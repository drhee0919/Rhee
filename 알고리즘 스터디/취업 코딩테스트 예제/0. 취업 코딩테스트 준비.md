##  코딩테스트 준비하기

#### 1. 기업별 출제경향 

> **1-1) 삼성** 
>
> - 삼성은 SW Expert Academy 라는 자체 사이트를 통해 코딩 테스트를 준비 및 풀이가 가능하게끔 조치. 
> - SW역량테스트는 A, B, C형으로 나뉘어 진행되었으며(난이도순), 3급 공채시험의 경우 A형 테스트와 가장 유사한 난이도를 보임 
> - 3시간의 제한시간, 2개의 문제 
> - 사용언어: C, C++, Java, Python 중 택1
> - 빈출 문제유형: 시뮬레이션, 구현,  DFS, BFS
> - 난이도가 높은 알고리즘보다는 구현이 복잡한 문제를 출제하는 경향 
> - 오프라인 코딩테스트 진행
>
> 
>
> **1-2) 라인(LINE)**
>
> - 3시간의 제한시간, 5~6문제 출제 
> - 사용언어: C++, JAVA, JavaScript, Python, Kotlin, Swift 중 택1
> - 빈출 문제유형: 구현, 탐색, 시뮬레이션, 자료구조 등 
>
> 
>
> **1-3) 카카오(Kakao)**
>
> - 블라인드 신입공채 방식 
> - 5시간의 제한시간, 7문제 출제 
> - 사용언어:  C++, JAVA, JavaScript, Python, Kotlin, Swift 중 택1
> - 빈출 문제유형: 구현, 문자열, 탐색, DP, DFS, BFS 그래프 등 (출제범위 방대)
> - 난이도가 높은 코딩테스트 
> - 일정 시간 후 출제문제의 해설을 인터넷에 공개하고 있으니 참조  



#### 2. 코딩테스트 채점 기준 

> **2-1) 시간 복잡도**
>
> - ex/ 1+2+3+4+ ... + N = ? 
>
>   ① 덧셈 연산을 N번 수행(N이 커지면 그에 비례하여 연산 수도 커짐) = O(N)
>
>   ② N(N+1)/2 수식을 사용 → N이 몇번이든 사칙연산 3번만 수행(연산횟수 상수) = O(1)
>
> - 빅-오 표기법에서는 가장 큰 항만 남기고 작은 항의 계수는 전부 생략할 수 있다. 
>
>   ex/ 어떤 알고리즘의 연산횟수 = 3N^2 + 10N + 700 → 시간복잡도는 O(N^2)
>
>   ​      (※ 위 알고리즘은 연산이 20배 증가하면 연산수는 약 400배 증가) 	
>
> - 통상 k중 반복문을 돌리면 시간 복잡도는 O(N^k) 가 된다. 
>
>   ex/ 2중 for문 → O(N^2), 3중 for문(ON^3)
>
> - 실제 코딩테스트에서 고안한 알고리즘의 연산횟수가 제한시간 내 돌아갈 정도인지 파악이 어려움 → 대략적인 파악을 먼저 하는 것이 일반적 
>
> 
>
> 
>
> **2-2) 공간 복잡도**
>
> - 문제에서 주어지는 입력 중 가장 메모리를 많이 사용하는 입력이 들어왔을 때, 해당 문제의 메모리 제한을 넘기지 않고 프로그램이 돌아갈지 파악해야 한다. 
>
> - 메모리 제한은 보통 128~512MB로 주어지는 경우가 많으므로, 가령 C++의 경우 int 기준으로 3천만 개 이상을 할당하면 위험하다.(※int = 4byte)
>
>   Tip. 배열의 크기가 천만이 넘어가면 혹시 잘못된 알고리즘이 아닌가 의심해보자 
>
> - 재귀함수를 사용하는 경우의 재귀 호출의 회수에 대해 유의하자 
>
> - 시간과 공간(메모리)는 trade-off 관계를 갖는게 일반적(메모리를 많이 잡아먹는 프로그램이 빠르다)