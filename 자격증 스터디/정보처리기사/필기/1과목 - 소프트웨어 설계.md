

### 1과목: 소프트웨어 설계



**1. 요구사항 확인**

> - 소프트웨어 생명주기 
>
> > * 일반적으로 사용되는 소프트웨어 생명주기 모형에는 
> >
> >   폭포수 모형(일방향), 프로토타입 모형(원형), 나선형 모형(폭포+프로토), 에자일 모형 등이 있음 
> >
> >   → 폭포수 모형과 에자일 모형의 차이점 위주로 학습할 것 	
> >
> > * 애자일 모형을 기반으로 하는 소프트 웨어 개발 모형에는 다음과 같은 사례 존재 
> >
> > ```
> > 스크럼, XP, 칸반, Lean, 크리스탈, ASD, FDD, DSDM, DAD ...
> > ```
> >
> > - 애자일 선언(Agile manifesto)의 내용적 특징 숙지 
> >
> > > 애자일 개발 4가지 핵심 가치(상호작용,SW,고객,변화)
> > >
> > > 애자일 개발 12가지 실행 지침(ex/ 지속 가능한 개발, 단순화, 주도적이고 조직적인 팀 )
>
> - 스크럼(Scrum) 기법
>
> > * 스크럼은 팀원 스스로가 스크럼 팀을 구성(self-organizing)해야 하며, 개발 작업에 관한 모든 것을 스스로 해결(cross-functional)할 수 있어야 한다. 
> > * <u>제품책임자(PO)</u>, 스크럼 마스터(SM), 개발팀(DT)으로 팀이 구성된다. 
> >
> > > 제품 책임자의 역할 숙지 : ex/ 백로그 작성 및 백로그 우선순위 지정 
> >
> > * 스크럼 개발 프로세스 숙지
> >
> > ```
> > 제품 백로그(모든 개발의 시작, 요구사항(User Story)) → 스프린트 계획회의 → 스프린트 → 일일 스크럼 회의 → 스프린트 검토 회의 → 스프린트 회고
> > 								   (끝, 스프린트 끝이나 일정 주기로 수행)
> > ```
> >
> > 
>
> - XP(eXtreme Programming)기법
>
> > * XP는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여과 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법 (고객이 최우선, 모든 절차에 고객 개입)
> > * XP의 5가지 핵심가치
> >
> > > 의사소통, 단순성, 존중, 피드백
> >
> > - XP개발 프로세스
> >
> > ```
> > 사용자 스토리 → 릴리즈 계획 수립 → 스파이크 → 이터레이션 → 승인검사 → 소규모 릴리즈
> > ```
> >
> > * XP의 주요 실천 방법
> >
> > > Pair Programming(짝 프로그래밍), Test-Driven Development(테스트 주도 개발), 
> > >
> > > Whole Team(전체 팀), Continuous Integration(계속적인 통합)
> > >
> > > Design Improvement(디자인개선) or Refactoring(리팩토링)
> > >
> > > Small Release(소규모 릴리즈)
>
> - 요구사항 정의
>
> > * 요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 **서비스에 대한 설명**과 정상적으로 운영되는데 **필요한 제약조건** 등을 나타냅니다. 
> > * 기술내용에 따른 구분
> >
> > > * 기능 요구사항 : 기능적 부분(반드시 수행되어야 하는 것, 사용자가 제공받기 원하는 기능)
> > > * 비기능 요구사항 : 기능 외적인 부분
> > >
> > > ```
> > > - 시스템 장비 구성 요구사항
> > > - 성능 요구사항
> > > - 인터페이스 요구사항
> > > - 데이터 요구사항
> > > - 테스트 요구사항
> > > - 보안 요구사항
> > > - 품질 요구사항
> > > (가용성, 정합성, 상호호환성, 대응성, 신뢰성, 사용성, 유지 관리성, 이식성, 확장성, 보안성 등으로 구분 )
> > > ```
> > >
> > > 
> >
> > * 기술관점에 따른 구분
> >
> > > * 시스템 요구사항 : 개발자관점, 전문적이고 기술적 용어(=소프트웨어 요구사항)
> > > * 사용자 요구사항 : 사용자 관점, 상대적으로 친숙한 표현
> >
> > * 요구사항 개발 프로세스 :  '요구사항 명세서(specification)' 가 산출되며 이를 검증함 
> >
> > ```
> > 요구사항 도출(수집) → 요구사항 분석 → 요구사항 명세 → 요구사항 확인(검증) 
> > ```
>
> - UML(Unified Modeling Language)
>
> > * UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통을 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어 
> > * 객체기술에 관한 표준화기구 OMG(Object Management Group) 에서 표준으로 지정
> > * 6개의 구조 다이어그램과 7개의 행위 다이어그램 작성 가능 
> > * UML의 구성 요소(사물, 관계, 다이어그램)
> >
> > > * 사물 : 관계가 형성될 수 있는 대상들
> > >
> > > ```
> > > - 구조사물: 시스템의 개념적, 물리적 요소
> > > 		   (클래스, 유스케이스, 컴포넌트, 노드 등)
> > > - 행동사물: 시간과 공간에 따른 요소들의 행위를 표현
> > > 		   (상호작용, 상태 머신 등)
> > > - 그룹사물: 요소들을 그룹으로 묶어 표현
> > > 		   (패키지)
> > > - 주해사물: 부가적인 설명이나 제약조건 등을 표현
> > > 		   (노트)
> > > ```
> > >
> > > * 관계: 사물과 사물 사의의 연관성을 표현 
> > >
> > > ```
> > > - 연관관계: 실선, 화살표(방향성이 있으면)로 표현
> > >             연관에 참여하는 객체의 개수를 의미하는 '다중도'를 선위에 표시
> > > - 집합관계: 하나의 사물이 다른 사물에 포함되어 있는 관계
> > >             포함되는 쪽에서 포함하는 쪽으로 '속이 빈 마름모'를 연결하여 표현
> > >             집합관계의 사물은 서로 독립적
> > > - 포함관계: 특수한 집환관계로 포함하는 사물이 포함되는 사물에 영향을 미침
> > >  		   포함되는 쪽에서 포함하는 쪽으로 '속이 칠해진 마름모'를 연결하여 표현
> > > - 일반화관계: 보다 일반적인 개념을 상위(부모), 보다 구체적인 개념은 하위(자식)
> > >               하위에서 상위인 사물 쪽으로 속이 빈 화살표를 연결하여 표현 
> > > - 의존관계: 연관관계와 같이 서로 연관은 있으나 필요에 의한 짧은 연관의 유지관계
> > >             영향을 주는 사물(이용자)이 영향을 받는 사물(제공자)쪽으로 
> > >             '점선 화살표' 를 연결하여 표현
> > > - 실체화관계: 사물이 있거나 해야 하는 기능(행위, 인터페이스)으로 그룹되는 관계
> > >               사물에서 기능쪽으로 '속이 빈 점선 화살표'를 연결하여 ㅍ현 
> > > ```
> > >
> > > * 다이어그램 : 사물의 관계를 도형으로 표현 
> > >
> > > ```
> > > - 구조적 다이어그램(주로 정적 모델링)
> > > 클래스 다이어그램
> > > 객체 다이어그램
> > > 컴포넌트 다이어그램: 구현 단계에서 사용
> > > 배치 다이어그램: 구현 단계에서 사용
> > > 복합체 구조 다이어그램
> > > 패키지 다이어그램
> > > 
> > > - 행위 다이어그램(주로 동적 모델링)
> > > 유스케이스 다이어그램
> > > 시퀸스 다이어그램
> > > 커뮤니케이션 다이어그램
> > > 상태 다이어그램
> > > 활동 다이어그램
> > > 상호작용 개요 다이어그램
> > > 타이밍 다이어그램 
> > > ```
> > >
> > > 



**2. 화면 설계**

> - 사용자 인터페이스 
>
> > * 사용자 인터페이스(UI)는 사용자와 시스템 간의 상호작용이 원활하게 이루어지도록 도와주는 장치나 소프트웨어를 의미 
> > * 사용자 인터페이스의 세가지 분야 
> >
> > ```
> > - 정보 제공과 전달을 위한 물리적 제어에 관한 분야
> > - 콘텐츠의 상세적인 표현과 전체적인 구성에 관한 분야
> > - 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능에 관한 분야 
> > ```
> >
> > * 사용자 인터페이스 구분
> >
> > ```
> > - CLI: 명령과 출력이 텍스트 형태로 이루어지는 인터페이스
> > - GUI: 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
> > - NUI: 사용자의 말이나 행동으로 기기를 조작하는 인터페이스 
> > ```
> >
> > * 사용자 인터페이스의 기본 원칙
> >
> > ```
> > - 직관성: 누구나 쉽게 이해하고 사용할 수 있어야 한다. 
> > - 유효성: 사용자의 목적을 정확하고 완벽하게 달성해야 한다. 
> > - 학습성: 누구나 쉽게 배우고 익힐 수 있어야 한다.
> > - 유연성: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다. 
> > ```
> >
> > * 사용자 인터페이스의 설계 지침 
> >
> > ```
> > - 사용자 중심: 사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경을 제공하며,
> > 			 실사용자에 대한 이해가 바탕이 되어야 한다. 
> > - 일관성: 버튼이나 조작 방법 등을 일관성 있게 제공하므로 사용자가 쉽게 기억하고 
> >  		 습득할 수 있게 설계해야 한다. 
> > - 단순성: 조작 방법을 단순화시켜 인지적 부담을 감소시켜야 한다. 
> > - 결과예측가능: 작동시킬 기능만 보고도 결과를 미리 예측할 수 있게 설계해야 한다. 
> > - 가시성: 메인 화면에 주요 기능을 노출시켜 최대한 조작이 쉽도록 설계해야 한다. 
> > - 표준화: 기능 구조와 디자인을 표준화하여 한 번 학습한 이후에는 쉽게 사용할 수 있어야
> > 		 한다. 
> > - 접근성: 사용자의 연령, 성별, 인종 등 다양한 계층이 사용할 수 있도록 설계해야 한다.
> > - 명확성: 사용자가 개념적으로 쉽게 인지할 수 있도록 설계해야 한다. 
> > - 오류 발생해결: 오류가 발생하면 사용자가 쉽게 인지할 수 있도록 설계해야 한다. 
> > ```
> >
> > 
>
> - UI 표준 및 지침
>
> > * UI표준: 전체 시스템에 포함된 모든 UI에 공통적으로 적용될 내용으로, 화면 구성이나 화면 이동
> >
> >   ​			   등이 포함된다.
> >
> > * UI지침: UI 요구사항, 구현 시 제약사항 등 UI 개발 과정에서 꼭 지켜야 할 공통의 조건을 
> >
> >   ​			  의미한다. 
> >
> > * 기술의 중립성 / 보편적 표현 보장성 / 기능의 호환성 확인을 위함 
> >
> > * 웹 표준 / 웹 접근성 / 웹 호환성과 상응 
> >
> > ```
> > -웹표준: 웹에서 사용되는 규칙 또는 기술을 의미하는 것으로, 웹 사이트 작성 시 이용하는 
> > 		HTML, JavaScript 등에 대한 규정, 웹 페이지가 다른 기종이나 플랫폼에서도 구현
> > 		되도록 제작하는 기법 등을 포함 
> > 		
> > -웹접근성: 누구나, 어떠한 환경에서도 웹 사이트에서 제공하는 모든 정보를 접근하여 이용
> > 		  할 수 있도록 보장하는 것을 의미
> > -웹호환성: 하드웨어나 소프트웨어 등의 다른 환경에서도 모든 이용자에게 동등한 서비스를 
> > 		  제공하는 것을 의미 
> > ```
> >
> > * 한국형 웹 콘텐츠 접근성 지침(KWCAG)
> >
> > > * 장애인과 비장애인의 동등하게 접근할 수 있는 웹 콘텐츠 제작 방법을 제시 
> >
> > ```
> > 1) 인식의 용이성 
> > - 대체 텍스트
> >   :텍스트가 아닌 이미지 등의 콘텐츠에는 그 의미를 인식할 수 있는 대체 텍스트를 사용
> >    해야 한다. 
> > - 멀티미디어 대체 수단
> >   :동영성, 음성 등 멀티미디어 콘텐츠에 대한 이해도를 높일 수 있도록 대체수단을 
> >    제공해야 한다.  (자막, 대본, 수화 등)
> > - 명료성 
> >   :콘텐츠는 색이나 명도, 방향, 모양, 크기, 소리 등에 관계없이 명확하게 전달될 수 
> >    있어야 한다.
> > 
> > 2) 운용의 용의성 
> > - 키보드 접근성
> >   :콘텐츠는 키보드만으로 접근할 수 있어야 한다.
> > - 충분한 시간 제공
> >   :콘텐츠는 읽고 사용하는데 충분한 시간을 제공해야 한다. 
> > - 광과민성 발작 예방
> >   :광과민석 발작을 일으킬 수 있는 콘텐츠는 제공하지 않아야 한다. 
> > - 쉬운 내비게이션
> >   :반복되는 영역은 건너뛸 수 있도록 하거나 용도나 목적을 이해할 수 있도록 링크 텍스트
> >    를 제공하는 등 콘텐츠를 쉽고 편리하게 내비게이션 할 수 있어야 한다. 
> >    
> > 3) 이해의 용이성
> > - 가독성 
> >   :콘텐츠는 읽고 이해하기 쉬워야 한다. 
> > - 예측 가능성
> >   :콘텐츠의 기능과 실행 결과는 예측이 가능해야 한다. 
> > - 콘텐츠의 논리성
> >   :콘텐츠는 선형 구조로 작성되어야 하고, 논리적인 순서를 제공해야 한다. 
> > - 입력 도움 
> >   :입력 오류를 방지하거나 정정할 수 있어야 한다. 
> > 
> > 4) 견고성
> > - 문법 준수 
> >   :웹 컨텐츠는 마크업언어(HTML, SGML, XML)의 문법 준수
> > - 접근성  
> >   :웹 애플리케이션은 접근성이 있어야 한다. 
> > ```
> >
> > * 네비게이션 : 사용자가 사이트에서 원하는 정보를 빠르게 찾을 수 있도록 다양한 경로나 방법을 					   제공
> >
> > ```
> > -메뉴(단추)
> >  : 계층 구조를 표현하는 기본 요소로, 사용자가 원하는 페이지로 이동할 수 있게 한다. 
> > -링크
> >  : 원하는 페이지로 이동할 수 있게 하는 하이퍼링크를 의미한다. 
> > -이미지맵
> >  : 그림에 하이퍼링크를 연결하여 원하는 페이지로 이동할 수 있게 한다. 
> > -사이트맵
> >  : 사이트의 전체 구조를 한 눈에 알아볼 수 있도록 트리 구조 형태로 만든것 
> > -사이트 메뉴바
> >  : 사이트의 좌측이나 우측에 메뉴 링크 등을 모아둔 것 
> > -내비게이션 바
> >  : 메뉴를 한 곳에 모아 놓은 그래픽이나 문자열 모음
> > -디렉터리
> >  : 주제나 항목을 카테고리별로 표현한 방식 
> > ```
> >
> > 
>
> - UI 설계도구 
>
> > - 와이어 프레임
> >
> > ```
> > 기획 단계 초기에 제작, 페이지에 대한 개략적인 레이아웃이나 UI요소 등에 대한 뼈대를 설계하는 단계
> > 
> > 사용툴: 손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등 
> > ```
> >
> > - 목업(Mock up)
> >
> > ```
> > 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형이다. 
> > 
> > 사용툴: 파워목업, 발사믹 목업 등 
> > ```
> >
> > - 스토리보드
> >
> > ```
> > 스토리보드는 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서.
> > 
> > 상단이나 우측에는 제목, 작성자 등을 입력하고, 좌측에는 UI화면, 우측에는 Description을 기입 
> > 
> > 사용툴: 파워포인트, 키노트, 스케치, Axure 등 
> > ```
> >
> > - 프로토타입
> >
> > ```
> > 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로서 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형 (사용성 테스트, 작업자 간 서비스 이해用)
> > 
> > 작성방법에 따라 페이퍼 프로토타입과 디지털 프로토타입으로 구분 
> > 
> > 사용툴: HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등 
> > ```
> >
> > - 유스케이스
> >
> > ```
> > 사용자 측면에서의 요구사항으로서, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술 
> > 
> > 일반적으로 다이어그램 형태로 작성되며, 다이어그램이 완성되면 각각의 유스케이스에 대한 유스케이스 명세서를 작성한다.  
> > ```
> >
> > 
>
> - UI요구사항 확인 
>
> > * 목표정의 → 활동 사항 정의 → UI요구사항 작성 순으로 진행 
>
> ```
> - 목표정의
> :사용자들을 대상으로 인터뷰를 진행한 후 사용자들의 의견이 수렴된 비즈니스 요구사항을 정의
>  
> - 활동사항 정의
> :조사한 요구사항을 토대로 앞으로 해야 할 활동 사항을 정의
> 
> - UI요구사항 작성
> :여러 경로를 통해 수집된 사용자들의 요구사항을 검토하고 분석하여 UI개발 목적에 맞게 작성
> [요구사항 요소 확인]→[정황 시나리오 작성]→[요구사항 작성]
> ```
>
> > * 요구사항 요소 확인 
> >
> > 파악된 요구사항 요소의 종류와 각각의 표현 방식등을 검토한다 
> >
> > ```
> > -데이터 요구
> > :사용자가 요구하는 모델과 객체들의 주요 특성을 기반으로 하여 데이터 객체 들을 정리.
> >  인터페이스 구성에 영향을 미치므로 반드시 초기에 확인
> > 
> > -기능 요구
> > :사용자의 목적 달성을 위해 무엇을 실행행 하는지를 동사형으로 설명한다. 
> >  기능 요구 리스트는 최대한 철저하게 정리해야 한다. 
> > 
> > -제품/서비스의 품질
> > :데이터 및 기능 요구 외에 제품의 품질, 서비스, 여기에 감성적인 품질 등을 고려하여 
> >  작성한다. 
> > 
> > -제약 사항
> > :제품 완료 데드라인, 전체 개발 및 제작에 필요한 비용, 시스템 준수에 필요한 규제가
> >  포함된다. 사전에 제약사항의 변경 가능 여부를 확인한다.
> > ```
> >
> > * 정황 시나리오 작성
> >
> > > 정황 시나리오는 사용자의 어떤 요구사항이 있을 때 이것을 만족하기 위해 사용자가 수행하는 과정을 이야기 형식으로 표현한 것 
> > >
> > > * 정황 시나리오는 요구사항 정의에 사용되는 초기 시나리오다 
> > > * 정황 시나리오는 개발하는 서비스의 모습을 상상하는 첫 번째 단계로 사용자 관점에서 시나리오를 작성해야 한다. 
> > > * 정황 시나리오는 개발하는 서비스의 모습을 상상하는 첫 번째 단계로 사용자 관점에서 시나리오를 작성해야 한다. 
> > > * 사용자는 주로 사용하는 기능 위주로 작성해야 하며, 함께 발생되는 기능들은 하나의 시나리오에 통합한다 
> > > * 육하원칙에 따라 간결하고 명확하게 작성한다 
> > > * 작성된 시나리오는 외부 전문가 또는 경험이 풍부한 사람에게 검토를 의뢰한다 
> >
> > * 요구사항 작성 
> >
> > > 요구사항은 정황 시나리오를 토대로 작성한다. 
> > >
> > > ex/ 정황시나리오에서 요구사항을 도출하는 내용 
> > >
> > > | 정황 시나리오                                                | 요구사항                                                     |
> > > | ------------------------------------------------------------ | ------------------------------------------------------------ |
> > > | 윤희는 회의가 끝난 후 핸드폰을 켰다. <br />주요 회의 내용을 메모하고 다음 약속을 <br />확인하는 한편, 회의 동안 중요한 전화가 <br />있었는지 확인한다. | - 문자를 입력할 수 있어야 한다. <br />-약속을 추적할 수 있어야 한다.<br /> -메시지 리스트를 확인할 수 있어야 한다. <br />- 핸드폰으로 구현이 가능해야 한다. |
> > >
> > > 
>
> - 품질 요구사항
>
> > 소프트웨어의 품질은 소프트웨어의 기능, 성능, 만족도 등 소프트웨어에 대한 요구사항이 얼마나 충족하는를 나타내는 소프트웨어 특성의 총체이다. 
> >
> > * ISO/IEC25010
> >
> > > ISO/IEC25010은 2011년 ISO/IEC9126을 개정하여 만든 소프트웨어 제품에 대한 국제 표준 
> > >
> > > * ISO/IEX 9216에서 제공한 소프트웨어 품질 특성 
> > >
> > > 기능성 / 신뢰성 / 사용성 / 효율성 / 유지 보수성 / 이식성 
> >
> > ```
> > - 기능성(functionality)
> > 기능성은 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 긴으을 제공하는지 여부를 나타낸다
> > 
> > +적절성/적합성(stability) 
> > :지정된 작업과 사용자의 목적 달성을 위해 적절한 기능을 제공할 수 있는 능력
> > +정밀성/정확성(accuracy)
> > :사용자가 요구하는 결과를 정확하게 산출할 수 있는 능력
> > +상호 운용성(Interoperability)
> > :다른 시스템들과 서로 어울려 작업할 수 있는 능력
> > +보안성(security)
> > :정보에 대한 접근을 권한에 따라 허용하거나 차단할 수 있는 능력
> > +호환성(compliance)
> > :기능고 관련된 표준, 관례 및 규정을 준수할 수 있는 능력 
> > 
> > 
> > -신뢰성(reliability)
> > 신뢰성은 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도를 나타낸다. 
> > 
> > +성숙성(maturity)
> > :결함으로 인한 고장을 피해갈 수 잇는 능력 
> > +고장 허용성(fault tolerance)
> > :결함 또는 인터페이스 결여 시에도 규정된 선성능 수준을 유지할 수 있는 능력 
> > +회복성(recoverability)
> > :고장 시 규정된성능 수준까지 다시 회복하고 직접적으로 영향 받은 데이터를 복구하 수 
> >  있는 능력 
> >  
> > 
> > -사용성(usability)
> > 사용성은 사용자와 컴퓨터 사이에 받생하는 어떠한 행위에 대하여 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도를 나타낸다. 
> > 
> > +이해성(understandability)
> > :소프트웨어의 적합성, 사용 방법 등을 사용자가 이해할 수 있는 능력 
> > +학습성(learnability)
> > :소프트웨어 애플리케이션을 학습할 수 있도록 하는 능력 
> > +운용성(operability)
> > :사용자가 소프트웨어를 운용하고 제어할 수 있도록 하는 능력 
> > +친밀성(attractiveness)
> > :사용자가 소프트웨어를 다시 사용하고 싶어 하도록 하는 능력 
> > 
> > 
> > -효율성(efficiency)
> > 효율성은 사용자가 요구하는 기능을 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도를 나타낸다. 
> > 
> > +시간 효율성(time behaviour)
> > :특정 기능을 수행할 때 적절한 반응 시간 및 처리 시간, 처리율을 제공할 수 있는 능력 
> > +자원 효율성(resource behaviour)
> > :특정 기능을 수행할 때 적절한 자원의 양과 종류를 제공할 수 있는 능력 
> > 
> > 
> > -유지 보수성(maintainability)
> > 유지 보수성은 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선 하거나 확장할 수 있는 정도를 나타낸다. 
> > 
> > +분석성(analyzability)
> > :결함이나 고장의 원인, 수정될 부분들의 식별을 가능하게 하는 능력 
> > +변경성(changeability)
> > :결함 제거 또는 환경 벼놔로 인한 수정 등을 쉽게 구현할 수 있는 능력 
> > +안정성(stability)
> > :변경으로 인한 예상치 못한 결과를 최소화할 수 있는 능력 
> > +시험성(testability)
> > :소프트웨어의 변경이 검증될 수 있는 능력 
> > 
> > 
> > -이식성(portablility)
> > 이식성은 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도를 나타낸다.
> > 
> > +적용성(adaptability)
> > :원래의 목적으로 제공되는 것 외에 다른 환경으로 변경될 수 있는 능력 
> > +설치성(installability)
> > :임의의 환경에서 소프트웨어를 설치할 수 있는 능력 
> > +대체성(replaceability)
> > :동일한 환경에서 동일한 목적을 위해 다른 소프트웨어를 대신하여 사용될 수 있는 능력 
> > +공존성(co-existence)
> > :자원을 공유하는 환경에서 다른 소프트웨어와 공존할 수 있는 능력 
> > ```
> >
> > 
>
> - UI 프로토타입 제작 및 검토 
>
> > - UI 프로토타입의 개요 
> >
> > 프로토타입은 사용자 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적인 형태의 모형으로, 테스트가 가능하다. 
> >
> > → 완전한 UI를 만들기 전에 사용자와의 의사소통을 위해 만든 모형 
> >
> > > * 프로토타입은 최대한 간단하게 만들어야 한다. 
> > > * 프로토타입은 일부 핵심적인 기능만을 제공하지만 최종 제품의 작동 방식을 이해시키는데 필요한 기능은 반드시 포함시ㅕ야 한다. 
> > > * 사용자의 요구사항이 모두 반영될 때까지 프로토타입을 계속하여 개선하고 보완해야한다. 
> > > * 프로토타이핑 및 테스트를 거치지 않고는 실제 사용자와 제품 간의 상호 작용 방식을 예측하기 어려우므로 실제 사용자를 대상으로 테스트하는 것이 좋다. 
> >
> > - UI 프로토타입의 장단점
> >
> > ```
> > 장점
> > - 사용자를 설득하고 이해시키기 쉽다 
> > - 요구사항과 기능의 불일치 등으로 인한 혼선을 예방할 수 있어 개발 시간을 줄일 수 있다
> > - 사전에 오류를 발견할 수 있다. 
> > 
> > 단점
> > - 프로토타입에 사용자의 모든 요구사항을 반영하기 위한 반복적인 개선 및 보완 작업
> >   때문에 작업 시간을 증가 시킬 수 있고, 필요 이상으로 자원을 소모할 수 있다. 
> > - 부분적으로 프로토타이핑을 진행하다보면 중요한 작업이 생략될 수 있다. 
> > ```
> >
> > - 프로토타이핑의 종류 
> >
> > > * 페이퍼 프로토타입
> > > * 디지털 프로토타입 
> >
> > - UI프로토타입 계획 및 작성 시 고려사항 
> >
> > > 프로토타입은 일반적으로 프로토타입 개발 계획을 수립하는 과정과 프로토타입을 개발한 후 결과를 보고하는 과정으로 진행된다 
> > >
> > > * 계획시 고려사항
> > >
> > > ```
> > > - 프로토타입의 개발 목적을 확인한다 
> > > - 소프트웨어, 하드웨어 등 프로토타입 개발에 필요한 환경을 마련한다 
> > > - 프로토타이핑 일정은 일반적으로 아키텍처가 확정된 이후 프로젝트의 시제 분석 작업
> > >   이 완료되기 이전에 진행해야 한다. 
> > > - 아키텍처의 해심이 되는 UI요소를 프로토타입의 범위로 잡는다 
> > > - 리더, 솔루션 담당자, 인프라 담당자, 개발 환경 리더, 공동 모듈 개발자, 
> > >   프로토타입 개발자 등 프로토타입의 개발 이누언을 확인하다 
> > > - 주어진 비즈니스 요구사항을 모두 만족하는지 프로토타입 아키텍처를 검증한다 
> > > - 프로토타입을 통해서 발생하는 이슈를 모두 취합하고 해결 방법을 제시한다 
> > > - 프로토타이핑을 진행하면서 분석, 설계, 개발, 테스트 등의 표준 가이드를 확정한다 
> > > - 프로토타이핑을 진행하면서 가장 많은 시간이 소요된 구간을 찾고 그 원인을 
> > >   분석하여 해결 방법을 제시한다 
> > > - 고객과 프로젝트 매니저, 프로젝트 리더 등에게 완성된 프로토타입을 시연한다 
> > > ```
> > >
> > > * 작성시 고려사항
> > >
> > > ```
> > > - 프로토타입의 작성 계획을 세운다 
> > > - 프로젝트 범위나 리스크 상황 등 주변 여건을 감안하여 프로토타입의 범위를 정한다 
> > > - 프로토타입을 통해서 얻고자 하는 목표를 확인한다 
> > > - 프로토타입의 개발 목표를 달성하기 위해 필요한 최소한의 기간과 비용을 확인한다 
> > > - 완성된 프로토타입이 실제 개발에 참조될 수 있는지 확인한다 
> > > - 프로토타입으로 검증할 범위가 너무 넓거나 기간이 길면 목표가 커져서 문제가 될 수 
> > >   있으니 주의한다. 
> > > ```
> > >
> > > 
> > >
> > > * UI프로토타입 제작 단계
> > >
> > > ```
> > > 1단계
> > > - 사용자의 요구사항을 분석하는 단계로, 사용자 관점에서 기본적인 요구사항이 확정될 
> > >   때까지 수행한다. 
> > >  
> > > 2단계
> > > - 요구사항을 충족하는 프로토타입을 종이에 손으로 직접 그리거나 편집 도구 등을 
> > >   이용하여 작성한다. 
> > > - 프로토타입은 개발할 시스템의 핵심적인 기능을 중심으로 개발한다. 
> > > 
> > > 3단계
> > > - 작성된 프로토타입을 기반으로 수정과 합의가 이뤄지는 단계이다. 
> > > - 개발자는 사용자가 요청한 제안 사항을 수용하여 보완 작업을 한다. 
> > > - 작업이 완료된 후 3단계로 되돌아간다. 
> > > - 사용자가 최종적으로 승인을 완료할 때까지 3단계와 4단계가 반복된다. 
> > > ```
> > >
> > > 
>
> - UI설계서 작성
>
> > - UI 설계서의 개요 
> >
> > UI설계서는 사용자의 요구사항을 바탕으로 UI설계를 구체화하여 작성하는 문서로, 상세 설계 전에 대표적인 화면들을 설계한다(상세설계 과정과 혼동 주의)
> >
> > > * UI 설계서는 기획자, 개발자, 디자이너 등과의 원활한 의사소통을 위해 작성한다 
> > > * UI 설계서는 UI설계사 표지, UI 설계서 개정 이력, UI요구사항 정의서, 시스템 구조, 사이트 맵, 프로세스 정의서, 화면 설계 순으로 작성한다 
> >
> > - UI설계서 표지 작성 
> >
> > > * 다른 문서와 혼동되지 않도록 프로젝트명 또는 시스템명을 포함시켜 작성한다.  
> >
> > - UI 설계서 개정 이력 작성 
> >
> > > * 설계서가 수정될 때마다 어떤 부분이 어떻게 수정되었는지 정리해 놓은 문서 
> > > * 처음 작성 시 첫 항목을 '초안작성', 버전을 1.0으로 설정 
> > > * 변경이 있을 시 마다 변경 내용을 적고 버전을 +0.1씩
> >
> > - UI요구사항 정의서 작성 
> >
> > > * 사용자의 요구사항을 확인하고 정리한 문서로, 사용자 요구사항의 UI적용 여부를 요구사항별로 표시한다. (RFP : Request fo Proposal)
> > > * 개정 이력서와 유사하게 생겼지만 RFP/확정여부/비고 컬럼으로 구성되어 있다. 
> >
> > - 시스템 구조 작성 
> >
> > > * 시스템 구조는 UI 요구사항와 UI프로토타입에 기초하여 전체 시스템의 구조를 설계한 것으로 사용자의 요구사항이 어떻게 시스템에 적용되는지 알 수 있다. 
> > > * 종단형태의 시스템 별, 사용자별 구성기능으로 도표 구성 
> >
> > - 사이트 맵 작성 
> >
> > > * 사이트 맵은 시스템 구조를 바탕으로 사이트에 표시할 콘텐츠를 한 눈에 알아 볼 수 있도록 메뉴별로 구분하여 설계한 것이다
> > > * 일반적으로 테이블 형태로 되어 있꼬, 위에서부터 아래로 내려가며 정보를 찾을 수 있는 계층형으로 되어 있는 것이 보통 
> > > * 사이트 맵을 작성한 후 사이트 맵의 상세 내용(site map detail)을 표 형태로 작성한다 
> >
> > - 프로세스 정의서 작성 
> >
> > > * 프로세스 정의서는 사용자 관점에서 사용자가 요구하는 프로세스들을 작업 직행 순서에 맞춰 정리한 것으로 UI의 전체적인 흐름을 파악할 수 있다. 
> > > * 횡으로 설계하는 화살표와 직사각형 으로 구성된 다이어그램 
> >
> > - 화면 설계 
> >
> > > * 화면 설계는 UI프로토타입과 UI프로세스를 참고하여 필요한 화면을 페이지별로 설계한 것 
> > > * 화면을 구분하기 위해 화면별 고유 ID를 부여하고 별도 표지를 작성한다 
> > > * 대표적인 화면들에 대해 포함될 정보, 인터페이스 요소, 레이아웃 등이 표현된 '와이어프레임' 을 대략적으로 스케치한다 
> > > * 주요 흐름을 스토리보드 형태로 작성한다. 디스크립션에는 시스템 정보, 인터렉션, 로직, 정책 등 디자인하거나 설계할 때 필요한 사항을 기록한다. 
> >
> > ```
> > <UI화면 설계의 기본 구성요소>
> > - 윈도우
> > 키보드나 마우스 등을 통해 데이터 입력 및 결과를 보여주는 화면상의 표시 영역
> > 
> > - 메뉴
> > 화면에서 수행할 기능들을 일정한 형태로 모아놓은 인터페이스
> > 사용자로 하여금 기능 선택을 수월하게 합니다.
> > 
> > - 아이콘
> > 수행하고자 하는 동작, 동작의 대상 등을 조그마한 그림 형태로 표현한 인터페이스입니다. 
> > 동일한 사용 환경 안에서는 아이콘의 크기는 동일하거나 규칙적인 크기 안에서 제공해야 합니다. 
> > 
> > - 포인터
> > 입력이 이뤄지는 지점을 알려주는 화면상의 커서입니다. 
> > 시스템의 상태를 포인터의 모양으로도 표시합니다.  
> > 
> > 
> > → 워드프로세스의 구성 화면을 생각하면 편하다 
> > ```
> >
> > 
>
> - UI상세 설계
>
> > - UI 시나리오 문서 개요 
> >
> > > * UI 상세 설계는 UI 설계써를 바탕으로 실제 설계 및 구현을 위해 모든 화면에 대한 자세한 설계를 진행하는 단계로, UI 상세 설계를 할 때는 반드시 시나리오를 작성해야 한다. 
> > > * UI시나리오 문서는 사용자 인터페이스의 기능 구조, 대표 화면, 화면 간 인터랙션의 흐름, 다양한 상황에서의 예외 처리 등을 문서로 정리한 것이다. 
> > > * UI 시나리오 문서에는 사용자가 최종 목표를 달성하기 위한 방법이 순차적으로 묘사되어 있다. 
> > > * UI 설계자 또는 인터랙션 디자이너가 UI 시나리오 문서를 작성하면 그래픽 디자이너가 시나리오를 바탕으로 디자인을 하고 개발자가 UI를 구현한다. 
> >
> > - UI시나리오 문서 작성 원칙 
> >
> > > * 개발자가 전체적인 UI의 기능과 작동 방식을 한눈에 이해할 수 있도록 '구체적'으로 작성한다. 보통 계층(Tree)구조 또는 플로차트(Flow Chart) 표기법으로 작성한다. 
> > > * 모든 기능에 공통적으로 적용될 UI요소와 <u>인터랙션</u>을 일반 규칙으로 정의한다. 
> > > * 대표 화면의 레이아웃과 그 화면에 속할 기능을 정의한다. 
> > > * 인터랙션의 흐름을 정의하며, 화면 간 인터랙션의 순서(sequence), 분기(branch), 조건(condition), 루프(loop)등을 명시한다. 
> > > * 예외상황에 대비한 다양한 케이스를 정의한다. 
> > > *  UI일반 규칙을 지키면서 기능별 상세 시나리오를 정의한다. 
> > > * UI시나리오 규칙을 지정한다. 
> >
> > * 인터랙션 
> >
> > > 사용자와 시스템을 연결하는 것이 UI라면 인터랙션은 UI를 통해 시스템을 사용하는 일련의 상호작용을 지칭. 
> > >
> > > ex/ 마우스ㄹ 화면의 어떤 아이콘을 클릭하면 화면이 그에 맞게 반응하는 것
> >
> > - UI시나리오 문서 작성을 위한 일반 규칙 
> >
> > ```
> > - 주요 키의 위치와 기능 
> > 모든 화면에 공통적으로 배치되는 주요 키의 위치와 기능을 설명한 것으로, 여러 화면 간의 일관성을 보장한다. 
> > 
> > - 공통 UI요소 
> > 체크박스, 라디오버튼, 텍스트 박스 등의 UI요소를 언제, 어떤 형태로 사용할 지를 정의하고, 사용자가 조작하면 어떻게 반응하는지 그 흐름을 설명한다. 
> > 
> > - 기본 스크린 레이아웃
> > 모든 화면에 공통적으로 나타나는 Titles, OK/Back, SoftKey, Option, Functional Buttons등의 위치와 속성을 기술한다. 
> > 
> > - 기본 인터랙션 규칙 
> > 터치 제스처등에 공통적으로 사용되는 조작 방법과 실행, 이전, 다음, 삭제, 이동 등의 화면 전환 효과 등을 기술한다. 
> > 
> > - 공통 단위 태스크 흐름 
> > 많은 기능들에 공통적으로 사용되는 삭제, 검색, 매녀 모드 상태 등에 대한 인터랙션 흐름을 설명한다. 
> > 
> > - 케이스 문서 
> > 다양한 상황에서 공통적으로 적용되는 시스템의 동작을 정의한 문서이다. 
> > (ex/ 사운드, 조명, 이벤트 케이스 등)
> > ```
> >
> > - 시나리오 문서의 요건 
> >
> > > * 완전성 
> > >
> > > > * 누락되지 않도록 최대한 상세히 기술한다 
> > > > * 해당 시스템의 기능보다는 사용자의 태스크의 초점을 맞춰 기술한다. 
> > >
> > > * 일관성
> > >
> > > > * 서비스 목표, 시스템 및 사용자의 요구사항, UI스타일 등 모두 일관성을 유지해야 한다. 
> > >
> > > * 이해성 
> > >
> > > > * 누구나 쉽게 이해할 수 있도록 설명한다. 
> > > > * 불분명하거나 추상적인 표현은 피한다.
> > >
> > > * 가독성 
> > >
> > > > * 표준화된 탬플릿 등을 활용하여 문서를 쉽게 읽을 수 있도록 해야한다. 
> > > > * v1.0, v2.0 등과 같이 문서 인덱스에 대한 규칙이나 목차를 제공한다. 
> > > > * 읽기 쉽도록 줄 간격, 단락, 들여쓰기 등의 기준을 마련한다. 
> > > > * 시각적인 효과를 위해서 여백이나 빈 페이지, 하이라이팅을 일관성 있게 지정한다. 
> > > > * 하이퍼링크 등을 지정하여 문서들이 서로 참조될 수 있도록 지정한다. 
> > >
> > > * 수정 용이성(modifiable)
> > >
> > > > * 시나리오의 수정이나 개선이 쉬워야 한다. 
> > >
> > > * 추적 용이성(traceable)
> > >
> > > > * 변경 사항은 언제, 어떤 부분이, 왜 발생했는지 쉽게 추적할 수 있어야 한다. 
> >
> > - UI 시나리오 문서로 인한 기대효과 
> >
> > ```
> > - 요구사항이나 의사소통에 대한 오류가 감소한다. 
> > - 개발 과정에서의 재작업이 감소하고, 혼선이 최소화된다. 
> > - 불필요한 기능을 최소화한다. 
> > - 소프트웨어 개발 비용을 절감시킨다. 
> > - 개발 속도를 향상시킨다. 
> > ```
> >
> > 



**3. 애플리케이션 설계**

> - 소프트웨어 아키텍처
>
> > - 소프트웨어 아키텍처의 설계 
> >
> > 소프트웨어 아키텍처는 소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다. 
> >
> > > * 소프트웨어 개발 시 적용되는 **원칙**과 **지침**이며, 이해 관계자들의 **의사소통 도구**로 활용된다. 
> > > * 소프트웨어 아키텍처의 설계는 기본적으로 좋은 품질을 유지하면서 <u>사용자의 비 기능적 요구사항으로 나타난 제약을 반영</u>하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정이다. 
> > > * <u>애플리케이션 분할 과정</u>과 <u>분할된 모듈에 할당될 기능</u>, <u>모듈 간의 인터페이스</u> 등을 결정한다. 
> > > * 소프트웨어 아키텍처 설계의 기본 원리로는 **모듈화 추상화**, **단계적 분해**, **정보 은닉**이 있다. 
> >
> > - 모듈화(Modularity)
> >
> > > 모듈화란 소프트웨어 성능을 향상시키거나 시스템의 수정 및 **재사용**, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다. 
> > >
> > > * 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 <u>재사용성을 향상</u>시킬 수 있다. 
> > > * 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다. 
> >
> > * 추상화(Abstraction) - 개략화, 모델화 
> >
> > > 추상화는 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것이다. 
> > >
> > > * 인간이 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법으로, 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트 할 수 있다. 
> > > * 추상화는 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다. 
> > >
> > > * 추상화의 유형 
> > >
> > > ```
> > > [과정 추상화]
> > > 자세한 수정 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있도록 설계하는 방법 
> > > 
> > > [데이터 추상화]
> > > 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터의 구조를 대표할 수 있는 표현으로 대체하는 방법 
> > > 
> > > [제어 추상화]
> > > 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법 
> > > ```
> >
> > - 단계적 분해(Stepwise Refinement)
> >
> > > 단계적 분해는 Niklaus Wirth에 의해 제안된 **하향식 설계 전략**으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법 
> > >
> > > * <u>추상화의 반복</u>에 의해 세분화된다. 
> > > * <u>소프트웨어의 기능에서부터 시작</u>하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다. 
> >
> > - 정보 은닉(Information Hiding)
> >
> > > 정보 은닉은 한 모듈 내부에 포함된 절차와 자료들의 정보가 감춰져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다. 
> > >
> > > * 어떤 모듈이 SW기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉된 모듈과 커뮤니케이션할 필요가 있을 때는 '필요한 정보만' 인터페이스를 통해 주고 받는다. 
> > > * 정보 은닉을 통해 <u>모듈을 독립적으로 수행</u>할 수 있고, 하나의 모듈이 변경되더라도 <u>다른 모듈에 영향을 주지 않으므로</u> **수정**, **시험**, **유지보수**가 용이하다. 
> >
> > 
> >
> > - 소프트웨어 아키텍처와 품질 속성 
> >
> > > 소프트웨어 아키텍처의 품질 속성은 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 **품질 평가 요소**들을 <u>시스템 측면</u>, <u>비즈니스 측면</u>, <u>아키텍처 측면</u>으로 구분하여 구체화시켜 놓은 것
> > >
> > > *  시스템 측면 
> > >
> > > | 품질속성    |                             내용                             |
> > > | ----------- | :----------------------------------------------------------: |
> > > | 성능        | 사용자의 요청과 같은 이벤트가 발생했을 때, 이를 적절하고 빠르게 처리 |
> > > | 보안        | 허용되지 않은 접근을 막고, 허용된 접근에는 적절한 서비스 제공 |
> > > | 가용성      |              장애 없이 정상적으로 서비스를 제공              |
> > > | 기능성      |            사용자가 요구한 기능을 만족스럽게 구현            |
> > > | 사용성      | 사용자가 소프트웨어를 사용하는데 헤매지 않도록 명확하고 편리하게 구현 |
> > > | 변경 용이성 | 소프트웨어가 처음 설계 목표와 다른 하드웨어나 플랫폼에서도 동작할 수 있도록 구현 |
> > > | 확장성      | 시스템의 용량, 처리능력 등을 확장시켰을 때 이를 효과적으로 활용할 수 있도록 구현 |
> > > | 기타 속성   |               테스트 용이성, 배치성, 안정성 등               |
> > >
> > > * 비즈니스 측면
> > >
> > > ```
> > > [품질속성]	[내용]
> > > ------------------------------------------------------------
> > > 시장적시성|정해진 시간에 맞춰 프로그램을 출시하는 것 
> > > 비용과혜택|개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들 것인지를 
> > >            결정하는 것 
> > >            유연성이 떨어지는 경우 유지보수에 많은 비용이 소모될 수 있다는 것을 
> > >            고려해야 한다. 
> > > 예상 시스템 수명 |시스템을 얼마나 오랫동안 사용할 것인지를 고려하는 것이다. 
> > >                   수명이 길어야 한다면 시스템 품질의 '변경 용이성', '확장성'을 
> > >                   중요하게 고려해야 한다. 
> > > 기타 속성 | 목표 시장, 공개 일정, 기존 시스템과의 통합            
> > > ```
> > >
> > > * 아키텍처 측면 
> > >
> > > | 품질속성       |                             내용                             |
> > > | -------------- | :----------------------------------------------------------: |
> > > | 개념적 무결성  | 전체 시스템과 시스템을 이루는 구성요소들 간의 일관성을 유지하는 것이다 |
> > > | 정확성, 완결성 | 요구사항과 요구사항을 구현하기 위해 발생하는 제약사항들을 모두 충족시키는 것 |
> > > | 구축 가능성    | 모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정을 변경할 수 있도록 하는 것 |
> > > | 기타 속성      |       변경성, 시험성, 적응성, 일치성, 대체성 등이 있음       |
> >
> > 
> >
> > - 소프트웨어 아키텍처의 설계 과정 
> >
> > > 아키텍처의 설계 과정은 **설계 목표 설정**, **시스템 타입 결정**, **아키텍처 패턴 적용**, **서브시스템 구체화**, **검토** 순으로 진행한다.
> > >
> > > * 설계 목표 설정
> > >
> > > > 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정한다. 
> > >
> > > * 시스템 타입 결정
> > >
> > > > 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택한다. 
> > > >
> > > > ```
> > > > [시스템 타입]: 일반적으로 4가지 타입 존재 
> > > > - 대화형 시스템
> > > > : 사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템 
> > > >   (온라인 쇼핑몰 등 대부분의 웹 애플리케이션)
> > > > 
> > > > - 이벤트 중심 시스템 
> > > > : 외부의 상태 변화에 따라 동작하는 시스템 
> > > >   (전화, 비상벨 등 내장SW)
> > > >   
> > > > - 변환형 시스템 
> > > > : 데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템 
> > > >   (컴파일러, 네트워크 프로토콜)
> > > >   
> > > > - 객체 영속형 시스템 
> > > > : DB를 사용하여 파일을 효과적으로 저장, 검색, 갱신 할 수 있는 시스템   \
> > > >   (서버 관리 소프트웨어)
> > > > ```
> > > >
> > > > 
> > >
> > > * 아키택처 패턴 적용 
> > >
> > > > <u>아키텍처 패턴</u>을 참조하여 시스템의 표준 아키텍처를 설계한다. 
> > > >
> > > > ※ 아키텍처 패턴이란?
> > > >
> > > > 여러 다양한 상황에서 아키텍처를 설계하는데 발생하는 문제들을 해결하기 위해 미리 만들어 놓은 전형적인 해결 방식 및 예제 
> > >
> > > * 서브시스템 구체화 
> > >
> > > > 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의한다. 
> > >
> > > * 검토 
> > >
> > > > 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 등을 검토한다. 
>
> - 아키텍처 패턴 
>
> > - 아키텍처 패턴(pattern)의 개요 
> >
> > 아키텍처 패턴은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미 
> >
> > > * 아키텍처 패턴은 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시 
> > > * 아키텍처 패턴에는 **서브시스템**들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙/지침 등이 포함되어 있다. 
> > > * 아키텍처 패턴을 아키텍처 스타일 또는 표준 아키텍처라고도 한다. 
> > > * 아키텍처 패턴의 장점 
> > >
> > > ```
> > > - 시행착오를 줄여 개발 시간을 단축시키고, 고품질의 소프트웨어를 생산할 수 있다. 
> > > - 검증된 구조로 개발하기 때문에 안정적인 개발이 가능하다. 
> > > - 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해진다. 
> > > - 시스템의 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지 
> > >   보수를 수행할 수 있다. 
> > > - 시스템의 특성을 개발 전에 예측하는 것이 가능해진다. 
> > > ```
> > >
> > > * 아키택처 패턴의 종류
> > >
> > > > **레이어 패턴**, **클라이언스-서버 패턴**, **파이프- 필터 패턴**, **모델 - 뷰 - 컨트롤러 패턴** 등 
> >
> > - 레이어 패턴(Layers pattern)
> >
> > > 레이어패턴은 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법 중의 하나다.
> > >
> > > * 레이어 패턴은 각각의 서브시스템들이 계층 구조를 이룸
> > >
> > > ​     (상위 계층은 하위 계층에 대한 서비스 제공자, 하위 계층은 상위 계층의 클라이언트)
> > >
> > > * 레이어 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다. 
> > >
> > > ​     변경 사항을 적용할 때도 서로 마주보는 두개의 계층에만 영향 → 변경 작업이 용이 
> > >
> > > * 레이어 패턴은 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다 
> > >
> > >   대표적인 사례 : OSI참조 모델 
> >
> > * 클라이언트 - 서버 패턴(Client-Server Pattern)
> >
> > >  하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
> > >
> > > ※ 컴포넌트: 독립적인 업무 기능을 수행하는 실행코드 기반으로 작성된 모듈입니다. 
> > >
> > > * C-S서버 패턴에서 사용자는 클라이언트와만 의사소통을 한다. 즉 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 **응답**을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다. 
> > > * 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다. 
> > > * 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적.
> > >
> > > ※**TCP-IP**, **컴포넌트**가 언급되면 클라이언트-서버 패턴 
> >
> > * 파이프 - 필터 패턴(Pipe-Filter Pattern) 
> >
> > > 파이프 - 필터 패턴은 <u>데이터 스트림</u> 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
> > >
> > > * 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이하다 
> > >
> > > * 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다 
> > >
> > > * 파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다
> > >
> > > * 대표적으로 UNIX의 쉘(Shell)이 있다. 
> > >
> > >   | source | -pipe1→ | Filter1 | -pipe2→ | Filter2 | -pipe3→ | Slink |
> > >   | ------ | ------- | ------- | ------- | ------- | ------- | ----- |
> > >   |        |         |         |         |         |         |       |
> >
> > - 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)
> >
> > > 모델-뷰-컨트롤러 패턴은 서브시스템을 3개의 부분으로 구조화하는 패턴
> > >
> > > * 모델: 서브시스템의 핵심 기능과 데이터를 보관한다.
> > > * 뷰: 사용자에게 정보를 표시한다. 
> > > * 컨트롤러: 사용자로부터 받은 입력을 처리한다. 
> > > * 모델-뷰-컨트롤러 패턴은 각 부분은 별도의 컴포넌트로 분리되어 있으므로 <u>서로 영향을 받지 않고</u> 개발 작업을 수행할 수 있다. 
> > > * 모델-뷰-컨트롤러 패턴에서는 여러개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 <u>대화형 어플리케이션</u>에 적합하다
> > >
> > > ※ 대화형 어플리케이션 
> > >
> > > ```
> > > 온라인 쇼핑몰이나 스마트폰 앱과 같이 사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 소프트웨어를 지칭 
> > > ```
> > >
> > > 
> >
> > - 기타 패턴 
> >
> > ```
> > [마스터 슬레이브 패턴]
> > - 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴포넌트에서
> >   처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴이다. 
> > - 마스터 컴포넌트는 모든 작업의 주체이고, 슬레이브 컴포넌트는 마스터 컴포넌트의 지시
> >   에 따라 작업을 수행하여 결과를 반환한다. 
> > - 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 주로 활용한다. 
> > 
> > ※장애 허용 시스템
> > :시스템의 일부가 결함 또는 고장으로 기능이 정지되더라도 해당 부분의 기능만 수행이
> >  불가능할 뿐 전체 시스템은 정상적으로 수행이 가능한 시스템 
> >  
> >  
> > [브로커 패턴(Broker Pattern)]
> > - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청
> >   에 맞는 컴포넌트와 사용자를 연결해준다. 
> > - 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴 
> > - 분산 환경 시스템에서 주로 활용 
> > 
> > [피어-투-피어 패턴]
> > - 피어(peer)를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 
> >   될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
> > - 클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용한다. 
> > 
> > ※ 멀티스레딩(multi threading)
> > :프로세스를 두개 이상의 실행 단위로 구분하여 자원을 공유하며 병렬로 수행하는 기능 
> > 
> > 
> > [이벤트-버스 패턴]
> > - 소스가 특정 채널에 이벤트 메시지를 발행(publish)하면, 해당 채널을 구독(subscribe)
> >   한 리스너들이 메시지를 받아 이벤트를 처리하는 방식 
> > - 4가지 주요한 컴포넌트로 구성
> >   ㆍ이벤트를 생성하는 소스(source)
> >   ㆍ이벤트를 수행하는 리스너(listener)
> >   ㆍ이벤트의 통로인 채널(Channel)
> >   ㆍ채널들을 관리하는 버스(Bus)
> >   
> >   
> > [블랙보드 패턴]
> > - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로, 
> >   컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다. 
> > - 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴 
> > - 음성 인식, 차량 식별, 신호 해석 등에 주로 활용
> > 
> > [인터프리터 패턴]
> > - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성 
> > - 특정 언어로 작서된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용되어진다. 
> >  
> > ```
> >
> > 
>
> - 객체지향
>
> > - 객체지향의 개요 
> >
> > 현실 세계의 개채(entity)를 기계의 부품처럼 하나의 객체(object)로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법을 지칭
> >
> > * 객체지향 기법은 <u>구조적 기법의 문제점</u>으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다. 
> > * SW의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 용이하다. 
> > * 단계적/계층적 표현 및 멀티미디어 데이터 및 병렬 처리지원 
> >
> > ※ 구조적 기법 
> >
> > 프로시저에 근간을 두고 하나의 커다란 작업을 여러개의 작은 작업으로 분할하고, 분할된 각각의 소작업을 수행하는 모듈을 작성한 다음 이들을 한 곳에 모아 큰 작업을 수행하는 하나의 완벽한 프로그램으로 작성하는 기법 
> >
> > * 객체지향의 주요 구성 요소와 개념 
> >
> > > **객체, 클래스, 캡슐화, 상속, 다형성(polymorphism)**
> >
> > - 객체(Object)
> >
> > > 객체는 <u>데이터</u>와 <u>데이터를 처리하는 함수</u>를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈 
> > >
> > > ```
> > > [데이터]
> > > - 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다. 
> > > - 속성(Attribute), 상태, 변수, 상수, 자료 구조 라고도 한다. 
> > > 
> > > [함수]
> > > - 객체가 수행하는 기능, 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘 
> > > - 객체의 상태를 참조하거나 변경하는 수단이 되는 것으로 
> > >   메소드(Method,행위), 서비스(Service), 동작(Operation), 연산이라고도 지칭한다. 
> > > ```
> > >
> > > * 객체의 특성 (자동차에 비유)
> > >
> > > ```
> > > - 객체는 독립적으로 식별 가능한 이름을 가지고 있다. 
> > >   (자동차는 번호판으로 다른 자동차 객체와 구분된다.)
> > >   
> > > - 객체가 가질 수 잇는 조건을 '상태(state)' 라고 하는데, 일반적으로 상태는 시간에
> > >   따라 변한다.
> > >   (자동차는 '정지', '이동' 등의 상태가 존재하며, 이는 고정된 것이 아니라 시간에 
> > >    따라 변한다.)
> > >    
> > > - 객체와 객체는 '상호 연관성' 에 의한 관계가 형성된다. 
> > >   (화재 발생 시 소방차, 구급차, 경찰차는 긴밀하게 협조하여 화재를 진압하고 환자를
> > >    이송하며, 교통을 정리하는 관계가 형성된다)
> > >    
> > > - 객체가 반응할 수 있는 메시지(Message)의 집합을 행위라고 하며, 객체는 행위의 
> > >   특징을 나타낼 수 있다. 
> > >   (자동차 객체는 '가속 페달을 밟는 행위' 를 하면 '가속' 하는 특징을 나타내고, 
> > >    '브레이크를 밟는 행위'를 하면 '감속' 하는 특징을 나타낸다.)
> > >    
> > > - 객체는 일정한 기억장소를 가지고 있다. 
> > >   (자동차는 주차장에 있거나 도로 위에 있거나 일정한 물리적 공간을 점유한다. )
> > >    
> > > ```
> > >
> > > * 객체의 메소드(함수)는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다. 
> > >
> > > ```
> > > [구조적 기법] 프로그램 = 데이터 + 함수 
> > > [객체지향 기법] 객체 = 데이터 + 함수 
> > > 			  프고그램 = 객체 + 객체 (객체간에는 메시지를 주고받음)
> > > ```
> > >
> > > 
> >
> > - 클래스(Class)
> >
> > > 클래스의 공통된 속성과 연산(행위)을 갖는 <u>객체의 집합</u> 으로, 객체의 일반적인 타입(type)을 
> > >
> > > 의미한다. 
> > >
> > > * 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀 
> > > * 클래스에 속한 각각의 객체를 인스턴스(Instance)라 하며, 클래스로부터 새로운 객체를 생성하는 것은 인스턴스화(Instantiation)라고 한다. 
> > > * 동일 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가지고 있으면서,     그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타내게 된다. 
> > > * 최상위 클래스는 상위 클래스를 갖지 않는 클래스를 지칭 
> > > * 슈퍼클래스(Super Class)는 특정 클래스의 상위(부모) 클래스이고, 
> > > * 서브클래스(Sub Class)는 특정 클래스의 하위(자식) 클래스를 의미한다. 
> >
> > - 캡슐화(Encapsulation)
> >
> > > 캡슐화는 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다. 
> > >
> > > * 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 <u>은폐(정보은닉)</u> 되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다
> > > * 캡슐화된 객체들은 재사용이 용이하다. 
> > > * 객체들 간의 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다. 
> >
> > * 상속(Inheritance)
> >
> > > 상속은 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것이다. 
> > >
> > > * 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있다. 
> > >
> > > * 하위 클래스는 상위 클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다. 
> > >
> > > * 상위 클래스의 속성과 연산을 하위 클래스가 사용할 수 있기 때문에 객체와 클래스의 재사용, 즉 소프트웨어의 재사용(Reuse)을 높이는 중요한 개념이다. 
> > >
> > > * 다중상속(Multiple Inheritance)
> > >
> > >   : 한개의 클래스가 두개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것 -
> >
> > - 다형성(Polymorphism)
> >
> > > 다형성은 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미한다. 
> > >
> > > * 객체(클래스)들을 동일한 메소드명을 사용하며 같은 의미의 응답을 한다. 
> > > * 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것 
> > >
> > > ex/  '+' 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능구현 
> > >
> > > 
>
> 
>
> - 모듈
>
> > - 모듈의 개요 
> >
> > > 모듈은 <u>모듈화를 통해 분리된 시스템의 각 기능들</u>로, 서브루틴, 서브 시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용한다. 
> > >
> > > * 모듈은 <u>단독으로 컴파일</u>이 가능하며, <u>재사용 할 수 있다</u>. 
> > > * **모듈의 기능적 독립성**은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어진다. 
> > > * 독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, <u>오류가 발생해도 쉽게 발견</u>하고 해결할 수 있다. 
> > > * 모듈의 독립성을 **결합도(Coupling)**, **응집도(Cohesion)**에 의해 측정되며, 독립성을 높이려면 모듈의 <u>결합도는 약하게</u>, <u>응집도는 강하게</u>, <u>모듈의 크기는 작게</u> 만들어야 한다. 
> >
> > 
> >
> > - 결합도(Coupling) - (여러)모듈 간에 상호 의존도  
> >
> > > 결합도는 모듈 간의 <u>상호 의존하는 정도</u> 또는 <u>두 모듈 사이의 연관 관계</u>를 의미
> > >
> > > * 다양한 결합으로 모듈을 구성할 수 있으나 결합도가 약할수록 품질이 높고, 강할 수록 품질이 낮다. 
> > > * 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다 
> > > * 결합도의 종류에는 **자료 결합도, 스탬프 결합도, 제어 결합도, 외부결합도, 공통 결합도, 내용 결합도**가 있고 결합도는 결합도약함←--------- →결합도 강함 
> > >
> > > ```
> > > 1) 자료 결합도 
> > > :모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도 
> > > 
> > > 2) 스탬프(검인) 결합도 
> > > :모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도 
> > > 
> > > 3) 제어 결합도(control coupling)
> > > : 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어요소(Funtion Code, Switch, Tag, Flag)를 전달하는 결합도이다. 
> > > 
> > > 4) 외부 결합도(External Coupling)
> > > : 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
> > > 
> > > 5) 공통(공유) 결합도(Common Coupling) 
> > > : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도이다. 
> > > 
> > > 6) 내용 결합도(Content Coupling)
> > > : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참졷하거나 수정 할 때의 
> > >   결합도이다. 
> > > ```
> > >
> > > 
> >
> > - 응집도(Cohesion) - 모듈 내부의 처리 요소들 간의 기능적 연관도 
> >
> > > 응집도는 <u>정보 은닉</u> 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들이 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
> > >
> > > - 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다 
> > >
> > > - 응집도 가 강한쪽부터 약한 순서대로 
> > >
> > >   **기능적 응집도, 순차적 응집도,  교환(통신)적 응집도, 절차적 응집도, 시간적 응집도, 논리적 응집도 ** 가 있다. 
> > >
> > >   ```
> > >   1) 기능적 응집도(Functional Cohesion)
> > >   :모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 
> > >   
> > >   2) 순차적 응집도(Sequential Cohesion)
> > >   :모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 
> > >    사용할 경우의 응집도 
> > >    
> > >   3) 교환(통신)적 응집도(Communicaiton Cohesion)
> > >   :동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 
> > >    경우의 응집도 
> > >    
> > >   4) 절차적 응집도(Procedual Cohesion)
> > >   :모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적
> > >    으로 수행할 경우의 응집도 
> > >   
> > >   5) 시간적 응집도(Temporal Cohesion)
> > >   :특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
> > >   
> > >   6) 논리적 응집도(Logical Cohesion)
> > >   :유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 
> > >    경우의 응집도 
> > >    
> > >   7) 우연적 응집도(Coincidental Cohesion)
> > >   :모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도 
> > >   ```
> > >
> > >   
> >
> > - 팬인(Fan-In) / 팬아웃(Fan-Out)
> >
> > > * 모듈에 들어오면 팬인, 모듈에서 나가면 팬아웃 
> > > * 팬인은 어떤 모듈을 제어(호출)하는 모듈의 수를 나타낸다. 
> > > * 팬아웃은 어떤 모듈에 의해 제어(호출)되는 모듈의 수를 나타낸다. 
> > > * 팬인과 팬아웃을 분석하여 시스템의 복잡도를 알 수 있다. 
> > > * 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요하다. 
> > > * 팬아웃이 높은 경우 불필요하게 다른 모둘을 호출하고 있는지 검토하고, 단순화 시킬 수 있는지 여부에 대한 검토가 필요하다. 
> > > * 시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계해야 한다. 
>
> - 코드
> - 디자인패턴sion





**4. 인터페이스 설계**

> - 시스템 인터페이스 요구사항 분석
> - 인터페이스 요구사항 검증
> - 인터페이스 방법 명세화 
> - 미들웨어 솔루션 명세 