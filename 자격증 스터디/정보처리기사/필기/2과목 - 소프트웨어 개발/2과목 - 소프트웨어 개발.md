### 2과목: 소프트웨어 개발



**1. 데이터 입출력 구현**

> - 자료 구조
>
> > - 자료 구조의 정의 
> >
> > > 저장 공간의 효율성과 실행시간의 신속성을 위해 저장법, 자료간의 관계, 처리방법등을 연구분석 하는 것 
> > >
> > > * 어떤 자료구조에서도 필요한 모든 연산들을 처리할 수 있다. 
> > > * 자료 구조에 따라 프로그램 실행 시간이 달라진다. 
> >
> > - 자료구조의 분류: **선형구조(Linear Structure)**, **비선형구조(Non-Linear Structure**)
> >
> > ```
> > [선형구조]
> > 배열(array)
> > 선형 리스트(linear list) -연속 리스트(continguous list)
> > 					  ㄴ연결 리스트(linked list) 
> > 스택(stack)
> > 큐(Queue)
> > 데큐(Deque)
> > 
> > 
> > [비선형 구조]
> > 트리(tree)
> > 그래프(graph)
> > ```
> >
> > 
>
> - 데이터 저장소/데이터베이스/DBMS
>
> > - 데이터 저장소 
> >
> > > 소프트웨어 개발 과정에서 다루어야 할 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것을 의미 
> > >
> > > * **논리 데이터 저장소** 와 **물리 데이터 저장소로 나뉜다**
> > >
> > > ```
> > > 논리 데이터 저장소
> > > : 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화
> > > 
> > > 물리 데이터 저장소 
> > > : 소프트웨어 운용환경의 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장한 것 
> > > ```
> > >
> > > * 논리 데이터저장소를 거쳐 물리 데이터 저장소를 구축하는 과정은 
> > >
> > >   데이터베이스를 구축하는 과정과 동일하다. 
> >
> > 
> >
> > * 데이터 베이스 
> >
> > > 데이터베이스는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임
> > >
> > > * 통합된 데이터(integrated data)
> > >
> > > > 자료의 **중복을 배제**한 데이터의 모임
> > >
> > > * 저장된 데이터(stored data)
> > >
> > > > 컴퓨터가 접근할 수 있는 **저장 매체**에 저장된 자료 
> > >
> > > * 운영 데이터(operational data)
> > >
> > > > **조직의 고유한 업무를 수행**하는 데 존재 가치가 확실하고 없어서는 안될 반드시 필요한  자료 
> > >
> > > * 공용 데이터(shared data)
> > >
> > > > 여러 응용 시스템들이 **공동**으로 소유하고 유지하는 자료 
> >
> > 
> >
> > - DBMS(데이터베이스 관리 시스템)
> >
> > > 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어 
> > >
> > > * 기존의 파일 시스템이 갖던 데이터의 **중복성**, **종속성** 문제를 해결하기 위해 제안 
> > > * 모든 응용프로그램들이 DB를 공용할 수 있도록 관리
> > > * DBMS는 DB의 구성, 접근방법, 유지관리에 대한 모든 책임을 진다. 
> > > * DBMS의 필수 기능: **정의(Definition), 조작(Manipulation), 제어(Control)**
> > >
> > > * 정의기능
> > >
> > > > DB에 저장될 데이터의 **형(type)과 구조에 대한 정의**, **이용방식**, **제약조건** 등을 명시하는   기능 
> > >
> > > * 조작 기능 
> > >
> > > > 데이터의 <u>검색, 갱신, 삽입, 삭제 (Select, Update, Insert, Delete)</u> 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능 
> > >
> > > * 제어 기능 
> > >
> > > > * DB를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 **무결성**이 유지되도록 제어해야 한다. 
> > > > * 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안을 유지하고 **권한(Authority)**을 검사할 수 있어야 한다. 
> > > > * 여러 사용자가 DB에 동시에 접근하여 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 **병행제어(Concurrency Control)**를 할 수 있어야 한다.
> > >
> > > * DBMS의 장단점 
> > >
> > > ```
> > > [장점]
> > > - 데이터의논리적 물리적 독립성이 보장된다
> > > - 데이터의 중복을 피할 수 있어 기억 공간이 절약된다.
> > > - 저장된 자료를 공동으로 이용할 수 있다. 
> > > - 데이터의 일관성을 유지할 수 있다. 
> > > - 데이터의 무결성을 유지할 수 있다. 
> > > - 보안을 유지할 수 있다. 
> > > - 데이터를 표준화할 수 있다. 
> > > - 데이터를 통합하여 관리할 수 있다. 
> > > - 항상 최신의 데이터를 유지한다.
> > > - 데이터의 실시간 처리가 가능하다. 
> > > ```
> > >
> > > ```
> > > [단점]
> > > - 데이터베이스의 전문가가 부족하다(인력난)
> > > - 전산화 비용이 증가한다.
> > > - 대용량 디스크로의 집중적인 Access로 과부하(Overload)가 발생한다. 
> > > - 파일의 예비(Backup)와 회복(Recovery)이 어렵다. 
> > > - 시스템이 복잡하다. 
> > > ```
> > >
> > > 
>
> - 데이터 입출력
>
> > - 데이터 입출력의 개요
> >
> > > 소프트웨어의 기능 구현을 위하여 데이터베이스에 데이터를 <u>입력 및 출력</u>하는 것 뿐만이 아닌 <u>데이터를 조작하는 모든 행위</u>를 의미
> > >
> > > * 해당 작업은 SQL(Structured Query Language)를 사용하여 이루어진다. 
> > > * 개발 코드 내 SQL코드를 삽입하거나, 객체와 데이터를 연결하는 것을 **데이터 접속(Data Mapping)**이라고 한다. 
> > > * SQL을 통한 데이터베이스 조작을 수행할 때 '하나의 논리적 기능을 수행하기 위한 작업의 단위' or '한꺼번에 모두 수행되어야 할 일련의 연산들을 '**트랜잭션(Transaction)'**이라 지칭. 
> >
> > 
> >
> > * SQL
> >
> > > 국제표준 데이터베이스 언어로, 많은 회사에서 RDB(관계형 데이터베이스) 지원언어로 채택
> > >
> > > * **관계대수**, **관계해석**을 기초로 한 혼합 데이터 언어
> > > * 질의어 + 데이터 <u>정의, 조작, 제어</u> 기능 보유 
> > > * **데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)**로 구분됨 
> >
> > 
> >
> > - 데이터 접속(Data Mapping)
> >
> > > 소프트웨어 기능 구현을 위해 프로그래밍 코드와 데이터베이스의 데이터를 연결하는 것 
> > >
> > > * 관련기술: **SQL Mapping,  ORM**
> > > * SQL Mapping
> > >
> > > > 프로그래밍 코드 내에 SQL을 직접 입력하여 DBMS의 데이터에 접속하는 기술.
> > > >
> > > > ```
> > > > [관련 프레임워크]
> > > > : JDBC, ODBC, MyBatis 등 
> > > > ```
> > >
> > > * ORM(Object-Relational Mapping)
> > >
> > > > 객체지향 프로그래밍에서 **객체**와 관계형 데이터베이스의 **데이터**를 연결하는 기술 
> > > >
> > > > ```
> > > > [관련 프레임워크]
> > > > : JPA, Hibernate, Django 
> > > > ```
> > >
> > > 
> > >
> > > - 트랜젝션(Transaction)
> > >
> > > > 트랜잭션을 제어하기 위해서 사용하는 명령어를 TCL(Transaction Control Language)라고 지칭
> > >
> > > ```
> > > - COMMIT : 트랜잭션을 반영하는 명령어 
> > > - ROLLBACK : 트랜잭션이 행한 모든 변경 작업을 취소하고 이전상태로 돌리는 연산
> > > - SAVEPOINT(=CHECKPOINT)
> > > : 트랜잭션 내에 ROLLBACK할 위치인 저장점을 지정하는 명령어 
> > > ```
> > >
> > > 
>
> - 절차형 SQL
>
> > - 절차형 SQL의 개요 
> >
> > > 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL을 의미 
> > >
> > > 단일 SQL문장으로 처리하기 어려운 연속적인 작업들을 처리하는데 적합.
> > >
> > > * 다양한 기능을 수행하는 **저장 모듈**을 생성할 수 있다. 
> > > * DBMS엔진에서 직접 실행되기 때문에 입출력 패킷이 적은 편 이다. 
> > > * BEGIN-END 형식으로 작성되는 **블록(Block)구조**로 되어 있기 때문에 <u>기능별 모듈화</u>가 가능하다. 
> > > * 절차형 SQL의 종류에는 **프로시저, 트리거, 사용자정의함수** 가 있다. 
> > >
> > > > * 프로시저
> > > >
> > > > > 특정 기능을 수행하는 일종의 트랜잭션 언어. **호출**을 통해 실행되어 미리 저장해 놓은 SQL작업을 수행한다. 
> > > >
> > > > * 트리거(Trigger)
> > > >
> > > > > 데이터베이스 시스템에서 데이터의 입력, 갱신, 삭제 등의 **이벤트**(데이터 조작 작업) 가 발생할 때마다 관련 작업이 자동으로 수행된다. 
> > > >
> > > > * 사용자 정의 함수 
> > > >
> > > > > 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하며, 
> > > > >
> > > > > 종료 시 예약어 **Return** 을 사용하여 처리 결과를 **단일값**으로 반환한다. 
> > > > >
> > > > > 
> >
> > - 절차형 SQL의 테스트와 디버깅 
> >
> > > 절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 
> > >
> > > 실행 통해 결과를 확인하는 테스트 과정을 수행한다. 
> > >
> > > * 테스트 전 생성을 통해 **구문오류(syntax error)**나 **참조오류**의 존재 여부를 확인하다 
> > > * 오류 및 경고 메시지가 상세히 출력되지 않으므로 **show명령어**를 통해 내용을 먼저 확인하고 문제를 수정한다. 
> > > * 1) 디버깅을 통해 로직을 검증하고 → 2) 결과를 통해 최종적으로 확인한다. 
> > > * DB에 변화를 줄 수 있는 삽입 및 변경 관련 SQL문을 **주석처리**하고 출력문으로 화면에 출력하여 확인하다. 
> >
> > - 쿼리 성능 최적화 
> >
> > > 데이터 입출력 애플리케이션의 성능 향상을 위해 SQL코드를 최적화하는 것 
> > >
> > > * 최적화하기 전 성능 측정 도구인 **APM(Application Performance Management/Monitoring)** 으로 최적화할 쿼리선정
> > > * 최적화 할 쿼리에 대해 **옵티마이저(Optimizer)**가 수립한 실행 계획을 검토하고 SQL코드 및 인덱스를 재구성함 
> > >
> > > ※옵티마이저(Optimizer)
> > >
> > > ​    :(DBMS에 내장) SQL이 효율적으로 수행되는  '최적의 경로' 를 찾아주는 모듈 

**2. 통합 구현**

> - 단위 모듈 테스트(※내용상 출제율 C 단위모듈 포함)
>
> > - 단위모듈(Unit Module)
> >
> > > 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것
> > >
> > > * 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 칭함
> > >
> > > * 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 함
> > >
> > > * 두 개의 단위 모듈이 합쳐지면 두개의 기능을 구현할 수 있음
> > >
> > > * 단위 모듈의 구성 요소 : **처리문**, **명령문**, **데이터 구조** 등
> > >
> > > * 독립적인 컴파일 가능, 다른 모듈에 호출되거나 삽입되기도 함
> > >
> > > * 단위 모듈 구현 순서 : <u>단위 기능 명세서 작성 → 입출력 기능 구현 → 알고리즘 구현</u> 
> >
> > - 단위 모듈 명세서 작성 
> >
> > > 설계 과정에서 작성하는 기능 및 코드 명세서나 설계 지침과 같이 단위 기능을 명세화한 문서들을 의미
> > >
> > > * 이 단계에서는 복잡한 시스템을 단순하게 구현하기 위한 **추상화** 작업 필요
> > >
> > > * 대형 시스템을 **분해**해 단위 기능을 구분하고, 각 기능들을 계층적으로 구성하는 구조화 과정을 거침
> > >
> > > * 단위 기능 명세서 작성 시 모듈의 독립적인 운용과 한 모듈 내의 정보가 다른 모듈에 영향을 주지 않도록 **정보 은닉**의 원리 고려
> >
> > - 입출력 기능 구현
> >
> > > 단위 기능 명세서에서 정의한 데이터 형식에 따라 입출력 기능을 위한 알고리즘 및 데이터 구현
> > >
> > > * 이 단계에서는 단위 모듈 간의 연동 또는 통신을 위한 입출력 데이터를 구현
> > >
> > > * 입출력 기능 구현 시 CLI, GUI와의 연동 고려
> > > * CLI(Command Line Interface) : Telnet이나 DOS와 같이 키보드를 통해 명령어를 입력받음
> > > * GUI(Graphical User Interface) : 윈도우, MacOS와 같이 키보드, 마우스 등의 도구를 통해 화면의 아이콘, 메뉴 등 그래픽 요소로 명령을 입력 받음
> > > * 입부출력 기능 구현 시 네트워크나 외부 장치의 입출력은 Open Source API를 이용하면 간편 구현 가능
> > >
> > > ※ IPC(Inter Process Communication)
> > >
> > > ```
> > > [IPC(Inter-Process Communication)]
> > > 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
> > > 
> > > - 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현 가능
> > > 
> > > - IPC의 대표 메소드 5가지
> > > > Shared Memory:다수의 프로세스가 공유 가능한 메모리를 구성해 프로세스 간 통신 			   수행
> > > 
> > > > Socket:네트워크 소켓을 이용해 네트워크를 공유하는 프로세스들 간 통신을 수행
> > > 
> > > > Semaphores:공유 지원에 대한 접근 제어를 통해 프로세스 간 통신 수행
> > > 
> > > > Pipes & named Pipes: 'Pipe'라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신 수행
> > > 
> > > > Message Queuing: 메세지가 발생하면 이를 전달하는 형태로 프로세스 간 통신 수행 
> > > 
> > > 
> > > ```
> > >
> > > 
> >
> > - 알고리즘 구현 
> >
> > > 입출력 데이터를 바탕으로 **단위 기능별 요구 사항**들을 구현 가능한 언어를 이용해 **모듈**로 구현
> > >
> > > * 구현된 단위 기능들이 **사용자의 요구와 일치**하는지 확인하는 과정 필요
> > > * 구현되는 모듈의 종류를 단위 기능의 종류에 따라 다음으로 구분 함
> > >
> > > ```
> > > > 디바이스 드라이버 모듈 : 하드웨어 주변 장치의 동작을 구현한 모듈
> > > 
> > > > 네트워크 모듈 : 네트워크 장비 및 데이터 통신을 위한 기능을 구현한 모듈
> > > 
> > > > 파일 모듈 : 컴퓨터 내부의 데이터 구조 영역에 접근하는 방법을 구현한 모듈
> > > 
> > > > 메모리 모듈 : 파일을 프로세스의 가상 메모리에 매칭/해제하는 방법, 프로세스 사이의 통신 기능을 구현한 모듈
> > > 
> > > > 프로세스 모듈 : 하나의 프로세스 안에서 다른 프로세스를 생성하는 방법을 구현한 모듈
> > > ```
> > >
> > > 
> >
> > - 단위 모델 테스트 개요 
> >
> > > 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것
> > >
> > > * 단위 테스트라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법을 사용
> > >
> > > > * **화이트박스 테스트** : 모듈의 소스 코드를 오픈시킨 상태에서 소스 코드의 모든 **논리적** 경로를 테스트하는 방법
> > > > * **블랙박스 테스트** : 소프트웨어가 수행할 특정 **기능**이 완전히 작동되는 것을 입증하는 테스트
> > >
> > > * 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없음 
> >
> > - 테스트 케이스(Test Case)
> >
> > > 모듈이 올바르게 작성되었는지 확인하기 위해 모듈에 입력될 수 있는 여러 값들과 예상 결과들을 나열해 목록을 만드는 과정
> > >
> > > * 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당
> > > * 테스트 케이스를 이용하지 않는 직관적인 테스트는 인력과 시간을 낭비할 수 있음
> > > * ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같음
> > >
> > > ```
> > > > 식별자(Identifier) : 항목 식별자, 일련번호
> > > 
> > > > 테스트 항목(Test Item) : 테스트 대상
> > > 
> > > > 입력 명세(Input Specification) : 입력 데이터 또는 테스트 조건
> > > 
> > > > 출력 명세(Output Specification) : 테스트 케이스 수행 시 예상되는 출력 결과
> > > 
> > > > 환경 설정(Environmental Needs) : 필요한 하드웨어나 소프트웨어의 환경
> > > 
> > > > 특수 절차 요구(Special Procedure Requirement) : 테스트 케이스 수행 시 특별히 요구되는 절차
> > > 
> > > > 의존성 기술(Inter-case Dependencies) : 테스트 케이스 간의 의존성
> > > ```
> > >
> > > 
> >
> > - 테스트 프로세스
> >
> > > 테스트를 위해 수행하는 모든 작업들이 <u>테스트의 목적과 조건을 달성할 수 있도록 도와주는 과정</u>
> > >
> > > **테스트 프로세스 5단계**
> > >
> > > ① 계획 및 제어 단계 : 테스트 목표를 달성하기 위한 계획 수립, 계획대로 진행되도록 제어
> > >
> > > ② 분석 및 설계 단계 : 테스트 목표를 구체화해 테스트 시나리오와 테스트 케이스를 작성하는 단계
> > >
> > > **＊테스트 시나리오** : <u>테스트 케이스</u>들을 적용하는 <u>구체적인 절차</u>를 명세한 문서
> > >
> > > ③ 구현 및 실행 단계 : 효율적인 테스트 수행을 위해 테스트 케이스들을 조합해 테스트 프로시저에 명세하는 단계
> > >
> > > ＊**테스트 프로시저** : <u>테스트 케이스</u>의 <u>실행 순서</u>를 의미(=테스트 스크립트)
> > >
> > > ④ 평가 단계 : 테스트가 계획과 목표에 맞게 수행되었는지 평가, 기록
> > >
> > > ⑤ 완료 단계 : 이후의 테스트를 위한 참고 자료 및 테스트 수행에 대한 증거 자료로 활용하기 위해 수행 과정과 산출물을 기록 및 저장하는 단계
>
> - 개발 지원 도구 
>
> > - 통합 개발 환경(IDE: Integrated Development Environment)
> >
> > > 개발에 필요한 환경, 즉 **편집기(Editor)**, **컴파일러(Compiler)**, **디버거(Debugger)** 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 것을 의미
> > >
> > > * 통합 개발 환경을 제공하는 소프트웨어를 의미
> > > * 코드의 자동 생성 및 컴파일 가능, 추가 기능을 위한 도구들을 다운로드 할 수 있음
> > > * 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정 용이
> > > * 외부의 다양한 서비스와 연동 가능 
> > > * 통합 개발 환경을 지원하는 대표적인 도구는 다음과 같음
> >
> > | 프로그램                            | 개발사                  | 플랫폼        | 운영체제                 | 지원 언어                     |
> > | ----------------------------------- | ----------------------- | ------------- | ------------------------ | ----------------------------- |
> > | 이클립스(Eclipse)                   | Eclipse Foundation, IBM | 크로스 플랫폼 | Windows, Linux, MacOS 등 | JAVA, C++, C, PHP, JSP 등     |
> > | 비주얼 스튜디오(Visual studio)      | Microsoft               | Win32, Win64  | Windows                  | Basic, C++, C, C#, .NET 등    |
> > | 엑스 코드(Xcode)                    | Apple                   | Mac, iPhone   | MacOS, iOS               | C++, C, C#, JAVA 등           |
> > | 안드로이스 스튜디오(Android Studio) | Google                  | Android       | Windows, Linux, MacOS    | JAVA, C, C++                  |
> > | IDEA                                | JetBrains               | 크로스 플랫폼 | Windows, Linux, MacOS    | JAVA, JSP, XML, GO, Kotlin 등 |
> >
> > 
> >
> > - 빌드 도구 
> >
> > > 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업들을 수행하는 소프트웨어
> > >
> > > ＊**전처리(Preprocessing)** : 컴파일에 앞서 코드에 삽입된 주석을 제거하거나 매크로들을 처리하는 과정
> > >
> > > * 빌드 : 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말함
> > > * 대표적인 도구
> >
> > | 도구                   | 특징                                                         |
> > | ---------------------- | ------------------------------------------------------------ |
> > | Ant(Another Neat Tool) | - 아파치 소프트웨어 재단에서 개발한 소프트웨어, 자바 프로젝트의 공식적인 빌드 도구로 사용됨<br />- XML 기반의 빌드 스크립트 사용<br />- 자유도와 유연성 높음, 복잡한 빌드 환경에도 대처 가능<br />- 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의, 스크립트의 재사용 어려움 |
> > | Maven                  | - 아파치 소프트웨어 재단에서 개발한 소프트웨어, Ant의 대안으로 개발 됨<br />- 의존성을 설정해 라이브러리를 관리<br />- 컴파일과 빌드 동시 수행 가능<br />- 규칙이나 표준이 존재해 예외 사항만 기록하면 됨 |
> > | Gradle                 | - 기존의 Ant와 Maven을 보완해 개발된 빌드 도구<br />- 한스 토커 외 6인의 개발자가 모여 공동 개발함<br />- 안드로이드 스튜디오의 공식 빌드 도구로 채택된 도구- 의존성 활용, 그루비(Groovy) 기반의 빌드 스크립트 사용 |
> >
> > 
> >
> > - 기타 협업 도구 
> >
> > > 개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구로, 협업 소프트웨어, **그룹웨어(Gropware)** 등으로 불림
> > >
> > > * 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함되어 있음
> > > * 다양한 플랫폼에서 사용할 수 있도록 제공됨
> > > * 협업 도구가 익숙하지 않거나 이용할 의지가 없으면 협업 도구가 요히려 협업의 방해 요소가 될 수 있음
> > > * 협업 도구의 종류
> >
> > | 구분                      | 협업도구의 역할 및 예씨                                      |
> > | ------------------------- | ------------------------------------------------------------ |
> > | 프로젝트 및 일정 관리     | - 전체 프로젝트와 개별 업무들의 진행 상태, 일정 등을 공유하는 기능 제공<br />- 구글 캘린더, 분더리스트(Wunderlist), 트렐로(Trello), 지라(Jira), 플로우(Flow) 등 |
> > | 정보 공유 및 커뮤니케이션 | - 주체별로 구성원들을 지목해 방을 개설한 후 정보를 공유하고 대화가능  <br />- 파일 관리 간편, 의사소통 자유로움<br />- 슬랙(Slack), 잔디(Jandi), 태스크월드(Teskworld) 등 |
> > | 디자인                    | - 디자이너가 설계한 UI나 이미지의 정보들을 코드화하여 개발자에게 전달하는 기능 제공 <br />- 스케치(Sketch), 제플린(Zeplin) 등 |
> > | 기타                      | - 아이디어 공유에 사용되는 에버노트(Evernote)<br />- API를 문서화해 개발자들 간 협업을 도와주는 스웨거(Swagger)<br />- 깃(Git)의 웹호스팅 서비스인 깃허브(Github) |
> >
> > 

**3. 제품 소프트웨어 패키징**

> - 소프트웨어 패키징 
>
> > - 소프트웨어 패키징의 개요 
> >
> > > 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것
> > >
> > > * 개발자가 아닌 **사용자 중심**으로 진행
> > > * 소스 코드는 향후 관리를 고려해 모듈화하여 패키징함
> > >
> > > ＊**모듈화** : 시스템을 각 **기능**별로 나누는 것
> > >
> > > * 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징함
> > > * 사용자의 편의성 및 실행 환경을 우선적으로 고려해야 함
> >
> > * 패키징 시 고려사항
> >
> > > * 사용자의 시스템 환경, 즉 OS, CPU, 메모리 등에 필요한 <u>최소 환경을 정의</u>
> > > *  **UI**는 시각적인 자료와 함께 제공하고 <u>매뉴얼과 일치시켜 패키징</u>함
> > > * 소프트웨어를 패키징해 배포한 이후, 하드웨어와 함께 관리될 수 있도록 **Managed Service** 형태로 제공하는 것이 좋음
> > > * <u>고객의 편의성</u>을 고려한 안정적인 배포 중요
> > > * 패키징의 변경 및 개선에 대한 관리를 항상 고려해야 함
> >
> > - 패키징 작업 순서 
> >
> > > 패키징 주기는 소프트웨어 개발 기법에 따라 달라지는데, 각 주기가 끝날 때마다 패키징 수행
> > >
> > > * 프로젝트 개발 과정에서 주기별로 패키징한 결과물은 테스트 서버에 배포
> > > * 마지막 개발 과정을 거쳐 패키징한 결과물은 고객이 사용할 수 있도록 온라인 배포 또는 오프라인으로 배포 함
> > >
> > > ![패키징 작업 순위](.\패키징 작업 순위.png)
> > >
> > > 
>
> - 릴리즈 노트 작성
>
> > - 릴리즈 노트의 개요 
> >
> > > 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서
> > >
> > > ＊릴리즈 : 개발이 완성된 소프트웨어를 출시, **배포**하는 것
> > >
> > > * 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유할 수 있음
> > > * 소프트웨어의 버전 관리나 릴리즈 정보를 체계적으로 관리할 수 있음
> > > * 테스트 진행 방법에 대한 결과와 소프트웨어 사양에 대한 <u>개발팀의 정확한 준수 여부를 확인</u>할 수 있음
> > > * 소프트웨어의 <u>초기 배포 시</u> 또는 출시 후 <u>개선 사항을 적용한 추가 배포 시</u>에 제공
> > > * <u>**개발팀**에서 제공하는 소프트웨어 사양에 대한 **최종 승인**</u>까지 얻은 후 문서화 되어 제공됨
> >
> > * 릴리즈 노트의 **초기 버전** 작성시 고려사항 
> >
> > > * 정확하고 완전한 정보를 기반으로 <u>개발팀에서 직접 **현재 시제**</u>로 작성
> > >
> > > * 신규 소스, 빌드 등의 **<u>이력**이 정확하게 관리</u>되어 변경 또는 개선된 항목에 대한 이력 정보들도 작성
> > >
> > > ```
> > > [일반적인 릴리즈 노트의 구성항목]
> > > > Header(머릿말)
> > > > 개요
> > > > 목적
> > > > 문제요약
> > > > 재현항목
> > > > 수정/개선내용
> > > > 사용자 영향도
> > > > SW지원 영향도
> > > > 노트
> > > > 면책조항
> > > > 연락처
> > > ```
> >
> > - 릴리즈 노트의 **추가 버전** 작성시 고려사항 
> >
> > > * <u>중대한 오류</u>가 발생해 긴급 수정하는 경우, 릴리즈 버전을 출시하고 버그 번호를 포함한 **모든 수정된 내용을 담아** 릴리즈 노트 작성
> > > * <u>소프트웨어에 대한 기능 업그레이드</u>를 완료한 경우에 릴리즈 버전을 출시하고 릴리즈 노트 작성
> > > * <u>사용자로부터 접수된 요구사항에 의해 추가나 수정</u>된 경우 자체 기능 향상과는 다른 별도의 릴리즈 버전을 출시하고 릴리즈 노트 작성
> >
> > - 릴리즈 노트 작성 순서
> >
> > > ![릴리즈 노트 작성순서](.\릴리즈 노트 작성순서.png)
> > >
> > > 
>
> - 디지털 저작권 관리(DRM)
>
> > - 저작권의 개요 
> >
> > > **저작권**
> > >
> > > 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한
> > >
> > > * 저작권 보호 기술
> > >
> > >   컴퓨터 프로그램들과 같이 복제하기 쉬운 저작물에 대해 불법 복제 및 배포 등을 막기 위한 기술적인 방법
> >
> > * **디지털 저작권 권리(DRM; Digital Right Management)**
> >
> > > 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 결쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술
> > >
> > > * 원본 콘텐츠가 아날로그인 경우에는 <u>디지털로 변환</u>한 후 패키저에 의해 DRM 패키징 수행
> > > * 콘텐츠의 크기가 음원이나 문서와 같이 크<u>기가 작은 경우 사용자가 콘텐츠를 요청하는 시점에서 **실시간으로 패키징을 수행**</u>하고, <u>크기가 큰 경우 **미리 패키징을 수행** 후 배포</u>
> > > * <u>패키징 수행 시 콘텐츠에는 암호화된 저작권자의 **전자서명**이 포함</u>되고 저작권자가 설정한 라이선스 정보가 **클리어링 하우스**에 등록 됨
> > > * **클리어링 하우스(Clearing House)** : 디지털 <u>저작권 라이선스의 중개 및 발급</u>을 수행하는 곳, 디지털 저작물의 이용 내역을 근거로 저작권료의 정산 및 분배가 수행됨
> > > * 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이선스 정보를 통해 **사용자 인증**과 콘텐츠 **사용 권한 소유 여부**를 확인받아야 함
> > > * **종량제 방식**을 적용한 소프트웨어의 경우 클리어링 하우스를 통해 서비스의 실제 사용량을 측정하여 <u>이용한 만큼의 요금 부과</u>
> >
> > - 디지털 저작권 관리의 흐름도 
> >
> > > ![디지털 저작권 관리 흐름도](.\디지털 저작권 관리 흐름도.png)
> > >
> > > \- **클리어링 하우스(Clearing House)** : 저작권에 대한 <u>사용 권한, 라이선스 발급, 사용량에 따른 결제 관리</u> 등을 수행하는 곳
> > >
> > > \- **콘텐츠 제공자(Contents Provider)** : 콘텐츠를 제공하는 저작권자
> > >
> > > \- **패키저(Packager)** : <u>콘텐츠를 메타 데이터와 함께</u> 배포 가능한 형태로 묶어 암호화하는 프로그램
> > >
> > > ＊<u>메타 데이터</u> : 데이터에 대한 데이터, 즉 데이터에 대한 속성 정보 등을 설명하기 위한 데이터
> > >
> > > \- **콘텐츠 분배자(Contents Distributor)** : 암호화된 콘텐츠를 유통하는 곳이나 사람
> > >
> > > \- **콘텐츠 소비자(Customer)** : 콘텐츠를 구매해서 사용하는 주체
> > >
> > > \- **DRM 컨트롤러(DRM Controller)** : 배포된 콘텐츠의 <u>이용 권한을 통제하는 프로그램</u>
> > >
> > > \- **보안 컨테이너(Security Container)** : 콘텐츠 원본을 안전하게 유통하기 위한 <u>전자적 보안 장치</u>
> >
> > 
> >
> > * **디지털 저작권 관리의 기술 요소**
> >
> >   디지털 저작권 관리를 위해 사용되는 기술은 다음과 같음
> >
> >   | 구성요소                      | 설명                                                         |
> >   | ----------------------------- | ------------------------------------------------------------ |
> >   | 암호화(Encryption)            | 콘텐츠및 라이선스를 <u>암호화</u>하고 <u>전자 서명</u>을 할 수 있는 기술 |
> >   | 키 관리(Key Management)       | 콘텐츠를 <u>암호화한 키</u>에 대한 저장 및 분배 기술         |
> >   | 암호화 파일 생성(Packager)    | 콘텐츠를 <u>암호화된 콘텐츠로 생성</u>하기 위한 기술         |
> >   | 식별 기술(Identification)     | 콘텐츠에 대한 <u>식별 체계 표현</u> 기술                     |
> >   | 저작권 표현(Right Expression) | 라이선스의 <u>내용 표현</u> 기술                             |
> >   | 정책 관리(Policy Management ) | 라이선스 발급 및 사용에 대한 <u>정책 표현</u> 및 관리 기술   |
> >   | 크랙 방지(Tamper Resistance)  | <u>크랙</u>에 의한 콘텐츠 사용 방지 기술                     |
> >   | 인증(Authentication)          | 라이선스 발급 및 사용의 기준이 되는 <u>사용자 인증</u> 기술  |
> >
> >   
>
> - 소프트웨어 설치 매뉴얼 작성 
>
> > * 소프트웨어 설치 매뉴얼의 개요
> >
> > > 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서
> > >
> > > * 설치 메뉴얼은 사용자 기준으로 작성
> > > * 설치 시작부터 완료 될 때까지의 전 과정을 빠짐없이 순서대로 설명
> >
> > - 서문
> >
> > > 서문에는 <u>문서 이력, 설치 매뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목</u>을 기술
> > >
> > > * 설치 매뉴얼의 주석 : 주의사항과 참고 사항을 기술
> > >
> > > * 설치 도구의 구성 : 설치 관련 파일, log 폴더, 폴더 및 설치 프로그램 실행 파일에 대해 설명
> > >
> > > * 설치 도구 체크 항목 : 사용자 환경, 응용 프로그램, 업그레이드 버전, 백업 폴더 확인
> >
> > * 기본사항 
> >
> > > 소프트웨어와 관련하여 기본적으로 설명되어야 할 항목
> > >
> > > * <u>소프트웨어 개요, 설치 관련 파일, 설치 아이콘, 프로그램 삭제, 관련 추가 정보</u>
> >
> > * 설치 매뉴얼 작성 방법
> >
> > > 설치 매뉴얼은 사용자가 설치 과정을 이해하기 쉽도록 <u>설치 화면을 누락 없이 캡쳐</u>하고 <u>순서대로 상세히</u> 설명
> > >
> > > * <u>설치 화면 및 UI, 설치 이상 메시지, 설치 완료 및 결과, FAQ, 설치 시 점검 사항, Network 환경 및 보안, 고객 지원 방법, 준수 정보 및 제한 보증</u> 등에 대한 내용 기술
> >
> > - 설치 매뉴얼 작성순서
> >
> > > ![소프트웨어 설치 매뉴얼 작성순서](.\소프트웨어 설치 매뉴얼 작성순서.png)
>
> - 소프트웨어 사용자 매뉴얼 작성 
>
> > - 소프트웨어 사용자 매뉴얼의 개요 
> >
> > > 사용자가 소프트웨어를 <u>사용하는 과정에서 필요한 내용</u>을 문서로 기록한 설명서와 안내서
> > >
> > > * **개별적**으로 <u>동작이 가능한 컴포넌트 단위</u>로 매뉴얼 작성
> > > * **컴포넌트 명세서**와 **컴포넌트 구현 설계서**를 토대로 작성
> >
> > * 서문
> >
> > >서문에는 <u>문서 이력, 사용자 매뉴얼의 주석, 기록 보관</u>을 위해 필요한 내용을 기술 함
> > >
> > >* 사용자 매뉴얼의 주석 : 주의 사항과 참고 사항 기술
> > >* 기록 보관 내용 : 필요한 기술 지원이나 추가 정보를 얻기 위한 소프트웨어 등록 정보 기술
> >
> > * 기본사항
> >
> > > 소프트웨어와 관련하여 기본적으로 설명되어야 할 항목
> > >
> > > * 소프트웨어 개요, 소프트웨어 사용 환경, 소프트웨어 관리, 모델, 버전별 특징, 기능, 인터페이스의 특징, 소프트웨어 구동 환경
> >
> > * 사용자 매뉴얼 작성 방법
> >
> > > 사용자 매뉴얼은 사용자가 사용 방법을 이해하기 쉽도록 상황별로 누락 없이 캡처하여 순서대로 상세히 설명(설치 매뉴얼과 동일)
> > >
> > > \- 사용자 화면 및 UI, 주요 기능 분류, 응용 프로그램 및 설정, 장치 연동, Network 환경, Profile 안내, 고객 지원 방법, 준수 정보 및 제한 보증
> >
> > * 사용자 매뉴얼 작성 순서
> >
> > > * 설치 매뉴얼에서 
> > >
> > >   <u>기능식별 → UI분류 → 설치/백업파일 확인 → Uninstall절차확인 → 이상 케이스 확인</u> 
> > >
> > >   <u>→ 최종 매뉴얼 적용</u> 으로 이어지는 흐름과 비교 	
> > >
> > > ![소프트웨어 사용자 매뉴얼 작성순서](.\소프트웨어 사용자 매뉴얼 작성순서.png)
> > >
> > > 
>
> - 소프트웨어 버전 등록
>
> > - 소프트웨어 패키징의 **형상 관리**
> >
> > > 형상 관리 : 소프트웨어의 개발 과정에서 <u>소프트웨어의 변경 사항</u>을 관리하기 위해 개발된 일련의 활동
> > >
> > > * 소프트웨어 <u>변경의 원인을 알아내고 제어</u>하며, 적절히 변경되고 있는지 확인하여 <u>해당 담당자에게 통보</u>
> > >
> > > * <u>형상 관리는 소프트웨어 개발의 전 단계에 적용</u>되는 활동이며, <u>유지보수 단계</u>에서도 수행됨
> > >
> > > * 형상 관리는 <u>개발의 전체 비용을 줄이고</u>, 개발 과정의 여러 <u>방해 요인이 최소화</u>되도록 보증하는 것을 목적으로 함
> > >
> > > ＊**형상** : 소프트웨어 개발 단계의 각 과정에서 만들어지는 프로그램, 프로그램 설명 문서, 데이터 등을 통칭
> >
> > * 형상 관리의 중요성 
> >
> > > * 변경 사항을 체계적으로 **추적 및 통제**
> > > * 무절제한 변경 방지
> > > * 버그나 수정 사항 **추적** 가능
> > > * **진행 정도**를 확인하기 위한 **기준**으로 사용
> >
> > - 형상 관리 기능
> >
> > > 형상 관리는 품질 보증을 위한 중요한 요소
> > >
> > > * **형상 식별** : 형상 관리 대상에 이름과 **관리 번호**를 부여하고, <u>계층 구조로 구분</u>해 수정 및 추적이 용이하도록 하는 작업
> > > * **버전 제어** : <u>다른 버전의 형상 항목을 관리</u>하고, 이를 위해 <u>특정 절차와 도구를 결합</u>시키는 작업
> > > * **형상 통제(변경 관리)** : 현재의 **기준선(BaseLine)**이 잘 반영되도록 조정 
> > > * **형상 감사** : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 **공식적으로 승인**하는 작업
> > > * **형상 기록(상태 보고)**: 형상의 식별, 통제, 감사 작업의 결과를 기록 관리 및 보고서화
> >
> > - 소프트웨어 버전 등록 관련 주요 용어 
> >
> > > ```
> > > - 저장소(Repository) : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳 
> > > 
> > > - 가져오기(import) : 버전 관리가 되고 있지 않은 아무것도 없는 저장소에 처음으로 파일을 복사
> > > 
> > > - 체크아웃(Check-Out) : 프로그램을 수정하기 위해 저장소에서 파일을 받아옴, 소스 파일과 함께 버전 관리를 위한 파일들도 받아옴
> > > 
> > > - 체크인(Check-In) : 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신
> > > 
> > > - 커밋(Commit) : 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료
> > > 
> > > - 동기화(Update) : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화 함
> > > ```
> > >
> > > 
> >
> > * 소프트웨어 버전 등록 과정 
> >
> > > **I-CO-C-U-D(아이코컫)**
> > >
> > > ![소프트웨어 버전 등록 과정](.\소프트웨어 버전 등록 과정.png)
> > >
> > > 
>
> - 소프트웨어 버전 관리 도구 (공유폴더 방식, 클라이언트/서버방식, 분산 저장소 방식)
>
> > * **공유폴더 방식**
> >
> > > 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
> > >
> > > * **개발자**들은 개발이 완료된 파일을 약속된 **공유 폴더**에 매일 복사함
> > > * **담당자**는 공유 폴더의 파일을 **자기 PC**로 복사한 후 이상 유무를 확인
> > > * 이상 유무 확인 중 파일의 오류가 확인되면, <u>해당 파일을 등록한 개발자에게 수정 의뢰</u>
> > > * 파일을 잘못 복사하거나 다른 위치로 복사하는 것에 대비하기 위해 <u>파일의 변경사항을 **데이터베이스**에 기록해 관리</u>
> > >
> > > ex) SCCS, RCS, PVCS, QVCS (다 CS로 끝난다.)
> >
> > - **클라이언트/ 서버 방식**
> >
> > > 버전 관리 자료가 서버에 저장되어 관리되는 방식
> > >
> > > * 서버의 자료를 개발자별로 **자신의 PC**로 복사해 작업한 후 변경된 내용을 **서버**에 반영
> > > * **모든 버전 관리는 서버에서 수행**
> > > * 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력
> > > * <u>서버에 문제 발생 시 협업 및 버전 관리 **작업 중단** 됨</u>
> > >
> > > ex) **CVS**, <u>SVN(Suvbersion)</u>*, **CVS**NT, **C**lear **C**ase, **C**MVC, Perforce 등 (C로 시작하는 경우가 많다)
> >
> > - **분산 저장소 방식**
> >
> > > 버전 관리 자료가 하나의 **원격 저장소**와 <u>분산된 개발자 **PC의 로컬 저장소**</u>에 함께 저장되어 관리되는 방식
> > >
> > > * 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사해 작업한 후 변경된 내용을 로컬 저장소에서 우선 반영한 다음 이를 원격 저장소에 반영 함
> > > * <u>원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 할 수 있음</u>(S/C방식과 가장 큰 다른점)
> > >
> > > ex) Git, GNU arch, DCVS, Bazaar, TeamWare, Bitkeeper 등
> > >
> > > 
> >
> > - **Subversion(서브버전, SVN)**
> >
> > > * CVS를 개선한 것, 아파치 소프트웨어 재단에서 2000년에 발표
> > >
> > > ＊CVS : 공동 개발을 편리하게 작업 할 수 있도록 버전 관리를 도와주는 시스템
> > >
> > > * 클라이언트/서버 구조
> > >
> > > * 커밋할 때마다 **라비전(Revision)**이 1씩 증가
> > >
> > > * Subversion의 주요 명령어
> > >
> > > ```
> > > > add : 새로운 파일이나 디렉터리를 버전 관리 대상으로 등록
> > > 
> > > > commit : 버전 관리 대상으로 등록된 클라이언트의 소스 파일을 서버의 소스 파일에 적용
> > > 
> > > > update : 서버의 최신 commit 이력을 클라이언트의 소스 파일에 적용
> > > 
> > > > checkout : 버전 관리 정보와 소스 파일을 서버에서 클라이언트로 받아옴
> > > 
> > > > lock/unlock : 서버의 소스 파일이나 디렉터리를 잠그거나 해제
> > > 
> > > > Import : 아무것도 없는 서버의 저장소에 맨 처음 소스 파일을 저장
> > > 
> > > > export : 버전 관리에 대한 정보를 제외한 순수한 소스 파일만을 서버에서 받아 옴
> > > 
> > > > info : 지정된 파일에 대한 정보 표시
> > > 
> > > > diff : 지정된 파일이나 경로에 대해 전 리비전과의 차이 표시
> > > 
> > > > merge : 다른 디렉터리에서 작업된 버전 관리 내역을 기본 개발 작업과 병합
> > > ```
> > >
> > > 
> >
> > - 깃(**GIT**)
> >
> > > * 리누즈 토발즈가 2005년에 개발, 이후 주니오 하마노가 유지 보수
> > >
> > > * 분산 버전 관리 시스템
> > >
> > > * 지역 저장소에서 버전 관리가 이루어짐, 신속한 처리 
> > >
> > >   (↔ 서버에서 모든 버전관리가 이루어진 **S/C방식)**
> > >
> > > * 원격 저장소나 네트워크에 문제가 발생해도 작업 가능
> > >
> > > * 브랜치를 이용해 다양한 형태의 기능 테스팅 가능
> > >
> > > * 파일의 변화를 **스냅샷**으로 저장, 버전의 흐름 파악 가능 ↔ **리비전**
> > >
> > > * Git의 주요 명령어
> > >
> > > ```
> > > > add : 작업 내역을 지역 저장소에 저장하기 전 스테이징 영역에 추가
> > > 
> > > > commit : 작업 내역을 지역 저장소에 저장
> > > 
> > > > branch : 새로운 브랜치 생성
> > > 
> > > > checkout : 지정한 브랜치로 이동
> > > 
> > > > merge : 브랜치 병합
> > > 
> > > > init : 지역 저장소 생성
> > > 
> > > > remote add : 원격 저장소에 연결
> > > 
> > > > push : 로컬 저장소의 변경 내역을 원격 저장소에 반영
> > > 
> > > > fetch : 원격 저장소의 변경 이력만을 지역 저장소로 가져옴
> > > 
> > > > clone : 원격 저장소의 전체 내용을 지역 저장소로 복제
> > > 
> > > > fork : 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제
> > > ```
> > >
> > > 
>
> - 빌드 자동화 도구 
>
> > - 빌드 자동화 도구의 개념 
> >
> > > 빌드를 포함해 테스트 및 배포를 자동화하는 도구
> > >
> > > * 지속적인 통합 개발 환경에서 유용
> > > * 빌드 자동화 도구 : Ant, Make, Maven, 가장 대표적인 **Gradle, Jenkins** 등 
> >
> > - **Jenkins**
> >
> > > * **자바** 기반의 오픈 소스 형태, 가장 많이 사용되는 빌드 자동화 도구
> > > * **서블릿 컨테이너**에서 실행되는 서버 기반 도구
> > > * SVN, Git 등 <u>대부분의 **형상 관리 도구**와 연동</u> 가능
> > > * **Web GUI** 제공
> > > * 여러 대의 컴퓨터를 이용한 **분산 빌드**나 **테스트** 가능 
> >
> > - **Gradle**
> >
> > > * **Groovy**를 기반으로 한 오픈 소스 형태의 자동화 도구
> > >
> > > * **안드로이드 앱** 개발 환경에서 사용, 플러그인 설정 시 JAVA, C/C++, Python 등의 언어도 빌드 가능
> > > * DSL을 <u>스크립트 언어</u>로 사용
> > >
> > > * 실행할 처리 명령들을 모아 태스크로 만든 후 **태스크 단위**로 실행
> > >
> > > * **빌드 속도 빠름**(이전 태스크 재사용, 빌드 캐시 기능)

**4. 애플리케이션 테스트 관리**

> - 애플리케이션 테스트
>
> > - 애플리케이션 테스트의 개념 
> >
> > > 애플리케이션에 잠재되어 있는 결함을 찾아내는 행위, 절차
> > >
> > > * **고객**의 요구사항을 만족시키는지 <u>확인(Validation)</u>하고, 
> > > * **기능**을 정확히 수행하는지 <u>검증(Verification)</u>
> > >
> > > ＊Validation : 사용자 입장
> > >
> > > ＊Verification : 개발자 입장
> > >
> > > 
> > >
> > > **☞ 소프트웨어의 분류**
> > >
> > > \- **상용 소프트웨어** : <u>보통의 사용자들이 공통적으로</u> 필요로 하는 기능을 제공하는 소프트웨어
> > >
> > > \> 산업 범용 소프트웨어 : 시스템 소프트웨어, 미들웨어, 응용 소프트웨어
> > >
> > > \> 산업 특화 소프트웨어 : 특정 분야에서 요구하는 기능만을 구현한 소프트웨어
> > >
> > > 
> > >
> > > \- **서비스 제공 소프트웨어** : <u>특정 사용자</u>가 필요로 하는 기능만을 구현해 제공하는 소프트웨어
> > >
> > > \> 신규 개발 소프트웨어 : 새로운 서비스를 제공하기 위해 개발된 소프트웨어
> > >
> > > \> 기능 개선 소프트웨어 : 기능을 개선하기 위해
> > >
> > > \> 추가 개발 소프트웨어 : 새로운 기능을 추가하기 위해
> > >
> > > \> 시스템 통합 소프트웨어 : 업무기능이나 데이터 등을 통합하여 개발된 소프트웨어
> > >
> > > ​	(시스템 별로 서비스 되던 것을 원스톱(One-Stop)서비스로 제공) 
> >
> > - 애플리케이션 테스트의 중요성 
> >
> > > \- 프로그램 실행 전에 오류를 발견하여 예방(**오류사전식별**)
> > >
> > > \- 제품의 **신뢰도** 향상
> > >
> > > \- 단순한 오류 뿐만 아니라 새로운 **오류의 유입도 예방**
> > >
> > > \- 최소한의 시간과 노력으로 많은 결함 발견 가능(**최고의 효율성**)
> >
> > - 애플리케이션 테스트의 기본 원리 
> >
> > > * **완벽한 소프트웨어 테스팅은 불가,** 결함은 줄일 수는 있지만 결함이 없다고 증명할 수는 없음 
> > > * 결함은 대부분 특정 모듈에 집중되어 있음(**파레토 법칙**)
> > > * 테스트 케이스를 지속적으로 보완 및 개선(**'살충제 패러독스' 방지**)
> > > * 정황에 따라 테스트를 다르게 수행
> > > * 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없음
> > > * 테스트와 위험은 반비례
> > > * 테스트는 작은 부분에서 시작해 점점 확대해 진행
> > > * 발자와 관계없는 별도의 팀에서 테스트 수행
>
> - 애플리케이션 테스트의 분류 
>
> > - 프로그램 실행 여부에 따른 분류 
> >
> > | 구분        | 설명                                                         |
> > | ----------- | ------------------------------------------------------------ |
> > | 정적 테스트 | More Actions프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트- 소프트웨어 개발 초기에 결함 발견 가능, 개발 비용 낮음<br />ex) 워크스루, 인스펙션, 코드검사 등 |
> > | 동적 테스트 | 프로그램을 실행하여 오류를 찾는 테스트- 소프트웨어 개발의 모든 단계에서 테스트를 수행할 수 있음<br />ex) 블랙박스 테스트, 화이트박스 테스트 |
> >
> > 
> >
> > - 테스트 기반(Test Bases)에 따른 테스트 
> >
> > | 구분             | 설명                                                         |
> > | ---------------- | ------------------------------------------------------------ |
> > | 명세 기반 테스트 | <u>사용자의 요구사항</u>에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트<br />- 종류 : 동등 분할, 경계 값 분석 등 |
> > | 구조 기반 테스트 | <u>소프트웨어 내부의 논리 흐름</u>에 따라 테스트 케이스를 작성하고 확인하는 테스트<br />- 종류 : 구문 기반, 결정 기반, 조건 기반 등 |
> > | 경험 기반 테스트 | <u>유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반</u>으로 수행하는 테스트<br /> 사용자 요구사항에 대한 명세게 부족하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적<br />- 종류 : 에러 추정, 체크 리스트, 탐색적 테스팅 |
> > |                  |                                                              |
> >
> > 
> >
> > - 시각에 따른 테스트 
> >
> > > * **확인(Validation)** 테스트 : **사용자**의 시각에서 생산된 제품의 결과를 테스트하는 것. 사용자가 요구한대로 완성되었는지
> > > * **검증(Verification)** 테스트 : **개발자**의 시각에서 제품의 생산 과정을 테스트하는 것, 제품이 명세서대로 완성 되었는지
> >
> > 
> >
> > - 목적에 따른 테스트 
> >
> > > | 구분                     | 설명                                                         |
> > > | ------------------------ | ------------------------------------------------------------ |
> > > | 회복(Recovery) 테스트    | 시스템에 여러 결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인 |
> > > | 안전(Security) 테스트    | 시스템에 설치된 시스템 보호 도구가 불법적인 칩입으로부터 시스템을 보호할 수 있는지 확인 |
> > > | 강도(Stress) 테스트      | 시스템에 과도한 정보량이나 빈도 등을 부과해 과부하 시 소프트웨어가 정상적으로 실행되는지 확인 |
> > > | 성능(Performance) 테스트 | 소프트웨어의 실시간 성능이나 전체적인 효율성을 진단, 응답시간, 처리량 등 테스트 |
> > > | 구조(Structured) 테스트  | 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가 |
> > > | 회귀(Regression) 테스트  | 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인 |
> > > | 병행(Parallel) 테스트    | 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력해 결과를 비교 |
>
> - 테스트 기법에 따른 애플리케이션 테스트 
>
> > - 화이트 박스 테스트 
> >
> > > 모듈안의 내용을 볼 수 있어 내부의 **논리적**인 경로를 테스트하는 방식
> > >
> > > 모듈의 **원시 코드**를 **오픈**시킨 상태에서 원시 코드의 <u>논리적인 모든 경로를 테스트</u>하여 테스트 케이스를 설계하는 방식
> > >
> > > * 구조 기반 테스트
> > > * 테스트 과정의 **초기**에 적용
> > > * 모듈 안의 작동을 직접 관찰
> > > * 분기점 부분들을 수행함으로써 <u>**논리적** 경로 제어</u>
> >
> > - 화이트 박스 테스트의 종류 
> >
> > > ```
> > > [기초 경로 검사]
> > > 
> > > - 대표적인 화이트박스 테스트 기법
> > > 
> > > - 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
> > > 
> > > 
> > > [제어 구조 검사]
> > > 
> > > - 조건 검사(Condition Testing) : 프로그램 모듈 내에 있는 논리적 조건을 테스트 
> > > 
> > > - 루프 검사(Loop Testing) : 프로그램의 반복구조에 초점을 맞춰 테스트
> > > 
> > > - 데이터 흐름 검사(Data Flow Testing) : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 
> > > ```
> > >
> > > 
> >
> > - 화이트박스 테스트의 검증 기준 
> >
> > > * **문장 검증 기준(State Coverage)** : 소스 코드의 **모든 구문이 한 번 이상** 수행되도록 테스트 케이스 설계
> > > * **분기 검증 기준(Branch Coverage)** : 소스 코드의 **모든 조건문이 한 번 이상** 수행되도록 테스트 케이스 설계
> > > * **조건 검증 기준(Condition Coverage)** : 소스 코드의 <u>**모든 조건문**에 대해 조건이 True인 경우와 False인 경우가 한 번 이상</u> 수행되도록 테스트 케이스 설계
> > > * **분기/조건 기준(Branch/Condition Coverage)** : 소스 코드의 <u>**모든 조건문**과 각 **조건문에 포함된 개별 조건식**의 결과가 True인 경우와 False인 경우가 한 번 이상</u> 수행되도록 테스트 케이스 설계
> > >
> > > 
> > >
> > > **☞ 검증 기준(Coverage)의 종류**
> > >
> > > ```
> > > - 기능 기반 커버리지 : 실제 테스트가 수행된 기능의 수 / 전체 기능 수
> > > 
> > > - 라인 커버리지 : 테스트 시나리오가 수행한 소스 코드의 라인 수 / 전체 소스 코드의 라인수 
> > > 
> > > - 코드 커버리지 : 소스 코드의 구문, 분기, 조건 등의 구조 코드 자체가 얼마나 테스트 되었는지를 측정하는 방법 
> > > ```
> > >
> > > > ※<u>문장 검증 기준, 분기 검증 기준</u> 등은 모두 **코드 커버리지**에 해당
> >
> > 
> >
> > - 블랙박스 테스트
> >
> > > 소프트웨어의 각 **기능**이 완전히 작동되는 것을 입증하는 테스트, 기능 테스트라고도 함
> > >
> > > * 사용자의 **요구사항 명세서**를 보면서 테스트, 주로 구현된 기능을 테스트
> > > * 명세 기반 테스트, 경험 기반 테스트
> > > * 테스트 과정의 **후반부**에 적용
> >
> > - 블랙박스 테스트의 종류 
> >
> > > * 동치 분할 검사(동등 분할 기법) : 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법
> > > * 경계값 분석 : 입력 자료에만 치중한 동치 분할 기법을 보완하기 위한 기법
> > > * 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 분석한 다음 효용성이 높은 테스트 케이스를 선정해 검사하는 기법
> > > * 오류 예측 검사 : 과거의 경험이나 확인자의 감각으로 테스트하는 기법
> > > * 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공해 동일한 결과가 출력되는지 테스트하는 기법
>
> - 개발 단계에 따른 애플리케이션 테스트 
> - 통합 테스트
> - 애플리케이션 테스트 프로세스 
> - 테스트 케이스 / 테스트 시나리오 / 테스트 오라클
> - 테스트 자동화 도구 
> - 결함관리 

**5. 인터페이스 구현**

> - 모듈 연계를 위한 인터페이스 기능 식별 
> - 인터페이스 기능 구현 정리 
> - 인터페이스 예외 처리 
> - 인터페이스 보안
> - 연게 테스트 
> - 인터페이스 구현 검증 