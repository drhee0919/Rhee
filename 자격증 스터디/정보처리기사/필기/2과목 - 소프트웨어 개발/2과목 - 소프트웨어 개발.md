### 2과목: 소프트웨어 개발



**1. 데이터 입출력 구현**

> - 자료 구조
>
> > - 자료 구조의 정의 
> >
> > > 저장 공간의 효율성과 실행시간의 신속성을 위해 저장법, 자료간의 관계, 처리방법등을 연구분석 하는 것 
> > >
> > > * 어떤 자료구조에서도 필요한 모든 연산들을 처리할 수 있다. 
> > > * 자료 구조에 따라 프로그램 실행 시간이 달라진다. 
> >
> > - 자료구조의 분류: **선형구조(Linear Structure)**, **비선형구조(Non-Linear Structure**)
> >
> > ```
> > [선형구조]
> > 배열(array)
> > 선형 리스트(linear list) -연속 리스트(continguous list)
> > 					  ㄴ연결 리스트(linked list) 
> > 스택(stack)
> > 큐(Queue)
> > 데큐(Deque)
> > 
> > 
> > [비선형 구조]
> > 트리(tree)
> > 그래프(graph)
> > ```
> >
> > 
>
> - 데이터 저장소/데이터베이스/DBMS
>
> > - 데이터 저장소 
> >
> > > 소프트웨어 개발 과정에서 다루어야 할 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것을 의미 
> > >
> > > * **논리 데이터 저장소** 와 **물리 데이터 저장소로 나뉜다**
> > >
> > > ```
> > > 논리 데이터 저장소
> > > : 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화
> > > 
> > > 물리 데이터 저장소 
> > > : 소프트웨어 운용환경의 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장한 것 
> > > ```
> > >
> > > * 논리 데이터저장소를 거쳐 물리 데이터 저장소를 구축하는 과정은 
> > >
> > >   데이터베이스를 구축하는 과정과 동일하다. 
> >
> > 
> >
> > * 데이터 베이스 
> >
> > > 데이터베이스는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임
> > >
> > > * 통합된 데이터(integrated data)
> > >
> > > > 자료의 **중복을 배제**한 데이터의 모임
> > >
> > > * 저장된 데이터(stored data)
> > >
> > > > 컴퓨터가 접근할 수 있는 **저장 매체**에 저장된 자료 
> > >
> > > * 운영 데이터(operational data)
> > >
> > > > **조직의 고유한 업무를 수행**하는 데 존재 가치가 확실하고 없어서는 안될 반드시 필요한  자료 
> > >
> > > * 공용 데이터(shared data)
> > >
> > > > 여러 응용 시스템들이 **공동**으로 소유하고 유지하는 자료 
> >
> > 
> >
> > - DBMS(데이터베이스 관리 시스템)
> >
> > > 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어 
> > >
> > > * 기존의 파일 시스템이 갖던 데이터의 **중복성**, **종속성** 문제를 해결하기 위해 제안 
> > > * 모든 응용프로그램들이 DB를 공용할 수 있도록 관리
> > > * DBMS는 DB의 구성, 접근방법, 유지관리에 대한 모든 책임을 진다. 
> > > * DBMS의 필수 기능: **정의(Definition), 조작(Manipulation), 제어(Control)**
> > >
> > > * 정의기능
> > >
> > > > DB에 저장될 데이터의 **형(type)과 구조에 대한 정의**, **이용방식**, **제약조건** 등을 명시하는   기능 
> > >
> > > * 조작 기능 
> > >
> > > > 데이터의 <u>검색, 갱신, 삽입, 삭제 (Select, Update, Insert, Delete)</u> 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능 
> > >
> > > * 제어 기능 
> > >
> > > > * DB를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 **무결성**이 유지되도록 제어해야 한다. 
> > > > * 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안을 유지하고 **권한(Authority)**을 검사할 수 있어야 한다. 
> > > > * 여러 사용자가 DB에 동시에 접근하여 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 **병행제어(Concurrency Control)**를 할 수 있어야 한다.
> > >
> > > * DBMS의 장단점 
> > >
> > > ```
> > > [장점]
> > > - 데이터의논리적 물리적 독립성이 보장된다
> > > - 데이터의 중복을 피할 수 있어 기억 공간이 절약된다.
> > > - 저장된 자료를 공동으로 이용할 수 있다. 
> > > - 데이터의 일관성을 유지할 수 있다. 
> > > - 데이터의 무결성을 유지할 수 있다. 
> > > - 보안을 유지할 수 있다. 
> > > - 데이터를 표준화할 수 있다. 
> > > - 데이터를 통합하여 관리할 수 있다. 
> > > - 항상 최신의 데이터를 유지한다.
> > > - 데이터의 실시간 처리가 가능하다. 
> > > ```
> > >
> > > ```
> > > [단점]
> > > - 데이터베이스의 전문가가 부족하다(인력난)
> > > - 전산화 비용이 증가한다.
> > > - 대용량 디스크로의 집중적인 Access로 과부하(Overload)가 발생한다. 
> > > - 파일의 예비(Backup)와 회복(Recovery)이 어렵다. 
> > > - 시스템이 복잡하다. 
> > > ```
> > >
> > > 
>
> - 데이터 입출력
>
> > - 데이터 입출력의 개요
> >
> > > 소프트웨어의 기능 구현을 위하여 데이터베이스에 데이터를 <u>입력 및 출력</u>하는 것 뿐만이 아닌 <u>데이터를 조작하는 모든 행위</u>를 의미
> > >
> > > * 해당 작업은 SQL(Structured Query Language)를 사용하여 이루어진다. 
> > > * 개발 코드 내 SQL코드를 삽입하거나, 객체와 데이터를 연결하는 것을 **데이터 접속(Data Mapping)**이라고 한다. 
> > > * SQL을 통한 데이터베이스 조작을 수행할 때 '하나의 논리적 기능을 수행하기 위한 작업의 단위' or '한꺼번에 모두 수행되어야 할 일련의 연산들을 '**트랜잭션(Transaction)'**이라 지칭. 
> >
> > 
> >
> > * SQL
> >
> > > 국제표준 데이터베이스 언어로, 많은 회사에서 RDB(관계형 데이터베이스) 지원언어로 채택
> > >
> > > * **관계대수**, **관계해석**을 기초로 한 혼합 데이터 언어
> > > * 질의어 + 데이터 <u>정의, 조작, 제어</u> 기능 보유 
> > > * **데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)**로 구분됨 
> >
> > 
> >
> > - 데이터 접속(Data Mapping)
> >
> > > 소프트웨어 기능 구현을 위해 프로그래밍 코드와 데이터베이스의 데이터를 연결하는 것 
> > >
> > > * 관련기술: **SQL Mapping,  ORM**
> > > * SQL Mapping
> > >
> > > > 프로그래밍 코드 내에 SQL을 직접 입력하여 DBMS의 데이터에 접속하는 기술.
> > > >
> > > > ```
> > > > [관련 프레임워크]
> > > > : JDBC, ODBC, MyBatis 등 
> > > > ```
> > >
> > > * ORM(Object-Relational Mapping)
> > >
> > > > 객체지향 프로그래밍에서 **객체**와 관계형 데이터베이스의 **데이터**를 연결하는 기술 
> > > >
> > > > ```
> > > > [관련 프레임워크]
> > > > : JPA, Hibernate, Django 
> > > > ```
> > >
> > > 
> > >
> > > - 트랜젝션(Transaction)
> > >
> > > > 트랜잭션을 제어하기 위해서 사용하는 명령어를 TCL(Transaction Control Language)라고 지칭
> > >
> > > ```
> > > - COMMIT : 트랜잭션을 반영하는 명령어 
> > > - ROLLBACK : 트랜잭션이 행한 모든 변경 작업을 취소하고 이전상태로 돌리는 연산
> > > - SAVEPOINT(=CHECKPOINT)
> > > : 트랜잭션 내에 ROLLBACK할 위치인 저장점을 지정하는 명령어 
> > > ```
> > >
> > > 
>
> - 절차형 SQL
>
> > - 절차형 SQL의 개요 
> >
> > > 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL을 의미 
> > >
> > > 단일 SQL문장으로 처리하기 어려운 연속적인 작업들을 처리하는데 적합.
> > >
> > > * 다양한 기능을 수행하는 **저장 모듈**을 생성할 수 있다. 
> > > * DBMS엔진에서 직접 실행되기 때문에 입출력 패킷이 적은 편 이다. 
> > > * BEGIN-END 형식으로 작성되는 **블록(Block)구조**로 되어 있기 때문에 <u>기능별 모듈화</u>가 가능하다. 
> > > * 절차형 SQL의 종류에는 **프로시저, 트리거, 사용자정의함수** 가 있다. 
> > >
> > > > * 프로시저
> > > >
> > > > > 특정 기능을 수행하는 일종의 트랜잭션 언어. **호출**을 통해 실행되어 미리 저장해 놓은 SQL작업을 수행한다. 
> > > >
> > > > * 트리거(Trigger)
> > > >
> > > > > 데이터베이스 시스템에서 데이터의 입력, 갱신, 삭제 등의 **이벤트**(데이터 조작 작업) 가 발생할 때마다 관련 작업이 자동으로 수행된다. 
> > > >
> > > > * 사용자 정의 함수 
> > > >
> > > > > 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하며, 
> > > > >
> > > > > 종료 시 예약어 **Return** 을 사용하여 처리 결과를 **단일값**으로 반환한다. 
> > > > >
> > > > > 
> >
> > - 절차형 SQL의 테스트와 디버깅 
> >
> > > 절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 
> > >
> > > 실행 통해 결과를 확인하는 테스트 과정을 수행한다. 
> > >
> > > * 테스트 전 생성을 통해 **구문오류(syntax error)**나 **참조오류**의 존재 여부를 확인하다 
> > > * 오류 및 경고 메시지가 상세히 출력되지 않으므로 **show명령어**를 통해 내용을 먼저 확인하고 문제를 수정한다. 
> > > * 1) 디버깅을 통해 로직을 검증하고 → 2) 결과를 통해 최종적으로 확인한다. 
> > > * DB에 변화를 줄 수 있는 삽입 및 변경 관련 SQL문을 **주석처리**하고 출력문으로 화면에 출력하여 확인하다. 
> >
> > - 쿼리 성능 최적화 
> >
> > > 데이터 입출력 애플리케이션의 성능 향상을 위해 SQL코드를 최적화하는 것 
> > >
> > > * 최적화하기 전 성능 측정 도구인 **APM(Application Performance Management/Monitoring)** 으로 최적화할 쿼리선정
> > > * 최적화 할 쿼리에 대해 **옵티마이저(Optimizer)**가 수립한 실행 계획을 검토하고 SQL코드 및 인덱스를 재구성함 
> > >
> > > ※옵티마이저(Optimizer)
> > >
> > > ​    :(DBMS에 내장) SQL이 효율적으로 수행되는  '최적의 경로' 를 찾아주는 모듈 

**2. 통합 구현**

> - 단위 모듈 테스트(※내용상 출제율 C 단위모듈 포함)
>
> > - 단위모듈(Unit Module)
> >
> > > 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것
> > >
> > > * 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 칭함
> > >
> > > * 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 함
> > >
> > > * 두 개의 단위 모듈이 합쳐지면 두개의 기능을 구현할 수 있음
> > >
> > > * 단위 모듈의 구성 요소 : **처리문**, **명령문**, **데이터 구조** 등
> > >
> > > * 독립적인 컴파일 가능, 다른 모듈에 호출되거나 삽입되기도 함
> > >
> > > * 단위 모듈 구현 순서 : <u>단위 기능 명세서 작성 → 입출력 기능 구현 → 알고리즘 구현</u> 
> >
> > - 단위 모듈 명세서 작성 
> >
> > > 설계 과정에서 작성하는 기능 및 코드 명세서나 설계 지침과 같이 단위 기능을 명세화한 문서들을 의미
> > >
> > > * 이 단계에서는 복잡한 시스템을 단순하게 구현하기 위한 **추상화** 작업 필요
> > >
> > > * 대형 시스템을 **분해**해 단위 기능을 구분하고, 각 기능들을 계층적으로 구성하는 구조화 과정을 거침
> > >
> > > * 단위 기능 명세서 작성 시 모듈의 독립적인 운용과 한 모듈 내의 정보가 다른 모듈에 영향을 주지 않도록 **정보 은닉**의 원리 고려
> >
> > - 입출력 기능 구현
> >
> > > 단위 기능 명세서에서 정의한 데이터 형식에 따라 입출력 기능을 위한 알고리즘 및 데이터 구현
> > >
> > > * 이 단계에서는 단위 모듈 간의 연동 또는 통신을 위한 입출력 데이터를 구현
> > >
> > > * 입출력 기능 구현 시 CLI, GUI와의 연동 고려
> > > * CLI(Command Line Interface) : Telnet이나 DOS와 같이 키보드를 통해 명령어를 입력받음
> > > * GUI(Graphical User Interface) : 윈도우, MacOS와 같이 키보드, 마우스 등의 도구를 통해 화면의 아이콘, 메뉴 등 그래픽 요소로 명령을 입력 받음
> > > * 입부출력 기능 구현 시 네트워크나 외부 장치의 입출력은 Open Source API를 이용하면 간편 구현 가능
> > >
> > > ※ IPC(Inter Process Communication)
> > >
> > > ```
> > > [IPC(Inter-Process Communication)]
> > > 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
> > > 
> > > - 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현 가능
> > > 
> > > - IPC의 대표 메소드 5가지
> > > > Shared Memory:다수의 프로세스가 공유 가능한 메모리를 구성해 프로세스 간 통신 			   수행
> > > 
> > > > Socket:네트워크 소켓을 이용해 네트워크를 공유하는 프로세스들 간 통신을 수행
> > > 
> > > > Semaphores:공유 지원에 대한 접근 제어를 통해 프로세스 간 통신 수행
> > > 
> > > > Pipes & named Pipes: 'Pipe'라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신 수행
> > > 
> > > > Message Queuing: 메세지가 발생하면 이를 전달하는 형태로 프로세스 간 통신 수행 
> > > 
> > > 
> > > ```
> > >
> > > 
> >
> > - 알고리즘 구현 
> >
> > > 입출력 데이터를 바탕으로 **단위 기능별 요구 사항**들을 구현 가능한 언어를 이용해 **모듈**로 구현
> > >
> > > * 구현된 단위 기능들이 **사용자의 요구와 일치**하는지 확인하는 과정 필요
> > > * 구현되는 모듈의 종류를 단위 기능의 종류에 따라 다음으로 구분 함
> > >
> > > ```
> > > > 디바이스 드라이버 모듈 : 하드웨어 주변 장치의 동작을 구현한 모듈
> > > 
> > > > 네트워크 모듈 : 네트워크 장비 및 데이터 통신을 위한 기능을 구현한 모듈
> > > 
> > > > 파일 모듈 : 컴퓨터 내부의 데이터 구조 영역에 접근하는 방법을 구현한 모듈
> > > 
> > > > 메모리 모듈 : 파일을 프로세스의 가상 메모리에 매칭/해제하는 방법, 프로세스 사이의 통신 기능을 구현한 모듈
> > > 
> > > > 프로세스 모듈 : 하나의 프로세스 안에서 다른 프로세스를 생성하는 방법을 구현한 모듈
> > > ```
> > >
> > > 
> >
> > - 단위 모델 테스트 개요 
> >
> > > 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것
> > >
> > > * 단위 테스트라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법을 사용
> > >
> > > > * **화이트박스 테스트** : 모듈의 소스 코드를 오픈시킨 상태에서 소스 코드의 모든 **논리적** 경로를 테스트하는 방법
> > > > * **블랙박스 테스트** : 소프트웨어가 수행할 특정 **기능**이 완전히 작동되는 것을 입증하는 테스트
> > >
> > > * 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없음 
> >
> > - 테스트 케이스(Test Case)
> >
> > > 모듈이 올바르게 작성되었는지 확인하기 위해 모듈에 입력될 수 있는 여러 값들과 예상 결과들을 나열해 목록을 만드는 과정
> > >
> > > * 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당
> > > * 테스트 케이스를 이용하지 않는 직관적인 테스트는 인력과 시간을 낭비할 수 있음
> > > * ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같음
> > >
> > > ```
> > > > 식별자(Identifier) : 항목 식별자, 일련번호
> > > 
> > > > 테스트 항목(Test Item) : 테스트 대상
> > > 
> > > > 입력 명세(Input Specification) : 입력 데이터 또는 테스트 조건
> > > 
> > > > 출력 명세(Output Specification) : 테스트 케이스 수행 시 예상되는 출력 결과
> > > 
> > > > 환경 설정(Environmental Needs) : 필요한 하드웨어나 소프트웨어의 환경
> > > 
> > > > 특수 절차 요구(Special Procedure Requirement) : 테스트 케이스 수행 시 특별히 요구되는 절차
> > > 
> > > > 의존성 기술(Inter-case Dependencies) : 테스트 케이스 간의 의존성
> > > ```
> > >
> > > 
> >
> > - 테스트 프로세스
> >
> > > 테스트를 위해 수행하는 모든 작업들이 <u>테스트의 목적과 조건을 달성할 수 있도록 도와주는 과정</u>
> > >
> > > **테스트 프로세스 5단계**
> > >
> > > ① 계획 및 제어 단계 : 테스트 목표를 달성하기 위한 계획 수립, 계획대로 진행되도록 제어
> > >
> > > ② 분석 및 설계 단계 : 테스트 목표를 구체화해 테스트 시나리오와 테스트 케이스를 작성하는 단계
> > >
> > > **＊테스트 시나리오** : <u>테스트 케이스</u>들을 적용하는 <u>구체적인 절차</u>를 명세한 문서
> > >
> > > ③ 구현 및 실행 단계 : 효율적인 테스트 수행을 위해 테스트 케이스들을 조합해 테스트 프로시저에 명세하는 단계
> > >
> > > ＊**테스트 프로시저** : <u>테스트 케이스</u>의 <u>실행 순서</u>를 의미(=테스트 스크립트)
> > >
> > > ④ 평가 단계 : 테스트가 계획과 목표에 맞게 수행되었는지 평가, 기록
> > >
> > > ⑤ 완료 단계 : 이후의 테스트를 위한 참고 자료 및 테스트 수행에 대한 증거 자료로 활용하기 위해 수행 과정과 산출물을 기록 및 저장하는 단계
>
> - 개발 지원 도구 
>
> > - 통합 개발 환경(IDE: Integrated Development Environment)
> >
> > > 개발에 필요한 환경, 즉 **편집기(Editor)**, **컴파일러(Compiler)**, **디버거(Debugger)** 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 것을 의미
> > >
> > > * 통합 개발 환경을 제공하는 소프트웨어를 의미
> > > * 코드의 자동 생성 및 컴파일 가능, 추가 기능을 위한 도구들을 다운로드 할 수 있음
> > > * 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정 용이
> > > * 외부의 다양한 서비스와 연동 가능 
> > > * 통합 개발 환경을 지원하는 대표적인 도구는 다음과 같음
> >
> > | 프로그램                            | 개발사                  | 플랫폼        | 운영체제                 | 지원 언어                     |
> > | ----------------------------------- | ----------------------- | ------------- | ------------------------ | ----------------------------- |
> > | 이클립스(Eclipse)                   | Eclipse Foundation, IBM | 크로스 플랫폼 | Windows, Linux, MacOS 등 | JAVA, C++, C, PHP, JSP 등     |
> > | 비주얼 스튜디오(Visual studio)      | Microsoft               | Win32, Win64  | Windows                  | Basic, C++, C, C#, .NET 등    |
> > | 엑스 코드(Xcode)                    | Apple                   | Mac, iPhone   | MacOS, iOS               | C++, C, C#, JAVA 등           |
> > | 안드로이스 스튜디오(Android Studio) | Google                  | Android       | Windows, Linux, MacOS    | JAVA, C, C++                  |
> > | IDEA                                | JetBrains               | 크로스 플랫폼 | Windows, Linux, MacOS    | JAVA, JSP, XML, GO, Kotlin 등 |
> >
> > 
> >
> > - 빌드 도구 
> >
> > > 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업들을 수행하는 소프트웨어
> > >
> > > ＊**전처리(Preprocessing)** : 컴파일에 앞서 코드에 삽입된 주석을 제거하거나 매크로들을 처리하는 과정
> > >
> > > * 빌드 : 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말함
> > > * 대표적인 도구
> >
> > | 도구                   | 특징                                                         |
> > | ---------------------- | ------------------------------------------------------------ |
> > | Ant(Another Neat Tool) | - 아파치 소프트웨어 재단에서 개발한 소프트웨어, 자바 프로젝트의 공식적인 빌드 도구로 사용됨<br />- XML 기반의 빌드 스크립트 사용<br />- 자유도와 유연성 높음, 복잡한 빌드 환경에도 대처 가능<br />- 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의, 스크립트의 재사용 어려움 |
> > | Maven                  | - 아파치 소프트웨어 재단에서 개발한 소프트웨어, Ant의 대안으로 개발 됨<br />- 의존성을 설정해 라이브러리를 관리<br />- 컴파일과 빌드 동시 수행 가능<br />- 규칙이나 표준이 존재해 예외 사항만 기록하면 됨 |
> > | Gradle                 | - 기존의 Ant와 Maven을 보완해 개발된 빌드 도구<br />- 한스 토커 외 6인의 개발자가 모여 공동 개발함<br />- 안드로이드 스튜디오의 공식 빌드 도구로 채택된 도구- 의존성 활용, 그루비(Groovy) 기반의 빌드 스크립트 사용 |
> >
> > 
> >
> > - 기타 협업 도구 
> >
> > > 개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구로, 협업 소프트웨어, **그룹웨어(Gropware)** 등으로 불림
> > >
> > > * 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함되어 있음
> > > * 다양한 플랫폼에서 사용할 수 있도록 제공됨
> > > * 협업 도구가 익숙하지 않거나 이용할 의지가 없으면 협업 도구가 요히려 협업의 방해 요소가 될 수 있음
> > > * 협업 도구의 종류
> >
> > | 구분                      | 협업도구의 역할 및 예씨                                      |
> > | ------------------------- | ------------------------------------------------------------ |
> > | 프로젝트 및 일정 관리     | - 전체 프로젝트와 개별 업무들의 진행 상태, 일정 등을 공유하는 기능 제공<br />- 구글 캘린더, 분더리스트(Wunderlist), 트렐로(Trello), 지라(Jira), 플로우(Flow) 등 |
> > | 정보 공유 및 커뮤니케이션 | - 주체별로 구성원들을 지목해 방을 개설한 후 정보를 공유하고 대화가능  <br />- 파일 관리 간편, 의사소통 자유로움<br />- 슬랙(Slack), 잔디(Jandi), 태스크월드(Teskworld) 등 |
> > | 디자인                    | - 디자이너가 설계한 UI나 이미지의 정보들을 코드화하여 개발자에게 전달하는 기능 제공 <br />- 스케치(Sketch), 제플린(Zeplin) 등 |
> > | 기타                      | - 아이디어 공유에 사용되는 에버노트(Evernote)<br />- API를 문서화해 개발자들 간 협업을 도와주는 스웨거(Swagger)<br />- 깃(Git)의 웹호스팅 서비스인 깃허브(Github) |
> >
> > 

**3. 제품 소프트웨어 패키징**

> - 소프트웨어 패키징 
>
> > - 소프트웨어 패키징의 개요 
> >
> > > 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것
> > >
> > > * 개발자가 아닌 **사용자 중심**으로 진행
> > > * 소스 코드는 향후 관리를 고려해 모듈화하여 패키징함
> > >
> > > ＊**모듈화** : 시스템을 각 **기능**별로 나누는 것
> > >
> > > * 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징함
> > > * 사용자의 편의성 및 실행 환경을 우선적으로 고려해야 함
> >
> > * 패키징 시 고려사항
> >
> > > * 사용자의 시스템 환경, 즉 OS, CPU, 메모리 등에 필요한 <u>최소 환경을 정의</u>
> > > *  **UI**는 시각적인 자료와 함께 제공하고 <u>매뉴얼과 일치시켜 패키징</u>함
> > > * 소프트웨어를 패키징해 배포한 이후, 하드웨어와 함께 관리될 수 있도록 **Managed Service** 형태로 제공하는 것이 좋음
> > > * <u>고객의 편의성</u>을 고려한 안정적인 배포 중요
> > > * 패키징의 변경 및 개선에 대한 관리를 항상 고려해야 함
> >
> > - 패키징 작업 순서 
> >
> > > 패키징 주기는 소프트웨어 개발 기법에 따라 달라지는데, 각 주기가 끝날 때마다 패키징 수행
> > >
> > > * 프로젝트 개발 과정에서 주기별로 패키징한 결과물은 테스트 서버에 배포
> > > * 마지막 개발 과정을 거쳐 패키징한 결과물은 고객이 사용할 수 있도록 온라인 배포 또는 오프라인으로 배포 함
> > >
> > > ![패키징 작업 순위](.\패키징 작업 순위.png)
> > >
> > > 
>
> - 릴리즈 노트 작성
> - 디지털 저작권 관리(DRM)
> - 소프트웨어 버전 등록
> - 소프트웨어 버전 관리 도구 
> - 빌드 자동화 도구 

**4. 애플리케이션 테스트 관리**

> - 애플리케이션 테스트
> - 애플리케이션 테스트의 분류 
> - 테스트 기법에 따른 애플리케이션 테스트 
> - 개발 단계에 따른 애플리케이션 테스트 
> - 통합 테스트
> - 애플리케이션 테스트 프로세스 
> - 테스트 케이스 / 테스트 시나리오 / 테스트 오라클
> - 테스트 자동화 도구 
> - 결함관리 

**5. 인터페이스 구현**

> - 모듈 연계를 위한 인터페이스 기능 식별 
> - 인터페이스 기능 구현 정리 
> - 인터페이스 예외 처리 
> - 인터페이스 보안
> - 연게 테스트 
> - 인터페이스 구현 검증 