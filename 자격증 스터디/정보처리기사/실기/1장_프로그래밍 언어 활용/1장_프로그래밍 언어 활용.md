### 1장. 프로그래밍 언어 활용 

#### 단원별 요점 정리 

- 데이터 타입 

> 데이터 타입은 변수에 저장될 데이터의 형식을 나타내는 것으로, 변수에 값을 저장하기 전에 문자형, 정수형, 실수형 등 어떤 형식의 값을 저장할지 데이터 타입을 지정하여 변수를 선언해야 한다. 
>
> - C/C++이 데이터 타입 
>
> > **문자**
> >
> > ```
> > - char : 1byte | -128~127의 기억범위 
> > ```
> >
> > **부호없는 문자형**
> >
> > ```
> > - unsigned char : 1byte | 0~255의 기억범위 
> > ```
> >
> > **정수**
> >
> > ```
> > - short : 2byte | -32,768~32,767의 기억범위 
> > - int : 4byte | -2,147,483,648~2,147438,647
> > - long: 4byte | -2,147,483,648~2,147438,647
> > - long long: 8byte | -9,223,372,036,854,775,808~9,223,372,036,854,775,807
> > ```
> >
> > **부호없는 정수형**
> >
> > ```
> > - unsigned short : 2byte | 0~65,535
> > - unsigned int : 4byte | 0~4,294,967,295
> > - unsigned long : 4byte | 0~4,294,967,295
> > ```
> >
> > **실수**
> >
> > ```
> > - float : 4byte | 1.2*10^-38 ~ 3.4*10^38 의 기억범위
> > - double : 8byte | 2.2*10^-308 ~ 1.8*10^308
> > - long double : 8byte | 2.2*10^-308 ~ 1.8*10^308
> > ```
> >
> > ※ 논리형은 따로 존재하지 않는다. 
>
> - Java의 데이터 타입 
>
> > **문자**
> >
> > ```
> > -char : 2byte | 0 ~ 65,535 의 기억범위
> > ```
> >
> > **정수**
> >
> > ```
> > - byte : 1byte | -128~127 의 기억범위
> > - short : 2byte | -32,768~32,767 
> > - int : 4byte | -2,147,483,648~2,147438,647
> > - long: 8byte | -9,223,372,036,854,775,808~9,223,372,036,854,775,807
> > ```
> >
> > **실수**
> >
> > ```
> > - float : 4byte | 1.4*10^-45 ~ 3.4*10^38 의 기억범위 
> > - double : 8byte | 4.9*10^-324 ~ 1.8*10^308
> > ```
> >
> > **논리**
> >
> > ```
> > - boolean : 1byte | true 또는 False 
> > ```
>
> - Python의 데이터 타입 
>
> > **문자**
> >
> > ```
> > - str : 무제한 | 무제한 (*프로그램에 반영된 메모리의 한계까지)
> > ```
> >
> > **정수**
> >
> > ```
> > - int : 무제한 | 무제한 
> > ```
> >
> > **실수**
> >
> > ```
> > - float : 8byte | 4.9*10^ - 324 1.8*10^308
> > - complex : 16byte | 4.9*10^ - 324 1.8*10^308  (복소수를 의미, 허수8byte, 실수8byte)
> > ```
> >
> > 

- 변수

> 변수(variable)는 <u>컴퓨터가 명령을 처리</u>하는 도중 <u>발생하는 값</u>을 저장하기 위한 공간으로, **변할 수 있는 값**을 의미한다. → 정수형, 실수형, 문자형, 포인터형 등으로 구분 
>
> - 변수의 작성규칙 (C언어기준)
>
> > * 영문자, 숫자, _(under bar)를 사용할 수 있다. 
> > * 첫 글자는 영문자나 _로 시작해야 하며, 숫자는 올 수 없다. 
> > * 글자 수에 제한이 없다. 
> > * 공백이나 *,+,-,/ 등의 특수문자를 사용할 수 없다. 
> > * 대 소문자를 구분한다. 
> > * 예약어를 변수명으로 사용할 수 없다. 
> > * 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 한다. 
> >
> > ※ 자주 사용하는 변수를 상수로 만들어 사용하고 싶다면
> >
> > > 가령 C언어에서는 const 라는 예약어를 사용하여 변수를 상수화시키는 것이 가능하다 
> > >
> > > 이때 이런 변수를 심볼릭(symbolic) 상수라고도 한다.
> >
> > ```c
> > const float PI = 3.1415927;
> > ```
>
> -  기억 클래스 
>
> > 변수 선언 시 메모리 내에 변수의 값을 저장하기 위한 <u>기억영역이 할당</u>되는데, 할당되는 기억영역에 따라 사용범위의 제한이 있다. 이러한 기억영역을 결정하는 작업을 기억 클래스(Storage Class)라 한다. 
> >
> > ※ C언어에서는 다음과 같이 5종류의 기억 클래스를 제공한다. 
> >
> > ```
> > 1) 자동변수 
> > 자동변수는 함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수이다. 
> > - 함수나 블록이 실행되는 동안에만 존재하며 이를 벗어나면 자동으로 소멸된다. 
> > - 쵝화하지 않으면 쓰레기값(Garbage Value)이 저장된다. 
> > (auto는 기본값으로 생략이 가능하다)
> > 기억영역: 메모리(스택)
> > 예약어: auto
> > 생존기간: 일시적 
> > 사용범위: 지역적 
> > 
> > 2) 레지스터 변수 
> > 레지스터 변수는 메모리가 아닌 CPU내부의 레지스터에 기억영역을 할당받는 변수이다. 
> > - 자주 사용되는 변수를 레지스터에 저장하여 처리속도를 높이기 위해 사용한다. 
> > - 함수나 블록이 실행되는 동안에만 존재하며 이를 벗어나면 자동으로 소멸된다. 
> > - 레지스터의 사용 개수는 한정되어 있어 데이터를 저장할 레지스터가 없는 경우 자동 변수
> >   로 취급되어 메모리에 할당된다. 
> > - CPU에 저장되어 메모리 주소를 가질 수 없기 때문에 변수의 주소를 구하는 주소연산자(&)
> >   를 사용할 수 없다. 
> > 기억영역: 레지스터 
> > 예약어: register
> > 생존기간: 일시적 
> > 사용범위: 지역적 
> > 
> > 3) 정적변수(내적) 
> > 정적변수는 함수나 블록 내에서 선언하는 내부정적 변수와 함수 외부에서 선언하는 외부 정적변수가 있다. 
> > - 내부 정적 변수는 선언한 함수나 블록 내에서만 사용할 수 있다. 
> > - (내외부 모두) 함수나 블록이 종료된 뒤에도 값이 소멸하지 않는다. 
> > - 초기화는 변수 선언 시 한 번만 할 수 있으며, 초기화를 생략하면 자동으로 0으로 초기화
> >   된다. 
> > 기억영역: 메모리(데이터)
> > 예약어: static
> > 생존기간: 영구적 
> > 사용범위: 지역적
> > 
> > 4) 정적변수(외부) 
> > -외부 정적 변수는 모든 함수에서 사용할 수 있다. 
> > - (내외부 모두) 함수나 블록이 종료된 뒤에도 값이 소멸하지 않는다. 
> > - 초기화는 변수 선언 시 한 번만 할 수 있으며, 초기화를 생략하면 자동으로 0으로 초기화
> >   된다. 
> > 기억영역: 메모리(데이터)
> > 예약어: static
> > 생존기간: 영구적
> > 사용범위: 전역적 
> > 
> > 5) 외부변수
> > 외부 변수는 현재 파일이나 다른 파일에서 선언된 변수나 함수를 참조(reference)하기 위한 
> > 변수이다. 
> > - 외부 변수는 함수 밖에서 선언한다. 
> > - 함수가 종료된 뒤에도 값이 소멸되지 않는다. 
> > - 초기화하지 않으면 자동으로 0으로 초기화 된다. 
> > - 다른 파일에서 선언된 변수를 참조할 경우 초기화 할 수 없다. 
> > 기억영역: 메모리(데이터) 
> > 예약어: extern
> > 생존기간: 영구적
> > 사용범위: 전역적 
> > ```
> >
> > * 특정 구문으로 변수를 선언할 때 저장되는 값을 확인하는 문제 
> > * 특정 구문으로 변수를 선언하였을 때 잘못된 이유를 묻는 문제 출제 
>
> 

- 데이터 입출력

> - C언어의 표준 입출력 함수의 개요 
>
> 표준 입출력함수(Input-Output Functions)란 <u>키보드로 입력</u>받아 <u>화면으로 출력</u>할 때 사용하는 함수로, 대표적으로 scanf(), getchar(), gets(), printf(), putchar(), puts() 등이 있다. 
>
> - scanf()함수 
>
> > scanf()함수는 C언어의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수이다. 
> >
> > * 입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있다. 
> > * 한번에 여러개의 데이터를 입력받을 수 있다. 
> > * 서식 문자열과 변수의 자료형은 일치해야 한다. 
> >
> > ```c
> > scanf(서식 문자열, 변수의 주소) 
> > /*서식 문자열 : 입력받을 데이터의 자료형을 지정한다. 
> >   변수의 주소 : 데이터를 입력받을 변수를 적는다.
> >                 변수의 주소로 입력받아야 하기 때문에 변수에 주소 연산자(&)를 붙인다.  */
> > ```
> >
> > ```c
> > scanf("%3d", &a);
> > ```
> >
> > > * %: 서식 문자임을 지정 
> > > * 3: 입력 자릿수를 3으로 지정 
> > > * d: 10진수로 입력 
> > > * &a: 입력받은 데이터를 변수 a의 주소에 저장  
>
> - 서식 문자열의 종류
>
> > 서식 문자열은 printf() 함수로 출력할 때도 동일하게 적용된다. 
> >
> > * %d : 정수형 10진수를 입출력하기 위해 지정한다. 
> > * %u : 부호없는 정수형 10진수를 입출력하기 위해 지정한다. 
> > * %o : 정수형 8진수를 입출력하기 위해 지정한다. 
> > * %x : 정수형 16진수를 입출력하기 위해 지정한다. 
> > * %c : 문자를 입출력하기 위해 지정한다. 
> > * %s : 문자열을 입출력하기 위해 지정한다. 
> > * %f : 소수점을 포함하는 실수를 입출력하기 위해 지정한다. 
> > * %e : 지수형 실수를 입출력하기 위해 지정한다. 
> > * %ld: long형 10진수를 입출력하기 위해 지정한다. 
> > * %lo: long형 8진수를 입출력하기 위해 지정한다.
> > * %lx: long형 16진수를 입출력하기 위해 지정한다.
> > * %p : 주소를 16진수로 입출력하기 위해 지정한다. 
>
> |                    코드                     |       입력       |              결과               |
> | :-----------------------------------------: | :--------------: | :-----------------------------: |
> |              scanf("%d", &i);               |        20        |               20                |
> |              scanf("%4f", &j);              |      12.123      |              12.1               |
> | char b[8];<br>scanf("%d %f %s", &i, &j, b); | 345 2.62E-6 LOVE | i: 345<br>j: 2.62E-6<br>b: LOVE |
> |         scanf("%3d$$%3f", &i, &j);          |   123$$456789    |        i: 123<br>j: 456         |
>
> > ※ Java에서의 표준 입력 
> >
> > Java에서 키보드로 입력받은 값을 변수에 저장하려면 먼저 Scanner 클래스를 이용해 키보드로부터 값을 입력받는 객체 변수를 생성한 후 이를 사용해야 합니다. 
> >
> > ```java
> > Scanner Scan01 = new Scanner(System.in); // ①
> > inNum = scan01.nextInt(); // ②
> > ```
> >
> > ①객체 변수 생성
> >
> > * Scanner : 입력에 사용할 객체 변수를 생성할 떄 사용하는 클래스 이름. 
> > * Scan01 : 객체 변수명. 사용자 임의로 생성
> > * new : 객체 생성 예약어 
> > * Scanner() : 클래스의 이름. ()를 붙여 그대로 적어준다. 
> > * System.in : 표준 입력장치(예/ 키보드) 를 의미. <br>                   값을 입력받는 객체 변수를 생성할 것이므로 그대로 적음 
> >
> > ②객체 변수 활용 
> >
> > * inNum : 입력받은 값을 저장할 변수입니다. 이 변수는 미리 선언되어 있어야 합니다. 
> > * scan01.nextInt() :<br>scan01 : 입력에 사용할 객체 변수 이름. 객체 변수 생성시 사용한 객체 변수 이름과 동일해야 함. nextInt() : 입력받은 값을 정수형으로 반환합니다. 
> >
> > > **Scanner클래스의 입력 메소드**
> > >
> > > next() : 입력값을 문자열로 반환<br>nextLine() : 입력받은 라인 전체를 문자열로 반환<br>nextInt() : 입력값을 정수형으로 반환<br>nextFloat() : 입력값을 실수형으로 반환  
>
> - printf()함수 
>
> > printf()함수는 C언어의 표준 출력 함수로, 인수로 주어진 값을 화면에 출력하는 함수이다. 
> >
> > ```c
> > printf(서식 문자열, 변수)
> > /*
> > - 서식 문자열
> > : 변수의 자료형에 맞는 서식 문자열을 입력한다. 
> > 
> > - 변수 
> > : 서식 문자열의 순서에 맞게 출력할 변수를 적는다. scanf()와 달리 주소 연산자 &를 
> >   붙이지 않는다.
> > */
> > ```
> >
> > ```c
> > print("%-8.2f",200.2);
> > ```
> >
> > > * % : 서식 문자임을 지정 
> > > * ㅡ: 왼쪽부터 출력 
> > > * 8 : 출력 자릿수를 8자리로 지정 
> > > * 2 : 소수점 이하를 2자리로 지정 
> > > * f : 실수로 출력 
> >
> > * 주요 제어문자 
> >
> > > 제어 문자란 입력 혹은 출력 내용을 제어하는 문자이다. 
> > >
> > > ```c
> > > print("%d\n",a); // a의 값을 정수형 10진수로 출력한 후 다음 줄로 이동한다. 
> > > ```
> > >
> > > * \n : new line, 커서 다음 줄 앞으로 이동한다. 
> > > * \b : backspace, 커서를 왼쪽으로 한 칸 이동한다. 
> > > * \t : tab, 커서를 일정 간격 띄운다. 
> > > * \r : carriage return, 커서를 현재 줄의 처음으로 이동한다. 
> > > * \0 : null, 널 문자를 출력한다. 
> > > * \\'  : single quote, 작은따옴표를 출력한다. 
> > > * \\" : duble quote, 큰 따옴표를 출력한다. 
> > > * \a : alert, 스피커로 벨 소리를 출력한다. 
> > > * \\\\ : backslash, 역 슬래시를 출력한다. 
> > > * \f : form feed, 한 페이지를 넘긴다.    
> >
>
> |                       코드                       |             결과             |
> | :----------------------------------------------: | :--------------------------: |
> |                print("%d", 2543);                |             2543             |
> |               print("%e", 25.43);                |          2543000e+1          |
> |            print("%.3s", "help me");             |             hel              |
> |             print("%3s", "help me");             |           help me            |
> | print("a=%8.2f\t b=%e\n", 125.23f, 3141.592e-1); | a=  125.23<br>b=3.141592e+02 |
>
> 
>
> > ※ JAVA에서 표준출력 
> >
> > > Java에서 값을 화면에 출력할때는 printf() 메소드를 이용합니다. 
> > >
> > > ```java
> > > System.out.printf(서식 문자열, 변수)
> > >     
> > > // System 클래스의 서브 클래스인 out클래스의 메소드 printf()를 사용해서 출력한다는 의미. printf()메소드는 C언어의 printf() 함수와 사용법이 동일합니다. 
> > > ```
> > >
> > > ```java
> > > System.out.printf("%-8.2f", 200.2);
> > > // % : 서식 문자임을 지정 
> > > // - : 왼쪽부터 출력 
> > > // 8 : 출력 자릿수를 8자리로 지정 
> > > // 2 : 소수점 이하를 2자리로 지정 
> > > // f : 실수로 출력 
> > > ```
> >
> > 
>
> - 기타 표준 입출력 함수 
>
> > * 입력 
> >
> > > * getchar() : 키보드로 **한 문자**를 입력받아 변수에 저장하는 함수
> > > * gets() : 키보드로 **문자열**을 입력받아 저장하는 함수로, <u>enter를 누르기 전 까지를 하나의 문자열</u>로 인식하여 저장함 
> >
> > * 출력 
> >
> > > * putchar() : 인수로 주어진 **한 문자**를 화면에 출력하는 함수 
> > > * puts() : 인수로 주어진 문자열을 화면에 출력한 후 <u>커서를 자동으로 다음 줄 앞으로</u> 이동하는 함수 

- 연산자

> - 연산자 우선순위
>
> > 1. 증감연산자
> > 2. 산술연산자( *, /, %)
> > 3. 산술연산자(+ -)
> > 4. 시프트 연산자
> > 5. 관계 연산자(< <= >= >)
> > 6. 관계 연산자(==, !=) 
> > 7. 비트 연산자(&→^→| 순)
> > 8. 논리 연산자(&& → ||)
> > 9. 조건 연산자 
> > 10. 대입 연산자
> > 11. 순서 연산자
>
> - 증가연산자와(++) 감소연산자(--) (산술연산자中)
>
> > * 전치(ex/ ++a, --b)
> >
> > > 변수 앞에 증감 연산자가 오는 형태로 <u>먼저 변수의 값을 증감시킨 후</u> 변수를 연산에 사용한다. 
> >
> > * 후치(ex/ a++, b--)
> >
> > > 변수 뒤에 증감 연산자가 오는 형태로 <u>먼저 변수를 연산에 사용한 후</u> 변수의 값을 증감시킨다.
> >
> > ※ 전치연산자가 사용되었다면, 기존 변수 또는 후치에 사용되는 변수는 이미 전치를 거친 값으로 대체 된다. 
> >
> > Q. 다음에 제시된 산술 연산식의 결과를 적으시오(a=2, b=3, c=4, d=5)
> >
> > | 산술연산식                 | 결과 |
> > | -------------------------- | ---- |
> > | a = ++a + ++a;             | 8    |
> > | b = ++b - --c;             | 1    |
> > | c = ++b / b++;             | 1    |
> > | a = ++c + c++ + ++c + c++; | 24   |
> >
> > 
>
> - 관계 연산자 
>
> > 관계연산자는 두 수의 관계를 비교하여 참(True) 거짓(False)의 결과로 얻는 연산자
> >
> > 거짓은 0, 참은 1로 사용되지만 0외의 모든 숫자도 참으로 간주한다. 
>
> - 비트 연산자 
>
> > 비트 연산자는 비트별(0,1)로 연산하여 결과를 얻는 연산자이다.
> >
> > * & : and, 모든 비트가 1일때만 1
> > * ^ : xor, 모든 비트가 같으면 0, 하나라도 다르면 1 
> > * | : or, 모든 비트 중 한 비트라도 1이면 1 
> > * ~ : not, 각 비트의 부정, 0이면 1, 1이면 0
> > * << : 왼쪽 시프트, 비트를 왼쪽으로 이동 (>> 는 오른쪽 시프트)
> >
> > Q. 다음에 제시된 비트 연산식의 결과를 적으시오(a=5, b=7)
> >
> > ※ 각각 이진법을 적용시키면 a=101, b=111 
> >
> > | 비트 연산식                   | 결과               |
> > | ----------------------------- | ------------------ |
> > | a&b                           | 5                  |
> > | a\|b                          | 7                  |
> > | a^b                           | 2                  |
> > | ~b                            | -8<br>(2의 보수법) |
> > | a >> 1<br>(101→010)           | 2                  |
> > | b << 3<br>(111→111<u>000</u>) | 56                 |
> >
> > 
>
> - 논리 연산자 
>
> > 논리 연산자는 두개의 논리 값을 연산하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자이다. 
> >
> > * ! : not, 부정
> > * && : and, 모두 참이면 참 
> > * || : or, 하나라도 참이면 참 
>
> * 대입 연산자 
>
> > 연산 후 결과를 대입하는 연산식을 간략하게 입력할 수 있도록 제공됨. 
> >
> > 산술, 관계, 비트, 논리 연산자에 모두 적용될 수 있음. 
> >
> > ```
> > ex/ +=, -=, *=, /=, %=, <<=, >>= 
> > ```
>
> - 조건 연산자 
>
> > 조건 연산자는 조건에 따라 서로 다른 수식을 수행한다. 
>
> ```
> 조건 ? 수식1 : 수식2;  	//'조건'의 수식이 참이면 '수식1'을, 거짓이면 '수식2'를 실행
> ```
>
> - 기타 연산자 
>
> > * sizeof : 자료형의 크기를 표시한다. 
> >
> > * ,(콤마) : 콤마로 구분하여 한 줄에 두 개 이상의 수식을 작성하거나 변수를 정의한다. 
> >
> >   ​			   왼쪽에서 오른쪽으로 순서대로 수행되며, 순서 연산자라 부르기도 한다. 
> >
> > * (자료형) : 사용자가 자료형을 다른 자료형으로 변환할 떄 사용하는 것으로, cast(캐스트)연산자 라고 부른다. 
> >
> >   변환할 자료형을 괄호 안에 넣어서 변환할 값이나 변수명 앞에 놓는다. 
> >
> > ```c
> > a = (int)1.3 + (int)1.4;  //a에는 2저장 
> > ```
>
> 
>
> - 연산자 우선순위 (높음 → 낮음)
>
> > **증감 연산자** → **산술 연산자**(*,/,%) → **산술 연산자**(+, -) → **시프트 연산자** → **관계 연산자**(<,>,<=,>=) → **관계 연산자**(==, !=) → **비트 연산자**(& → ^ → |) → **논리 연산자**(&& → ||) → **조건 연산자** → **대입 연산자** → **순서 연산자**

- 제어문

> - 제어문의 종류에는 if문, 다중 if문, switch문, goto, 반복문 등이 있다. 
> - 다중 if문의 예시
>
> ```C
> // 점수에 따라 등급 표시 
> #include <stdio.h>
> main()
> {
>     int jum = 85;
>     if(jum >= 90)
>         printf("학점은 A입니다.\n");
>     else if(jum>=80)
>         printf("학점은 B입니다.\n");
>     else if(jum>=70)
>         printf("학점은 C입니다.\n");
>     else
>         printf("학점은 F입니다.\n");
> }
> ```
>
> - switch문
>
> > switch문은 조건에 다라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문이다. 
> >
> > * break문은 생략이 가능하지만 break문이 생략되면 수식과 레이블이 일치할 때 실행할 문장부터 break문 또는 switch문이 종료될 때까지 모든 문장이 실행된다. 
>
> - goto문
>
> > goto문은 프로그램 실행 중 현재 위치에서 원하는 다른 문장으로 건너뛰어 수행을 계속하기 위해 사용하는 제어문이다. 
> >
> > * goto문은 원하는 문장으로 쉽게 이동할 수 있지만 많이 사용하면 프로그램의 이해와 유지 보수가 어려워 거의 사용하지 않는다. 
>
> ```c
> #include <stdio.h>
> main()
> {
>     int a;
>    again: // 이동할 체크포인트
>     scanf("%d", &a);
>     if(a <= 10)
>         goto again; // again레이블로 이동 
>     else
>         printf("%d는 10보다 큽니다.", a);
> }
> ```
>
> 

- 반복문

> - 반복문은 제어문의 한 종류로 일정한 횟수를 반복하는 명령문을 말한다.<br>변수의 값을 일정하게 증가시키면서 정해진 수가 될 때까지 명령이나 명령 그룹을 반복 수행한다. 
> - 반복문에는 for, while, do~while문이 있다. 
> - break, continue 
>
> > * **break** : switch문이나 반복문 안에서 break가 나오면 블록을 벗어난다. 
> > * **continue** :<br>continue이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮긴다. 반복문에만 사용한다. 

- 배열과 문자열 

> - 배열은 동일한 데이터 유형을 여러개 사용해야 할 경우 이를 손쉽게 처리하기 위해 여러개의 변수를 조합해서 하나의 이름으로 정의해 사용하는 것을 말한다. 
> - 배열은 하나의 이름으로 여러 기억장소를 가리키기 때문에 배열에서 개별적인 요소들의 위치는 첨자를 이용하여 지정한다. 
> - 변수병 뒤에 []붙이고 그 안에 사용할 개수를 지정한다. (ex/ a[i])
> - C언어에서 배열의 **위치는 0**부터 시작한다.
> - 배열은 행 우선으로 데이터가 기억장소에 할당된다. 
> - C언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫번째 요소의 주소를 지정하는 것과 같다. 
> - 2차원 배열 
>
> > * 2차원 배열은 변수들을 평면, 즉 행과 열로 조합한 배열이다. 
>
> ```c
> // 예 : int b[3][3]
> ```
>
> 

- 포인터

> 포인터는 변수의 주소를 말하며, C언어에서는 주소를 제어할 수 있는 기능을 제공한다. 
>
> (Java, Python 에서는 포인터 변수를 사용할 수 없다.)
>
> - C언어에서 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라고 한다. 
>
> - 포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 *를 붙인다.(ex/ int *a;)
>
> - 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &를 붙인다. 
>
>   (ex/ a = &b)
>
> - 실행문에서 포인터 변수에 간접 연산자 *를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말한다. 
>
>   (ex/ c = *a)
>
> ```c
> int a = 100; //변수 a 초기값 선언 
> int *a; 	//변수 a의 포인터 변수 선언 
> int b = &a;  //변수 b의 초기값 선언, 초기값은 변수 a의 주소
> int *b;  	//변수 b의 포인터 변수 선언 
> int c = *b;  //(하단 표 참조) *b는 b에 저장된 주소가 가리키는 곳에 저장된 값을 말하므로 			   C의 초기값은 100이 된다. 	
> ```
>
> | 변수명 | 메모리주소 | 메모리에 저장된값 |
> | ------ | ---------- | ----------------- |
> |        | 0          |                   |
> | a      | 4          | 100               |
> |        | 8          |                   |
> | b      | 50         | 4                 |
> |        |            |                   |
>
> - 포인터 변수는 필요에 의해 동적으로 할당되는 메모리 영역인 **힙 영역**에 접근하는 동적 변수이다. 
> - 포인터 변수의 영역 
>
> > * 연결된 자료 구조를 구성하기 위해 사용한다. 
> > * 동적으로 할당된 자료 구조를 지정하기 위해 사용한다. 
> > * 배열을 인수로 전달하기 위해 사용한다. 
> > * 문자열을 표현하기 위해 사용한다. 
> > * 커다란 배열에서 요소를 효율적으로 저장하기 위해 사용한다. 
> > * 메모리에 직접 접근하기 위해 사용한다. 
> >
>
> - 포인터와 배열 
>
> > 배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있다. 
> >
> > * 배열의 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫번째 요소의 주소를 지정하는 것과 같다. 
> > * 배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 &연산자를 사용한다. 
> >
> > ```c
> > int a[5], *b
> > b = a //배열의 대표명을 적었으므로 a배열의 시작 주소인 a[0]의 주소를 b에 저장한다. 
> > b = &a[0] // a배열의 첫번재 요소인 a[0]의 주소(&)에 저장한다. 
> >     
> > /*
> > 
> > ↓배열 표기 방법 
> > a[0]--------a[1]--------a[2]--------a[3]--------a[4]
> > *(a+0)------*(a+1)------*(a+2)------*(a+3)------*(a+4)
> > ↑포인터 표기 방법 
> > (배열상의 주소는 순차적일태니, 어찌보면 당연한 개념)
> > 
> > */
> > ```
> >
> > ```c
> > main() 
> > {
> >     int a[5]; //5개의 요소를 갖는 정수형 배열 a를 선언. [0,1,2,3,4]
> >     
> >     int i;    //정수형 변수 선언 
> >     int *p;   //포인터 변수 *p 선언
> >     for(i=0; i<5; i++)  
> >         a[i] = i + 10; //반복변수 i가 5번보다 작은 동안 1씩 증가하면서 해당식을 반복
> >     		
> >     p = a;	// p = a = [10,11,12,13,14]	
> >     
> >     for(i=0; i<5; i++) 		
> >         printf("%d", *(p+i)); //반복문을 통해 p의 요소들을 차례대로 출력 
> >     						//만약 %d\n이라면 그 결과출력 그대로 적을 것 
> > }
> > ```
> >
> > 

- 사용자 정의 함수

> 사용자 정의 함수는 사용자가 <u>필요한 기능을 취향대로</u> 만들어 사용할 수 있는 함수이다. 사용자 정의 함수를 사용하면 <u>프로그램 구조가 간단</u>해지고 이해하기가 쉬워진다. 무엇보다 <u>동일한 코드를 반복 입력하는 수고를 줄일 수 있다.</u> 
>
> ```c
> #include <stdio.h>
> func(i,j); //사용할 함수를 선언하는 곳. 리턴값이 있으므로 void를 생략한다. 
> 
> main()
> {
>     int a=3, b=12;
>     a = func(a,b);
>     
>     prinf("%d, %d\n", a, b); // 반환받은 값에 의하여 결과는 9, 12
>     
> }
> 
> func(i,j)
>     
> int(i,j);
> {
>     i *= 3;
>     j /= 3;
>     printf("%d, %d\n", i, j);
>     return i; //리턴값, 사용자 정의 함수에 void를 명시해주느냐 아니냐의 핵심 
>     		 /* 호출한 곳, 즉 여기서는 main()함수로 값을 돌려주기 위해 사용하는 명령. 
>     		    return문을 만나면 가지고 갈 값을 챙겨 함수를 종료하고 호출한 곳으로 돌아
>     		    간다. 괄호를 사용해 'return(i);' 와 같이 입력해도 된다. 
>     		    i를 반환하므로 'a=func(a,b)'로 이동하여 i가 가지고 있는 값 9를 a에 저장
>     		    한다. 
>     		 */
> }
> ```
>
> 

- JAVA의 클래스와 메소드

> 클래스는 객체 생성을 위한 필드(속성)와 메소드(함수)를 정의하는 설계도로, Java는 아무리 작은 프로그램이라도 클래스를 만들어서 사용한다. 
>
> - 클래스 생성 순서
>
> > 1. 클래스 이름을 정하고, 객체 생성을 위한 필드(속성)와 메소드(함수)를 정의한다. 
> >
> >    → 이때 사용하는 명령어가 class
> >
> > 2. 객체를 생성한다. 클래스를 이용해 객체를 생성해야 프로그램에서 사용할 수 있다. 
> >
> >    → 이때 사용하는 명령어가 new
> >
> > 3. 이후 생성된 객체들을 이용하여 코딩진행. 
>
> - 어떤 것이 메소드 이름이고, 어떤 것이 인수이며, 어떤것이 자료형을 나타내는 부분인지 위주로 학습.
>
> ```java
> // 두 수를 교환하는 java프로그램 
> public class Example {
>     static class AAclass{ //Example클래스를 정의한다. 클래스 안의 클래스를 정의할 때는 						   static을 붙인다. 
>         int i;
>         int j;   
>     }
> 	public static void main(String[] args){
>         AAclass myVal = new AAclass(); //객체변수 myVal을 생성한다. 
>         myVal.i = 10;
>         myVal.j = 20;
>         myVal = change(myVal);
>         System.out.printf("i=%d, j=%d\n", myVal.i, myVal.j);
>     }
>     static AAclass change(AAclass myVal){
>         int temp;
>         temp = myVal.i;
>         myVal.i = myVal.j;
>         myVal.j = temp;
>         return myVal;
>     }
> }
> 
> ```
>
> 

- Python의 기초 

> - 파이썬의 기본문법
>
> > * 변수의 자료형에 대한 선언이 없다. 
> > * 문장의 끝을 의미하는 세미콜론(;)을 사용할 필요가 없다. 
> > * 변수를 연속하여 값을 저장하는 것이 가능하다. (ex/ x,y,z = 10,20,30)
> > * if나 for와 같이 코드 블록을 포함하는 명령문을 작성할 때 코드 블록은 콜론(:)과 여백으로 구분.
> > * 여백은 일반적으로 4칸 또는 한 개의 탭만큼 띄워야 하며, 같은 수준의 코드들은 반드시 동일한 여백을 가져야 한다. 
>
> - 리스트(List)
>
> > C와 Java의 배열과 비교되는 파이썬의 백미 
> >
> > * 리스트는 필요에 따라 개수를 늘리거나 줄일 수 있기 때문에 리스트를 선언할 때 크기를 적지 않는다 .
> > * 배열과 달리 하나의 리스트에 정수, 실수, 문자열 등 다양한 자료형을 섞어서 저장할 수 있다. 
> > * Python에서 리스트의 위치는 0부터 시작한다. + exclusive 한 형식 
>
> - 슬라이스(Slice)
>
> > 슬라이스는 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라(Slicing)반환하는 기능이다. 
> >
> > * 객체명[초기위치:최종위치]
> >
> > > '초기위치'에서 '최종위치-1'까지의 요소들을 가져온다. 
> >
> > * 객체명[초기위치:최종위치:증가값]
> >
> > > '초기위치'에서 '최종위치-1'까지 증가값 만큼 증가하면서 해당 위치의 요소들을 가져온다. 
> > >
> > > '증가값'이 음수인 경우, '초기위치'에서 '최종위치+1' 까지 '증가값'만큼 감소하면서 해당 위치의 요소들을 가져온다. (exclusive이니깐)
> >
> > * 객체명[초기위치:]
> >
> > > 객체의 0번째 위치에서 마지막 위치까지의 요소들을 반환(=객체명[초기위치:최종위치])
> >
> > * 객체명[:최종위치]
> >
> > > 객체의 0번째 위치에서 '최종위치-1' 까지의 요소들을 반환한다(=객체명[초기위치:])
> >
> > * 객체명[::증가값]
> >
> > > 객체의 0번째 위치에서 마지막 위치까지 '증가값' 만큼 증가하면서 해당 위치의 요소들을 반환한다. 

- Python의 활용 

> - 클래스 
>
> > C보다는 Java와 유사한 형식의 class. 개념이 동일하므로 서로 비교하면서 학습할 것 
> >
> > ```python
> > class 클래스명: #클래스는 예약어로, 그대로 입력하고 클래스명은 사용자가 임의로 지정
> >     실행할 문장 
> >     def 메소드명(self, 인수): #def는 메소드 정의 예약어. 
> >         				    #그대로 입력하고 이름은 사용자가 임의지정
> >         실행할 문장 			#self는 클래스가 속한 메소드에 반드시 포함되어야 하는 
> >         				    #예약어로, 사용자가 임의로 지정한다.
> >             				#인수는 메소드를 호출하는 곳에서 보낸 값을 저장할 변수
> >                 			#(역시 사용자가 임의지정)
> >         
> >         return값			    '''
> >         					return은 메소드를 호출한 위치로 값을 돌려주기 위해 
> >         					사용하는 예약어로, return값이 없는 경우 생략가능 
> >         					'값'에는 변수, 객체, 계산식 등이 올 수 있다. 
> >         					'''		
> > ```
> >
> > * 객체의 선언형식
> >
> > ```python
> > 변수명 = 클래스명() 
> > #변수명은 사용자가 임의로 지정하고, 사전에 정의한 클래스명과 괄호 명시
> > ```
> >
> > ```python
> > # 두 수를 교환하는 프로그램을 python으로 구현하기 
> > class Cls:
> >     x, y = 10,20
> >     def chg(self):
> >         temp = self.x
> >         self.x = self.y
> >         self.y = temp 
> >         
> > a = Cls()
> > print(a.x, a.y) #10 20 
> > a.chg()
> > print(a.x, a.y) #20 10 
> > ```
> >
> > ```python
> > # 0부터 10까지 더하는 프로그램을 Python으로 구현한 것
> > class Cls:
> >     def rep(self, r):
> >         
> >         hap = 0
> >         for i in range(r+1):
> >             
> >             hap += i 
> >         return hap 
> > a = Cls()
> > b = a.rep(10)
> > 
> > print(b) #55
> > ```
> >
> > 

- 라이브러리

> 라이브러리는 <u>프로그램을 효율적으로 개발할 수 있도록</u> <u>자주 사용하는 함수</u>나 <u>데이터들을 미리 만들어 놓은 집합체</u>이다. 
>
> - 자주 사용하는 함수들의 반복적인 코드 작성을 피하기 위해 미리 만들어 놓은 것으로, 필요할 때는 언제든지 호출하여 사용할 수 있다. 
> - 라이브러리에는 표준 라이브러리와 외부 라이브러리가 있다. 
>
> > * 표준 라이브러리 
> >
> > > 프로그래밍 언어에 기본적으로 포함되어있는 라이브러리로, 여러 종류의 모듈이나 패키지 형태이다. 
> >
> > * 외부 라이브러리 
> >
> > > 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용 
>
> - C언어의 대표적인 표준 라이브러리 
>
> > C언어에서는 라이브러리를 **헤더 파일**로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되어 있다. 
> >
> > * C언어에서 헤더 파일을 사용하려면 '#include<stdio.h>' 와 같이 include문을 이용해 선언한 후 사용해야 한다. 
> >
> > | 헤더파일 | 기능                                                         |
> > | -------- | ------------------------------------------------------------ |
> > | stdio.h  | - 데이터의 입출력에 사용되는 기능들을 제공한다.<br>- printf, scanf, fprintf, fscanf, fclose, fopen 등 |
> > | math.h   | - 수학 함수들을 제공한다. <br>- sqrt, pow, abs 등            |
> > | string.h | - 문자열 처리에 사용되는 기능들을 제공한다 <br>- atoi, atof, srand, rand, malloc, free 등 |
> > | time.h   | - 시간 처리에 사용되는 기능들을 제공한다. <br>- time, clock 등 |
> > |          |                                                              |
>
> - Java의 대표적인 표준 라이브러리 
>
> > Java는 라이브러리를 **패키지**에 포함하여 제공하는데, 각 패키지에는 Java 으용 프로그램 개발에 필요한 메소드(Java에서 특정 기능을 수행하는 함수)들이 클래스로 정의되어 있다. 
> >
> > * Java에서 패키지를 사용하려면 'import java.util'과 같이 import문을 이용해 선언한 후 사용해야 한다. 
> > * import로 선언된 패키지 안에 있는 클래스의 메소드를 사용할 때는 클래스와 메소드를 마침표(.)로 구분하여 'Math.abs()'와 같이 사용한다. 
> >
> > | 패키지    | 기능                                                         |
> > | --------- | ------------------------------------------------------------ |
> > | java.lang | - java에 기본적으로 필요한 인터페이스, 자료형, 예외처리 등에 관련된 기능을 제공<br>-import 문 없이도 사용할  수 있다. <br>-String, System, Process, Runtime, Math, Error등 |
> > | java.util | - 날짜처리, 난수발생, 복잡한 문자열 처리 등에 관련된 기능을 제공한다. <br>- Date, Calender, Random, StringTokenizer 등 |
> > | java.io   | - 파일 입출력과 관련된 기능 및 프로토콜을 제공한다.<br>- InputStream, OutputStream, Reader, Writer 등 |
> > | java.net  | - 네트워크와 관련된 기능을 제공한다.<br>- Socket, URL, InetAddress 등 |
> > | java.awt  | - 사용자 인터페이스(UI)와 관련된 기능을 제공<br>- Frame, Panel, Dialog, Button, Checkbox 등 |
> >
> > 
>
> - Python의 대표적인 표준 라이브러리 
>
> > Python은 Java와 동일하게 라이브러리를 **패키지**로 제공하며, 패키지에는 응용 프로그램 개발에 필요한 **클래스**와 **메소드**들이 정의되어 있다. 
> >
> > * Python에서 라이브러리를 사용하려면 'import random'과 같이 선언하고, 사용할 때는 마침표(.)로 구분하여 'random.choice()'와 같이 사용한다. 
> >
> > | 클래스     | 기능                                                         |
> > | ---------- | ------------------------------------------------------------ |
> > | 내장함수   | - 파이썬의 기본적인 인터페이스로, import문이나 클래스명 없이 사용가능<br>- abs(), slice(), pow(), print() 등 |
> > | os         | - 운영체제와 상호작용하기 위한 기능을 제공한다<br>-getcwd(), chdir(), system() 등 |
> > | re         | - 고급 문자열 처리를 위한 기능을 제공한다.<br>- findall(), sub() 등 |
> > | math       | - 복잡한 수학 연산을 위한 기능을 제공한다<br>- cos(), log() 등 |
> > | random     | - 무작위 선택을 위한 기능을 제공한다.<br>- choice(), sample(), random(), randrange() 등 |
> > | statistics | - 통계값 산출을 위한 기능을 제공한다. <br>- mean(), median(), variance() 등 |
> > | datetime   | - 날짜와 시간 조작을 위한 기능을 제공한다.<br>- today(), date(), strftime() 등 |
> >
> > 

- 절차적 프로그래밍 언어

> 절차적 프로그래밍 언어는 <u>일련의 처리 절차</u>를 정해진 문법에 따라 순서대로 기술해 나가는 언어이다. 
>
> - 프로그래밍이 실행되는 **절차**를 중요시한다. 
> - 데이터를 중심으로 프로시저를 구현하며, <u>프로그램 전체가 유기적으로 연결</u>되어 있다. 
> - 자연어에 가까운 단어와 문장으로 구성된다. 
> - 주로 **과학계산**이나 **하드웨어 제어**에 사용된다. 
>
> - 절차적 프로그래밍 언어의 장단점 
>
> | 장점                                                         | 단점                          |
> | ------------------------------------------------------------ | ----------------------------- |
> | 컴퓨터 처리 구조와 유사하며 실행 속도가 빠르다               | 프로그램을 분석하기 어렵다    |
> | 같은 코드를 복사하지 않고 다른 위치에서 호출하여 사용할 수 있다. | 유지보수나 코드 수정이 어렵다 |
> | 모듈 구성이 용이하며, 구조적인 프로그래밍이 가능하다.        |                               |
>
> - 절차적 프로그래밍 언어의 종류 
>
> > * C
> >
> > > * 1972년, 벨 연구소의 데니스 리치에 의해 개발 
> > >
> > > * 시스템 소프트웨어 개발에 편리(시스템 프로그래밍 언어로 널리 사용)
> > >
> > > * 자료의 주소를 조작 가능한 '포인터' 제공
> > >
> > > * 고급 프로그래밍 언어 + 저급 프로그램 언어 특징을 겸함
> > >
> > >   (기계 친화적 + 사용자 친화적)
> > >
> > > * 컴파일러 방식의 언어
> > >
> > >   (컴파일러: 고급 언어로 작성된 프로그램을 기계어로 번역하는 프로그램)
> > >
> > > * 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램을 작성할 수 있다.
> >
> > * ALGOL
> >
> > > * 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어이다. 
> > > * PASCAL과 C언어의 모체과 됨
> >
> > * COBOL
> >
> > > * 사무 처리용 언어 
> > > * 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉽다. 
> > > * 4개의 DIVISION으로 구성되어 있다. 
> >
> > * FORTRAN
> >
> > > * 과학 기술 계산용 언어 
> > > * 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 할 수 있다. 

- 객체지향 프로그래밍 언어

> 객체지향 프로그래밍 언어는 **현실세계의 개체(Entity)**를 기계의 부품처럼 하나의 객체로 만들어, <u>기계적인 부품들을 조립하여 제품을 만들 듯</u>이 소프트웨어를 개발할 때도 <u>객체들을 조립하여 프로그램을 작성</u>할 수 있도록 한 **프로그래밍 기법**이다. 
>
> - 객체지향 프로그래밍 언어의 장단점 
>
> | 장점                                                  | 단점                                                         |
> | ----------------------------------------------------- | ------------------------------------------------------------ |
> | 상속을 통한 재사용과 시스템의 확장에 용이하다.        | 프로그래밍 구현을 지원해 주는 정형화된 분석 및 설계 방법이 없다. |
> | 코드의 재활용성이 높다.                               | 구현 시 처리 시간이 지연된다.                                |
> | 자연적인 모델링에 의해 분석과 설계가 쉽고 효율적이다. |                                                              |
> | 사용자와 개발자 사이의 이해를 쉽게 해준다.            |                                                              |
> | 대형 프로그램의 작성이 용이하다.                      |                                                              |
> | 소프트웨어 개발 및 유지보수가 용이하다.               |                                                              |
>
> - 객체지향 프로그래밍 언어의 종류 
>
> > * Java
> >
> > > * 분산 네트워크 환경에 적용이 가능하며, **멀티스레드** 기능을 제공하므로 여러 작업을 동시에 처리할 수 있다. 
> > > * 운영체제 및 하드웨어에 독립적이며, 이식성이 강하다. 
> > > * 캡슐화가 가능하고 재사용성이 높다.
> >
> > * C++
> >
> > > * C언어에 객체지향 개념을 적용한 언어이다. 
> > > * 모든 문제를 객체로 모델링하여 표현한다. 
> >
> > * Smalltalk
> >
> > > * 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어이다. 
> > > * **최초로 GUI를 제공**한 언어이다. 

- 스크립트 언어 

> 스크립트 언어는 HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 것으로, 기계어로 컴파일 되지 않고, 별도의 변역기가 소스를 분석하여 동작하게 하는 언어
>
> - 게시판 입력, 상품 검색, 회원가입 등과 같은 데이터베이스 처리 작업을 수행하기 위해 주로 사용한다. 
> - 스크립트 언어는 서버용 스크립트 언어와 클라이언트용 스크립트 언어로 나뉜다. 
>
> > * 서버용 스크립트 언어 
> >
> > > 서버에서 해석되어 실행된 후 결과만 클라이언트로 보내는 언어 
> > >
> > > (ASP, JSP, PHP, 파이썬 등이 존재)
> >
> > * 클라이언트용 스크립트 언어 
> >
> > > 클라이언트의 웹 브라우저에서 해석되어 실행되는 클라이언트용 언어 
> > >
> > > (자바 스크립트(JavaScript))
>
> - 스크립트 언어의 장단점 
>
> | 장점                                                    | 단점                                            |
> | ------------------------------------------------------- | ----------------------------------------------- |
> | 컴파일 없이 바로 실행하므로 결과를 바로 확인할 수 있다. | 코드를 읽고 해석하야 하므로 실행 속도가 느리다. |
> | 배우고 코딩하기 쉽다.                                   | 런타임  오류가 많이 발생한다.                   |
> | 개발 시간이 짧다.                                       |                                                 |
> | 소스 코드를 쉽고 빠르게 수정할 수 있다.                 |                                                 |
> |                                                         |                                                 |
>
> - 스크립트 언어의 종류 
>
> > * 자바 스크립트(JavaScript)
> >
> > > * **넷스케이프**의 **브렌던 아이크**가 개발한 클라이언트용 스크립트 언어 
> > > * **웹페이지의 동작**을 제어하며, 변수 선언이 필요없다. 
> > > * 서버에서 데이터를 전송할 때, 아이디 비밀번호, 수량 등의 입력 사항을 확인하기 위한 용도로 많이 사용된다. 
> >
> > * ASP(Active Server Page)
> >
> > > * 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 **마이크로 소프트** 사에서 제작
> > > * **Windows개열**에서만 수행 가능한 프로그래밍 언어 
> >
> > * JSP(Java Server Page)
> >
> > > * **Java**로 만들어진 서버용 스크립트 언어로, 다양한 운영체제에서 사용이 가능하다. 
> >
> > * PHP(Professional Hypertext Preprocessor)
> >
> > > * 서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용이 가능하다. 
> > > * C, Java 등과 문법이 유사하므로 배우기 쉬워 **웹 페이지 제작**에 많이 사용된다. 
> >
> > * Python
> >
> > > * 객체지향 기능을 지원하는 **대화형 인터프리터 언어**로 플랫폼에 독립적이며 문법이 간단하여 배우기 쉽다. 
> > >
> > > ※ 인터프리터 언어: 인터프리터 언어는 원시 프로그램을 줄 단위로 번역하여 바로 실행해주는 언어로, 목적 프로그램을 생성하지 않고 즉시 실행 결과를 출력합니다. 

- 선언형 언어

> 선언형 언어는 명령형 언어와 반대되는 개념의 언어로, 명령형 언어가 문제를 해결하기 위한 방법을 기술한다면 선언형 언어는 <u>프로그램이 수행해야 할 문제를 기술</u>하는 언어이다. 
>
> - 선언형 언어는 **목표를 명시**하고 **알고리즘은 명시하지 않는다.** 
> - 선언형 언어에는 **함수형 언어**와 **논리형 언어**등이 있다.
>
> > * 함수형 언어 
> >
> > > * 수학적 함수를 조합하여 문제를 해결하는 언어로, 알려진 값에 함수를 적용하는 것을 기반으로 한다. 
> > > * 적용형 언어라고도 한다. 
> > > * 재귀호출이 자주 이용된다. 
> > > * 병렬 처리에 유리하다. 
> > > * 종류: LISP
> >
> > * 논리형 언어 
> >
> > > * 기호 논리학에 기반을 둔 언어로, 논리 문장을 이용하여 프로그램을 표현하고 계산을 수행한다. 
> > > * 선언적 언어라고도 한다. 
> > > * 반복문이나 선택문을 사용하지 않는다. 
> > > * 비절차적 언어이다. 
> > > * 종류: PROLOG
>
> - 선언형 언어의 장단점 
>
> > * 가독성이나 재사용성이 좋다. 
> > * 작동 순서를 구체적으로 작성하지 않기 때문에 오류가 적다. 
> > * 프로그램 동작을 변경하지 않고도 관련 값을 대체할 수 있다. 
>
> - 선언형 프로그래밍 언어의 종류 
>
> > * HTML
> >
> > > * 인터넷의 표준 문서인 **하이퍼텍스트 문서**를 만들기 위해 사용하는 언어 
> > > * 특별한 데이터타입이 없는 단순한 텍스트이므로 호환성이 좋고 사용이 편리 
> >
> > * LISP
> >
> > > * **인공지능 분야**에 사용되는 언어 
> > > * 기본 자료 구조가 연결 리스트 구조이며, **재귀(Recursion)**호출을 많이 사용한다. 
> >
> > * PROLOG
> >
> > > * **논리학**을 기초로 한 고급 언어로, **인공지능 분야**에서의 논리적인 추론이나 리스트 처리 등에 주로 사용된다. 
> >
> > * XML
> >
> > > * <u>기존 HTML의 단점을 보완</u>하여 웹에서 구조화된 폭 넓고 다양한 문서들을 상호 교환할 수 있도록 설계된 언어 
> > > * HTML사용자가 <u>새로운 태그(Tag)를 정의</u>할 수 있으며, 문서의 내용과 이를 표현하는 방식이 독립적이다. 
> >
> > * HASCAL
> >
> > > * 함수형 프로그래밍 언어로 **부작용(Side Effect)이 없다.** 
> > > * **코드가 간결**하고 에러 발생 가능성이 낮다. 

- 예외처리 

> 프로그램의 정상적인 실행을 방해하는 조건이나 상태를 예외라 하며, 이러한 <u>예외가 발생하였을 때 프로그래머가 해당 문제에 대비해 작성해 놓은 처리 루틴</u>을 수행하도록 하는 것을 예외처리라고 한다. 
>
> - 일반적인 처리 루틴: 1) 프로그램 종료, 2)로그를 남김
>
> - C++, Ada, Java, 자바스크립트와 같은 언어들은 예외처리 기능이 내장되어 있으며, 그밖의 언어들은 조건문을 이용하여 예외처리 루틴을 직접 작성할 수 있다. 
>
> - 예외의 원인으로는 
>
>   하드웨어 문제, 운영체제의 설정 실수, 라이브러리 손상, 사용자의 입력 실수, 받아들일 수 없는 연산, 할당하지 못하는 기억장치 접근 등이 있다. 

