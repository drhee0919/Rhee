

### 3장. 데이터 입출력 구현

#### 단원별 요점 정리(31~39, 총 9개) 

- 데이터 모델의 개념 

> 데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형이다. 
>
> - 데이터 모델의 구성요소
>
> > * **개체**(Entity)
> >
> >   : 데이터베이스에서 표현하려는 것으로, 사람이 생각하는 개념이나 정보단위 같은 <u>현실 세계의 대상체</u>. 
> >
> > * **속성**(Attribute)
> >
> >   : 데이터의 <u>가장 작은 논리적 단위</u>로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다. 
> >
> > * **관계**(Relationship)
> >
> >   : 개체 간의 관계 또는 속성 간의 <u>논리적인 연결</u>을 의미함.
>
> - 데이터 모델의 종류 
>
> > * **개념적** 데이터 모델
> >
> >   : 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 <u>추상적 개념</u>으로 표현하는 과정.  
> >
> > * **논리적** 데이터 모델 
> >
> >   : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정. 
> >
> > * **물리적** 데이터 모델 
>
> - 데이터 모델에 표시할 요소 
>
> > * **구조**(Structure)
> >
> >   : 논리적으로 표현된 개체 타입들 간의 관계로서 <u>데이터 구조</u> 및 <u>정적 성질</u>을 표현한다. 
> >
> > * **연산**(Operation)
> >
> >   : 데이터베이스에 저장된 <u>실제 데이터를 처리하는 작업에 대한 명세</u>로서 데이터베이스를 조작하는 기본 도구.
> >
> > * **제약조건**(Constraint)
> >
> >   : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건. 

- 이상/ 함수적 종속/ 정규화 

> - 이상(Anomally)
>
> > 이상이란 테이블에서 일부 속성들의 **종속**으로 인해 데이터의 **중복**이 발생하고, 이런 중복으로 인해 <u>테이블 조작 시 문제가 발생</u>하는 현상을 의미. 
> >
> > * 삽입이상
> >
> > > 테이블에 데이터를 삽입할 때 의도와는 상관업이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상. 
> > >
> > > ex/ 기본키 속성에 대한 데이터 누락 
> >
> > * 삭제이상
> >
> > > 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상. 
> > >
> > > ex/ 특정 속성만을 제거하고자 하였으나 유지되어야 할 정보까지 제거되는 경우 
> >
> > * 갱신이상
> >
> > > 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상.
> > >
> > > ex/ '학년'과 같이 특정 속성의 값을 갱신하고자 한다면, 특정 대상이 아닌 모든 튜플의 학년 값을 갱신해야 한다.  
>
> - 함수적 종속(Functional Dependecy)
>
> > 어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 할때,<br>속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y값이 오직 하나만 연관되어 있을 때, <br>이를 <u>Y는 X에 함수적 종속</u>, 또는 <u>X가 Y를 함수적으로 결정</u>한다고 하고 
> >
> > ​																" **X → Y** " 로 표기한다. 
>
> - 정규화 
>
> > 정규화는 테이블의 속성들이 <u>상호 종속적인 관계</u>를 갖는 특성을 이용하여 테이블을 **무손실 분해** 하는 과정 
> >
> > ※ 기사 과정에서는 1~5정규형까지의 정규화 단계를 다룬다. (다음 단계는 이전 단계 만족을 전재)
> >
> > * 제 1정규형
> >
> > > 테이블에 속한 모든 속성의 도메인이 원자값만으로 되어 있는 정규형<br>(테이블의 모든 속성 값이 <u>원자 값</u>으로만 되어 있는 정규형)
> >
> > * 제 2정규형 
> >
> > > 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형<br>('<u>부분적 함수적 종속</u>' 모두 제거)
> > >
> > > ※부분 함수적 종속 : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 함. 
> >
> > * 제 3정규형
> >
> > > 기본키가 아닌 모든 속성이 기본키에 대해 '<u>이행적 함수적 종속</u>' 을 만족하지 않는 정규형 <br>(A → B → C)
> >
> > - BCNF
> >
> > > <u>모든 결정자가 후보키</u>(Candidate Key)인 정규형 
> > >
> > > ※ **후보키**는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들을 말한다. 하나의 릴레이션내에서는 중복된 튜플들이 있을 수 없으므로 모든 릴레이션에는 반드시 하나 이상의 **후보키**가 존재한다.
> >
> > * 제 4정규형
> >
> > > 테이블에 <u>다중 값 종속</u> A→→B가 존재할 경우, 테이블의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형 
> > >
> > > ※ 다중 값 종속(다치종속)<br>: A, B, C 3개의 속성을 가진 테이블 R에서 어떤 복합 속성(A, C)에 대응하는 B 값의 집합이 A 값에만 종속되고 C 값에는 무관하면, B는 A에 다중 값 종속이라 하고, A →→ B로 표기함.
> >
> > - 제 5정규형
> >
> > > 테이블의 모든 <u>조인 종속</u>이 테이블의 후보키를 통해서만 성립되는 정규형

- 논리 데이터 모델의 물리 데이터 모델로 변환 

> - 테이블(Table)
>
> > 테이블은 데이터를 저장하는 데이터베이스의 <u>가장 기본적인 오브젝트</u>
> >
> > * 테이블은 컬럼(열)과 로우(행)으로 구성되며, 컬럼에는 지정된 유형에 따라 데이터가 저장된다. 
> > * 테이블의 구성요소 
> >
> > > * 로우 : 튜플, 인스턴스, 어커런스
> > > * 컬럼 : 각 속성 항목에 대한 값을 저장
> > > * 기본키<br>기본키는 후보키 중에서 선택한 주키(Main Key)이다.<br>한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성. 
> > > * 외래키<br>다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미<br>한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본적인 B가 동일한 도메인 상에서 정의되었을 때, 속성 A를 외래키라고 지칭. 
>
> - 엔티티(Entity)를 → 테이블로 변환 
>
> > 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환하는 것 
> >
> > → 엔티티를 테이블로 변환한 후 '테이블 목록 정의서' 를 작성한다. 
> >
> > * 테이블 목록 정의서 : 전체 테이블을 목록으로 요약 관리하는 문서로, <u>테이블 목록</u>이라고도 한다.
> > * 변환 시 고려사항 
> >
> > > * 일반적으로 테이블과 엔티티 명칭은 동일하게 하는 것을 권고 
> > > * 엔티티는 주로 한글명을 사용하지만 테이블을 소스 코드의 가독성을 위해 영문명을 사용한다. 
> > > * 메타 데이터 관리 시스템에 표준화된 용어가 있을 때는 메타에 등록된 단어를 사용하여 명명한다. 
>
> - 슈퍼타입/서브타입을 → 테이블로 변환 
>
> > 슈퍼타입/서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 슈퍼타입/ 서브타입을 테이블로 변환해야 한다. 
> >
> > → 슈퍼타입/서브타입 모델을 테이블로 변환하는 방법에는 <u>슈퍼타입 기준 테이블 변환</u>, <u>서브타입 기준 테이블 변환</u>, <u>개별타입 기준 테이블 변환</u>이 있다. 
> >
> > ※ 슈퍼타입과 서브타입<br>:부모의 속성 중에 더 작은 그룹으로 분리해서 관리할 필요가 있는 속성이 있을 때, 슈퍼타입 또는 서브타입 단위로 모델링 한다. 그 중 <u>슈퍼타입(전체를 하나의 테이블로 관리)</u>에 정의된 공통 속성과 각 서브타입의 속성을 더하여 <u>각각의 서브타입별로 테이블을 설계하는 방법</u>이 서브타입 단위의 모델링이다.
> >
> > * 슈퍼타입 기준 테이블 변환
> >
> > > 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것
> > >
> > > * 서브타입에 속성이나 관계가 적을 경우 사용하는 방법. 하나로 통합된 테이블에는 서브타입의 모든 속성이 포함되어야 한다. 
> > >
> > > **장점**
> > >
> > > > * <u>데이터의 액세스가 상대적으로 용이하다.</u> 
> > > > * 뷰를 이용하여 각각의 서브타입만을 액세스하거나 수정할 수 있다. 
> > > > * 서브타입 구분이 없는 임의 집합에 대한 처리가 용이하다. 
> > > > * <u>여러 테이블을 조인하지 않아도 되므로 수행 속도가 빨라진다.</u> 
> > > > * <u>SQL문장 구성이 단순해진다.</u> 
> > >
> > > **단점**
> > >
> > > > * <u>테이블의 컬럼이 증가하므로 디스크 저장 공간이 증가한다.</u> 
> > > > * <u>처리마다 서브타입에 대한 구분(Type)이 필요한 경우가 많이 발생한다.</u> 
> > > > * <u>인덱스 크기의 증가로 인덱스의 효율이 떨어진다.</u> 
> >
> > * 서브타입 기준 테이블 변환 
> >
> > > 서브타입 기준의 테이블 변환은 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것. 
> > >
> > > → 서브타입에 속성이나 관계가 많이 포함된 경우 사용한다. 
> > >
> > > **장점**
> > >
> > > > * 각 서브타입 속성들의 선택 사양이 명확한 경우에 유리하다.
> > > > * 처리할 때마다 서브타입 유형을 구분할 필요가 없다.
> > > > * 여러 개의 테이블로 통합하므로 테이블당 크기가 감소하여 전체 테이블 스캔시 유리.
> > >
> > > **단점**
> > >
> > > > * 수행 속도가 감소할 수 있다. 
> > > > * 복잡한 처리를 하지 하는 SQL통합이 어렵다. 
> > > > * 부분 범위에 대한 처리가 곤란해진다. 
> > > > * 여러 테이블을 통합한 뷰는 조회만 가능하다. 
> > > > * 식별자(UID)의 유지 관리가 어렵다. 
> >
> > * 개별타입 기준 테이블 변환 
> >
> > > 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것 
> > >
> > > * 슈퍼타입과 서브타입 테이블들 사이에는 각각 1:1 관계가 형성된다. 
> > > * 개별타입 기준 테이블 변환을 적용하는 경우 
> > >
> > > > * 전체 데이터에 대한 처리가 빈번한 경우 
> > > > * 서브타입 처리가 대부분 독립적으로 발생하는 경우 
> > > > * 통합하는 테이블의 컬럼수가 많을 경우
> > > > * 서브타입의 컬럼 수가 많은 경우 
> > > > * 트랜잭션의 주로 슈퍼타입에서 발생하는 경우 
> > > > * 슈퍼타입의 처리 범위가 넓고 빈번히 발생하며 단일 테이블 클러스터링이 필요한 경우
> > >
> > > **장점**
> > >
> > > > * 저장 공간이 상대적으로 작다
> > > > * 슈퍼타입 또는 서브타입 각각의 테이블에 속한 정보만 조회하는 경우 문장 작성이 용이하다. 
> > >
> > > **단점**
> > >
> > > > * 슈퍼타입 또는 서브타입의 정보를 같이 처리하면 항상 조인이 발생하여 성능이 저하.
> >
> > 
>
> - 속성을 컬럼으로 변환
>
> > 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환한다. 
> >
> > * 일반 속성 변환
> >
> > > * 속성과 컬럼의 명칭은 반드시 일치할 필요는 없으나, 개발자와 사용자  의사송통을 위하여 가능한 한 표준화된 약어를 사용하여 일치시키는 것이 좋다. 
> > > * 컬럼명은 SQL의 <u>예약어 사용을 피한다.</u> 
> > > * 컬럼명은 SQL의 가독성을 높이기 위해 <u>가능한 한 짧게</u> 지정한다. 
> > > * 복합 단어를 컬럼명으로 사용할 때는 미리 정의된 표준을 따른다. 
> > > * 테이블의 칼럼을 정의한 후에는 한 행(Row)에 해당하는 샘플 데이터를 작성하여 <u>컬럼의 정합성을 검증</u>한다. 
> >
> > * Primary UID를 기본키로 변환
> > * Primary UID(관계의 UID Bar; 다른 엔티티와의 관계로 인해 형성된 식별자)를 기본키로 변환
> > * Secondary(Alternate) UID를 유니크키로 변환 
>
> - 관계를 외래키로 변환
>
> > 논리 데이터 모델에서 정의된 관계는 <u>기본키</u>와 이를 참조하는 <u>외래키</u>로 변환한다. 
> >
> > * 1:1 관계 
> >
> > > 개체 A의 기본키를 개체 B의 <u>외래키로 추가</u>하거나 개체 B의 기본키를 개체 A의 외래키로 추가하여 표현한다. 
> >
> > * 1:M 관계
> >
> > > 개체 A의 기본키를 개체 B의 <u>외래키로 추가</u>하여 표현하거나<br><u>별도의 테이블</u>로 표현한다. 
> >
> > - 1:M 순환관계(자기 자신을 참조)
> >
> > > 개체 A에 개체A의 기본키를 참조하는 <u>외래키 칼럼을 추가</u>하여 표현한다.<br> (→기본키에서 한칸씩 밀어서)<br>데이터의 계층 구조를 표현하기 위해 주로 사용.
> >
> > * N:M 관계
> >
> > > 릴레이션 A와 B이 기본키를 모두 포함한 별도의 릴레이션으로 표현한다.<br>이를 <u>교차 릴레이션,</u> 또는 <u>교차 엔티티</u>라고 한다. 
>
> - 관리 목적의 테이블, 칼럼 추가
>
> > 논리 데이터 모델에서는 존재하지 않는 테이블이나 컬럼을 데이터베이스의 관리 혹은 데이터베이스를 이용하는 프로그래밍의 수행 속도를 향상시키기 위해 물리 데이터 모델에 추가할 수 있다. 
> >
> > (ex/ 시스템 등록 일자, 시스템 번호)
>
> - 데이터 타입 선택
>
> > 논리 데이터 모델에서 정의된 논리적인 데이터 타입을 물리적인 DBMS의 물리적 특성과 성능을 고려하여 최적의 데이터 타입과 데이터 최대 길이를 선택한다. 
> >
> > ※ORACLE DBMS에서 자주 사용되는 데이터 유형 
> >
> > * CHAR : 고정길이 문자열 데이터(최대 2000Byte까지 저장 가능)
> > * VARCHAR2 : 가변길이 문자열 데이터(최대 4000Byte까지 저장 가능)
> > * NUMBER : 38자릿수의 숫자 저장 가능 
> > * DATE : 날짜 저장  

- 반정규화(Denormalization)

> 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위. 
>
> * 시스템 성능이 향상되고 관리 효율성이 증가할 수 있지만, 데이터의 일관성 및 정합성을 저하시킬 수 있다. 
> * 사전에 데이터의 일관성과 무결성을 우선으로 할지, 성능과 단순화를 우선으로 할지를 결정해야 함.
> * 테이블 통합 
>
> > 두 개의 테이블이 조인 되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능향상에 도움이 될 경우에 수행 
> >
> > (1:1 / 1:N 관계 테이블 통합, 슈퍼타입 / 서브타입 테이블 통합)
> >
> > * 테이블 통합시 고려사항 
> >
> > > * 데이터 검색은 간편하지만 레코드 증가로 인해 처리량이 증가한다. 
> > > * 테이블 통합으로 인해 입력, 수정, 삭제 규칙이 복잡해질 수 있다. 
> > > * Not Null, Default, Check 등의 제약조건을 설계하기 어렵다. 
>
> * 테이블 분할
>
> > * 수평 분할
> >
> > > * 레코드를 기준으로 테이블을 분할 
> > > * 레코드별로 사용 빈도의 차이가 큰 경우 수행
> >
> > * 수직 분할 
> >
> > > * 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할 
> > > * <u>갱신이 자주 일어나는 속성</u>, <u>자주 조회되는 속성</u>, <u>크기가 큰 속성</u>, <u>보안이 적용되어야 하는 속성</u>이 있을 경우 분할한다. 
>
> * 중복 테이블 추가 
>
> > 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업 효율성을 향상 시킬 수 있다. 
> >
> > * 중복 테이블을 추가하는 경우 
> >
> > > * 정규화로 인해 수행 속도가 느려지는 경우
> > > * 많은 범위의 데이터를 자주 처리해야 하는 경우
> > > * 특정 범위의 데이터만 자주 처리해야 하는 경우
> > > * 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우에 추가 
> >
> > * 추가 방법
> >
> > > * 집계 테이블의 추가 
> > > * 진행 테이블의 추가 
> > > * 특정 부분만을 포함하는 테이블을 추가 
>
> * 중복 속성 추가
>
> > 중복 속성의 추가는 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것. 
> >
> > → 중복 속성을 추가하면 데이터 무결성 확보가 어렵고, 디스크 공간이 추가로 발생한다. 
> >
> > * 중복 속성을 추가하는 경우
> >
> > > * 조인이 자주 발생하는 속성인 경우 
> > > * 접근 경로가 복잡한 속성인 경우 
> > > * 액세스의 조건으로 자주 사용되는 속성인 경우 
> > > * 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우 
> >
> > * 중복 속성 추가 시 고려 사항
> >
> > > * 테이블 중복과 속성의 중복을 고려한다. 
> > > * 데이터 무결성 및 일관성에 유의해야 한다. 
> > > * SQL 그룹 함수를 이용하여 처리할 수 있어야 한다. 
> > > * 저장 공간의 지나친 낭비를 고려한다. 
>
> 

- 인덱스 설계

> 인덱스는 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조이다. 
>
> - 인덱스는 데이터가 저장된 물리적 구조와 밀접한 관계가 있다. 
> - 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다. 
> - 인덱스를 통해서 파일의 레코드에 대한 액세스를 빠르게 수행할 수 있다. 
> - 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적이다. 
> - 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 'TABLE SCAN' 이 발생한다. 
> - 기본키를 위한 인덱스를 기본 인덱스라고 하고, 그 밖의 인덱스들을 보조 인덱스라고 한다.<br>(대부분의 관계형 DBMS에서는 모든 기본키에 대해서 자동적으로 기본 인덱스를 생성한다.)
> - 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를<br>'클러스터드 인덱스' 라고 한다. 
> - 인덱스의 유형 
>
> > * 트리 기반 인덱스 
> >
> > > 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것 
> > >
> > > * B트리 인덱스 
> > > * B+트리 인덱스
> >
> > * 비트맵 인덱스
> >
> > > 인덱스 컬럼의 데이터를 0또는 1의 비트값으로 변환하여 인덱스키로 사용하는 방법 
> >
> > * 함수 기반 인덱스
> >
> > > 인덱스 컬럼의 값 대신 특정 함수나 수식을 적용하여 산출된 값을 사용하는 방법 
> > >
> > > → 함수로 B+트리 인덱스 또는 비트맵 인덱스를 생성하여 사용한다. 
> >
> > * 비트맵 조인 인덱스
> >
> > > 단일 객체로 구성된 일반적인 인덱스 액세스 방법과 <u>다르게 다수의 조인된 객체</u>로 구성된 인덱스
> >
> > * 도메인 인덱스
> >
> > > 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스라고도 함. 
>
> - 인덱스 설계 순서
>
> > 인덱스를 설계할 때는 분명하게 드러난 칼럼에 대해 기본적인 인덱스를 먼저 지정한 후<br>개발 단계에서 필요한 인덱스의 설계를 반복적으로 진행한다. 
> >
> > 1. 인덱스의 대상 테이블이나 컬럼 등을 선정한다. 
> > 2. 인덱스의 효율성을 검토하여 인덱스 최적화를 수행한다. 
> > 3. '인덱스 정의서' 를 작성한다. 
>
> - 인덱스 대상 테이블 선정 기준 
>
> > * MULTI BLOCK READ(테이블 엑세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수) 수에 따라 판단
> > * 랜덤 액세스가 빈번한 테이블
> > * 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
> > * 다른 테이블과 순차적 조인이 발생되는 테이블 
>
> - 인덱스 대상 컬럼 선정 기준 
>
> > * 인덱스 컬럼의 분포도가 10~15%이내인 컬럼(↔ 클러스터(분포도가 넓어야 좋다))
> > * 부분 처리를 목적으로 하는 컬럼
> > * 조회 및 출력 조건으로 사용되는 컬럼 
> > * 기본키와 Unique키 제약 조건을 사용한 컬럼
> > * 가능한 한 수정이 빈번하지 않은 컬럼
> > * ORDER BY, GROUP BY, UNION이 빈번한 컬럼
> > * 분포도가 좁은 컬럼은 단독 인덱스를 생성
> > * 인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스로 생성 

- 뷰 설계 
- 클러스터 설계
- 파티션 설계 
- 데이터베이스 용량 설계 
