## 공기업 전산학

#### 1. 데이터베이스

#### 2. 컴퓨터 구조 

> **2-1) 컴퓨터의 발전과정**
>
> > - ENIAC
> >
> > > * 미국 펜실베니아 대학 모클리와 에커트 교수가 제작 
> > > * 진공관을 이용한 최초의 전자식 컴퓨터 
> > > * 외부 프로그램 방식 채용 
> > > * 10진법 체계 사용 
> > > * 프로그램을 저장하고 변경하는 것이 불가능(단점) 
> >
> > - EDSAC
> >
> > > * 영국 캠프리지 대학 출신 윌크스와 동료들이 제작 + 폰노이만 참여 
> > > * 최초로 프로그램 내장 방식 채용: 컴퓨터에 미리 저장시켜 놓았다가 순서대로 실행 
> > > * 2진법 체계 사용 
> >
> > - EDVAC
> >
> > > - 에커트와 모클리, 폰 노이만의 참여로 제작 → ENIAC을 개량 
> > > - 프로그램 내장 방식 채용 
> > > - 2진법 체계 사용 
> >
> > - UNIVAC-Ⅰ
> >
> > > * 최초의 상업용 전자식 컴퓨터(일기예보 성공)
> > > * 미국 통계국에서 구입 
> >
> > ※ 폰 노이만 구조 
> >
> > > 제어장치, 연산장치, 기억장치로 이루어진 프로그램 내장방식의 설계구조로, 기존 대부분의 컴퓨터가 채택하고 있는 방식 
> > >
> > > 프로그램 내장 방식은 '전자계산기에 기억장치를 갖추고 연산의 순서를 부호화해 기억시킨 후 기억된 내용을 순차적으로 꺼내 명령을 해독하고 연산을 실행한다' 는 현대적 컴퓨터의 개념을 갖고 있다. 
> >
> > 
> >
> > **2-2) 컴퓨터의 세대별 발전 **
> >
> > > - 1세대(1946~1956)
> > >
> > > > * 회로: 진공관
> > > > * 대표 시스템: ENIAC, EDSAC, EDVAC, UNIVAC
> > > > * 주기억장치: 자기 드럼, 수은지연회로 
> > > > * 보조기억장치: 천공카드, 종이 테이프
> > > > * 처리속도: ms(밀리초)
> > > > * 사용언어: 기계어, 어셈블리어 
> > > > * 특징
> > > >
> > > > > * 진공관 사용에 따른 컴퓨터 크기가 매우 크고 엄청난 전력 소모와 열 발생 
> > > > > * 폰 노이만의 제안한 프로그램 내장의 개념 도입 
> > > > > * 수치 계산, 통계 등에 사용 
> > >
> > > - 2세대 (1957~1964)
> > >
> > > > * 회로: 트랜지스터
> > > > * 대표 시스템: IBM 7094, CDC 1604
> > > > * 주기억장치: 자기 코어
> > > > * 보조기억장치: 자기 드럼, 자기 디스크
> > > > * 처리속도: μs(마이크로초) 
> > > > * 사용언어: 고급언어(COBOL, FORTLAN, ALGOL)
> > > > * 특징
> > > >
> > > > > * 자기 드럼이나 자기 디스크 같은 대용량의 보조 기억장치 사용 
> > > > > * 운영체제의 개념 최초 도입
> > > > > * 다중 프로그래밍 기법 사용 
> > > > > * 온라인 실시간 처리 방식을 도입 
> > > > > * 과학계산, 일반 사무용으로 제작 
> > >
> > > - 3세대(1965~1979)
> > >
> > > > * 회로: 집적회로(IC, Integrated Circuit)
> > > > * 대표 시스템: IBM 360 시리즈, UNIAC 9000시리즈, PDP-11
> > > > * 주기억장치: IC(RAM, ROM)
> > > > * 보조기억장치: 자기 디스크, 자기 테이프
> > > > * 처리속도: ns(나노초)
> > > > * 사용언어: 고급언어(LISP, PASCAL, BASIC, PL/I)
> > > > * 특징 
> > > >
> > > > > * 캐시 기억장치가 등장 
> > > > > * OMR, OCR, MICR이 도입 
> > > > > * 패밀리 개념의 출현에 따라 프로그램의 호환성이 이루어졌다. 
> > > > > * 시분할 처리를 통해 멀티프로그래밍을 지원했다. 
> > > > > * 경영 정보 시스템이 확립되었다. 
> > >
> > > - 4세대(1980~1990)
> > >
> > > > * 회로: 고밀도 집적회로(LSI), 초고밀도 집적회로(VLSI)
> > > > * 대표 시스템: system/370계열(IBM), PDP-8(DEC), 매킨토시(애플), PC/XT, PC/AT(IBM)
> > > > * 주기억장치: LSI, VLSI
> > > > * 보조기억장치: 자기 디스크, 자기 테이프
> > > > * 처리속도: ps(피코초)
> > > > * 사용언어: 고급언어(ADA 등), 문제 지향적 언어 
> > > > * 특징 
> > > >
> > > > > * 마이크로프로세서가 개발됨 
> > > > > * 가상 기억 장치 개념의 도입 
> > > > > * 컴퓨터 네트워크의 발전 
> > >
> > > - 5세대(1990~현재)
> > >
> > > > * 회로: 초고밀도 직접회로(VLSI), 극대규모 집적회로(ULSI)...
> > > > * 주기억장치: VLSI
> > > > * 보조기억장치: 자기디스크, 광디스크
> > > > * 처리속도: fs(펨토초)
> > > > * 사용언어: 객체지향언어 등
> > > > * 특징
> > > >
> > > > > * 기존 시스템의 수준을 벗어나 경영정보, 지식정보, 인공지능, 신경망, 퍼지, 멀티미디어, 가상 현실을 목표로 하고 있다. 
> > > > > * 컴퓨터의 성능을 향상시키기 위해 다중 프로세서를 사용한 병렬 처리 컴퓨터 시스템, 광 컴퓨터, 신경망 컴퓨터 등의 개발과 인공지능의 연구가 활발히 진행되고 있다. 

#### 3. 운영체제

#### 4. 소프트웨어 공학

#### 5. 데이터 통신

#### 6. 정보보안

> **6-1) 보안의 3대 요소(정보보호의 목표)**
>
> > - 기밀성(Confidentially)<br>: 인가(authorization)된 사용자면 정보 자산에 접근할 수 있는 것을 의미 
> >
> > - 무결성(Integrity)<br>인가된 사람에 의해 인가된 방법으로만 정보를 변경할 수 있는 것을 의미 
> > - 가용성(Availability)<br>정보와 정보시스템의 사용을 인가받은 사람이 그를 사용하려고 할 때 언제든지 사용할 수 있도록 보장하는 것을 의미 
>
> **6-2) 보안공격**
>
> > - 소극적 공격과 적극적 공격(※X.800과 RFC2828에 의거한 분류) 
> >
> > | 구분        | 소극적공격                          | 능동적 공격                                                  |
> > | ----------- | ----------------------------------- | ------------------------------------------------------------ |
> > | 특징        | 직접적인 피해 없음                  | 직접적인 피해 있음                                           |
> > | 탐지가능성  | 어려움                              | 쉬움                                                         |
> > | 대표적인 예 | 스니핑, 도청(하이재킹), 트래픽 분석 | 변경, 신분위장, 재전송, <br>부인, DOS/DDOS, 사회공학, 세션 하이재킹 |
> >
> > - 기밀성(C)을 위협하는 공격
> >
> > > * 스누핑(Snooping)
> > >
> > > > 데이터에 대한 비인가 접근, 또는 탈취를 의미
> > > >
> > > > ex/ 인터넷으로 전송되는 기밀정보를 담고 있는 파일을 비인가자가 가로채고 메시지 내용을 자신의 이익을 위하여 사용하는 사례
> > >
> > > * 트래픽 분석(Traffic Analysis)
> > >
> > > > 도청자가 온라인 트래픽을 분석함으로서 다른 형태의 정보를 얻거나 암호화된 데이터의 내용을 우회적으로 분석 
> >
> > - 무결성(I)을 위협하는 공격
> >
> > > * 변경(변소, 수정, Modification)
> > >
> > > > 적법한 메시지의 일부를 수정하거나 메시지 전송을 지연시키거나 순서를 뒤바꾸어 인가되지 않은 효과를 노리는 행위를 지칭
> > >
> > > *  신분위장(가장, Masquerading)
> > >
> > > > 신분위장은 한 개체가 다른 개체의 행세를 하는 것으로서 다른 형태의 적극적 공격과 병행되어 수행된다
> > >
> > > * 재전송(재연, Replaying)
> > >
> > > > 적극적 공격의 대표사례로, 획득한 데이터 단위를 보관하고 시간이 경과한 후에 재전송함으로써 인가되지 않은 사항에 접근하는 효과를 노리는 행위 
> > >
> > > * 부인(Repudiation)
> > >
> > > > 메시지 송신자가 차후에 자신이 메시지를 보냈다는 것을 부인할 수 있고, 메시지 수신자는 차후에 메시지 받았다는 것을 부인할 수 있음
> >
> > - 가용성(A)을 위협하는 공격
> > - 기타 보안공격들 

#### 7. 자료구조 

> **7-1) 알고리즘 성능 분석방법**
>
> **7-2) 알고리즘의 조건**
>
> **7-3) 자료구조의 개념**
>
> **7-4) 자료구조의 분류**
>
> > - 선형구조 
> >
> > > * 배열
> > > * 연결 리스트
> > > * 스택(Stack)
> > >
> > > > * TOP 이라고 불리우는 한쪽끝에서 삽입과 삭제가 모두 이루어지는 순서리스트
> > >
> > > ```C
> > > //C
> > > 
> > > #include<stdio.h>
> > > #define MAX_STACK_SIZE 100
> > > 
> > > int stack[MAX_STACK_SIZE];
> > > int top=-1;
> > > 
> > > int IsEmpty(){
> > >     if(top<0)
> > >         return true;
> > >     else
> > >         return false;
> > >     }
> > > int IsFull(){
> > >     if(top>=MAX_STACK_SIZE-1)
> > >         return true;
> > >     else
> > >         return false;
> > > }
> > > 
> > > void push(int value){
> > >     if(IsFull()==true)
> > >         printf("스택이 가득 찼습니다.");
> > >     else
> > >         stack[++top]=value; 
> > > }
> > > 
> > > int pop(){
> > >     if(IsEmpty()==true)
> > >         printf("스택이 비었습니다.");
> > >     else 
> > >         return stack[top--];
> > > }
> > > 
> > > int main(){
> > > 
> > >     push(3);
> > >     push(5);
> > >     push(12);
> > >     printf("%d ",pop());
> > >     printf("%d ",pop());
> > >     printf("%d ",pop());
> > > 
> > >     return 0;
> > > }
> > > ```
> > >
> > > ```java
> > > // java
> > > interface Stack{
> > >     boolean isEmpty();
> > >     boolean isFull();
> > >     void push(char item);
> > >     char pop();
> > >     char peek();
> > >     void clear();
> > > }
> > > 
> > > public class ArrayStack implements Stack {
> > >     private int top;
> > >     private int stackSize;
> > >     private char stackArr[];
> > >     
> > >     // 스택을 생성하는 생성자
> > >     public ArrayStack(int stackSize) {
> > >         top = -1;    // 스택 포인터 초기화
> > >         this.stackSize = stackSize;    // 스택 사이즈 설정
> > >         stackArr = new char[this.stackSize];    // 스택 배열 생성
> > >     }
> > > 
> > >     // 스택이 가득찬 상태인지 확인
> > >     public boolean isFull() {
> > >         // 스택 포인터가 스택의 마지막 인덱스와 동일한 경우 true, 아닌 경우 			  false를 return
> > >         return (top == this.stackSize-1);    
> > >     }
> > >     
> > >     // 스택에 데이터를 추가
> > >     public void push(char item) {
> > >         if(isFull()) {
> > >             System.out.println("Stack is full!");
> > >         } 
> > >         else {
> > >             stackArr[++top] = item; //다음 스택 포인터가 가리키는 인덱스에 
> > >                                     //데이터 추가
> > >             System.out.println("Inserted Item : " + item);
> > >         }
> > >     }
> > >     
> > >     // 스택의 최상위(마지막) 데이터 추출 후 삭제
> > >     public char pop() {
> > >         if(isEmpty()) {
> > >             System.out.println("Deleting fail! Stack is empty!");
> > >             return 0
> > >         }
> > >         else {
> > >             System.out.println("Deleted Item : " + stackArr[top]);
> > >             return stackArr[top--];
> > >         }
> > >     }
> > >     
> > >     // 스택 초기화 
> > >     public void clear() {
> > >         if(isEmpty()) {
> > >             System.out.println("Stack is already empty!");
> > >         }
> > >         else {
> > >             top = -1;    // 스택 포인터 초기화
> > >             stackArr = new char[this.stackSize];    // 새로운 스택 배열 생성
> > >             System.out.println("Stack is clear!");
> > >         }
> > >     }
> > >     
> > >     // 스택에 저장된 모든 데이터를 출력
> > >     public void printStack() {
> > >         if(isEmpty()) {
> > >             System.out.println("Stack is empty!");
> > >         }
> > >         else {
> > >             System.out.print("Stack elements : ");
> > >             for(int i=0; i<=top; i++) {
> > >                 System.out.print(stackArr[i] + " ");
> > >             }
> > >             System.out.println();
> > >         }
> > >     }
> > > 
> > >     public static void main(String args[]) {
> > >         int stackSize = 5;
> > >         ArrayStack arrStack = new ArrayStack(stackSize);
> > >         
> > >         arrStack.push('A');
> > >         arrStack.printStack();
> > >         
> > >         arrStack.push('B');
> > >         arrStack.printStack();
> > > 
> > >         arrStack.push('C');
> > >         arrStack.printStack();
> > >         
> > >         arrStack.pop();
> > >         arrStack.printStack();
> > > 
> > >         arrStack.pop();
> > >         arrStack.printStack();
> > >         
> > >         arrStack.peek();
> > >         arrStack.printStack();
> > >         
> > >         arrStack.clear();
> > >         arrStack.printStack();
> > >         
> > >     }
> > > }
> > > 
> > > 
> > > 
> > > 
> > > ```
> > >
> > > 
> > >
> > > * 큐
> > > * 데크
> >
> > - 비선형구조 
> >
> > > * 트리 
> > > * 그래프 
>
> **7-5) 정렬**
>
> > - 버블정렬 
> > - 선택정렬
> > - 삽입정렬
> > - 셀정렬
> > - 병합정렬
> > - 퀵정렬
> > - 히프정렬
> > - 기수정렬

#### 8. 프로그래밍 언어론 

#### 부록 - IT 신기술 및 트렌드 용어 정리 