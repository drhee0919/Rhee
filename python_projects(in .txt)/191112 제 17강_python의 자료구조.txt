<11. 12 제 17강>

#<11.12. 제 17강>
#Python 학습 계획
#data type & data structure & 로직
#Numpy & Pandas를 이용한 EDA
#통계 개념, Python에서 처리, R에서 처리 
#통계적 데이터 분석(통계적 가설검정)
#Tensorflow를 이용한 machine learning
#지도학습, 비지도학습, 강화학습
#Deep Learning (CNN)
#R에서는 어떻게 하는지
#PythonFlask를 이용한 Web based ML Service 실습
#--------------------------------------------------------------------------------------------------------------
##Python의 자료구조 알아보기 

## Sequence Type (연속적인 데이터 타입) 

## 1) list 
## 임의의 객체를 순차적으로 저장하는 자료구조 
## 기호로는 [](대괄호) 

myLIist = list()  		#비어있는 리스트를 생성 
#또는 
myList = []		#list를 literal로 표현했다고 함 (자료구조를 코드상으로 표현)
myList = [1,2,3]		# 3개의 값을 가지는 list생성 
myList = [1,3,14,True,"아우성!!"] #모든 데이터 타입이 들어올 수 있다. 
myList = [10,[]] 		# 심지어 중첩 구조도 가능하다(리스트 안의 리스트) 
myList = [10, ["Show","me","the","money"], 3.14, True]
# List 안에 또 다른 자료구조들을 넣을 수 있다. 

#기본적으로 print문을 사용해서 함수 내 문구를 출력한다. 
print(myList[2])  		#3.14 출력 
print(myList[1][3])		#money 출력 
print(myList[-1]) 		#True 출력 
print(myList[0:1]) 		#Python은 exclusive한 언어(앞만 포함) 즉 10 만 출력 (slicing) 
		            # 통칭 'slicing' 한 결과는 원본자료구조와 동일 
print(myList[1][2:])		# ['the', 'money']
		 	# : 는 끝까지 자른다는 뜻 
			# slicing한 결과라서 리스트 형태로 나옴 
			

## -리스트의 연산 
a = [1,2,3]
b = [4,5,6] 
print(a+b)		#
print(a*3) 		#[1,2,3,1,2,3,1,2,3]


# list의 indexing & slicing 
a = [1,2,3] 
a[0] = 5			#5, 2, 3
a[0:1] = [7,8,9]		#결과 리스트를 해당 리스트로(등호 뒤) 대체하라 
			#7,8,9,2,3
a[0:2] = [7,8,9]		#7,8,9,3

a[1:] = [] 			#리스트의 특정 부분을 삭제하고 싶을때?
			#리스트 slicing 한 부분을 다른 부분으로 대체 
del a[1] 			#숫자 2제거 
			#변수 지우는 함수로 리스트 안의 원소를 삭제(많이 쓰진 않음) 
a[0] = [7,8,9]		#[[7,8,9],2,3]


## -list에 적용할 수 있는 함수 
## (1) append
# 리스트 의 맨 마지막칸을 생성, 그 안에 데이터를 저장 
a = [1,2,3]
a.append("Hello")
print(a)			#[1, 2, 3, 'Hello']

a.append([4,5,6]) 		#[1,2,3,[4,5,6]]

##(2) extend 
# 리스트를 확장 
a.extend([4,5,6]) 		# list를 확장 
print(a)			#[1,2,3,4,5,6]		
 
##(3) sort 
# list를 정렬(오름차순) 
a = [7,3,9,4,6,1,8]
result = a.sort() 		#※ 리턴 안됨 , 원본이 변경 
a.sort() 			#즉 위코드와 이건 같다 (리스트가 가지고 있는 함수)  
print(result)		#None (아무것도 안나온다)
print(a)			#[1,3,4,6,7,8,9]
result = sorted(a)		#특정 변수에 리턴시키려면  sorted를 이용한다(기본 파이선이 제공하는 함수) 
print(result) 		#원본이 변하지 않는다. [1,3,4,6,7,8,9]

a = ["Hello", "kaka" ,"World", "haha"]
a.sort() 			# 정렬의 기본(오름차순) 
print(a)			# 문자일 경우 ascii 코드 순서를 따름 

#내림차순 정렬을 먼저 하고 싶다면?
a = ["홍길동","최길동","아이유","김연아","신사임당"]
a.reverse() 		# 뒤에서부터 나열하는 함수 (역순정렬)
print(a)			# ["신사임당" ~ "홍길동"] 
a.reverse(reverse=True) 	# attribute 사용 (내림차순 정렬) 
print(a)			# ["홍길동" ~ "김연아"]

##(4) insert
# 해당 위치의 값을 바꾸는 것 외에도 특정 위치에 값을 낑겨 넣을 수 있음 
a =[1,2,3,4,5]
print(a.index(2))  #찾은 다음 찾은 위치를 return  #3
print(a.index(6)) #없는 거는 결측이 아니라 그냥 에러남 
a.insert(0, "Hello")
print(a) 	        #[1, 'Hello', 2, 3, 4, 5]

## (5) remove
#리스트 안에 첫번째로 발견한 해당 요소를 지운다 
a = [1,2,3,4,5,1,2,3,4,5]
a.remove(3)     	# 첫번째로 발견한 요소만 지움(첫번째 3만 지움) 
print(a)	        	# [1,2,4,5,1,2,3,4,5]

## (6) pop
# 지정한 위치의 요소를 뜯어올 수 있다. 
print(a.pop())	#5 , 맨마지막꺼 뜯어옴 
print(a.pop(2))	#3

## (7) count 
# 리스트 안에 원하는 요소의 개수를 세어준다. 
a = [1,2,3,4,5,1,2,1,3,4]	
print(a.count(1)) 	#3, 리스트 안에 1의 갯수를 출력

# (Sequence Type 이어서)
## 2) tuple 
# 리스트와 거의 동일, 표현하는 방식이 다름 
# list는 대괄호로 표현: []
# tuple은 소괄호로 표현 : () 
# 다른 언어에는 없는 Python만의 독자적인 자료구조 
a = () 		#empty tuple 
print(type(a))	# <class 'tuple'>
myList = [1]	#요소가 1개인 list 
print(type(myList))  # <class 'list'>
myTuple = (1) 	#요소가 1개인 tuple 
print(type(myTuple)) # <class 'int'>, 요소가 한개인 tuple은 이렇게 표현하면 안된다. 
myTuple = (1,)  
print(type(myTuple))  # <class 'tuple'>

# tuple과 list의 공통점과 차이점 
myTuple = (1,2,3)
print(myTuple[0:2])    # tuple 도 indexing&slicing  둘다 가능 
# myTuple[0] = 100 	   # 에러, 값을 바꿀수는 없다! (read only) 
		   # 리스트와 튜플의 가장 큰 차이점 
		   # 프로그램적으로 견고하게 (인자값이 변경되지 않도록) 만들때 자주 사용됨 
myTuple = 1,2,3 	   # 괄호를 생략 가능하다! 	#myTuple = (1,2,3)와 동치 

a,b,c = 10,20,30 	   #Python에서는 이런 표현이 가능하다 (a,b,c) = (10,20,30)    # 이것과 같은 결과이다
print(a) 		   # 10

#list와 tuple 
a = [1,2,3] #list 
b = tuple(a) #tuple 
print(b) 
c = list(b) #list 
print(c)

## 3) range
# 숫자 영역을 잡아주는  range는 일반적으로 for문과 같은 제어문을 사용할때 많이 사용 
# python 은 영역에 대한 타입이 따로 존재한다. 
range1 = range(10)
print(range1)

range2 = range(1,11,2)  #[1,3,5,7,9] 형태로 인식 
print(range2)


# 정리 
# Sequence type에는 결과적으로 3개가 존재 
# list, tuple, range 

##################################################################


## Mapping type 
## 1) dict(dictionary)
# key와 value의 쌍으로 표현되는 자료구조 
# 비슷하게 JSON을 예로 들 수 있다. ({name : "홍길동", age : 30})
a = {"name" : "홍길동", "age" : 30}
print(type(a))
# key값은 불변의 값을 사용해야 한다 
# list 는 key로 사용을 할 수 가 없다 
# tuple은 read only이기 때문에 key로 사용할 수 있다. 
a[10] = "hohoho"  # dictionary는 순번이라는 값이 없다 
                  # 그냥 키로 들어가게 됨 
print(a)          # {'name': '홍길동', 'age': 30, 10: 'hohoho'}

a["hobby"] = "game"
print(a)          # {'name': '홍길동', 'age': 30, 10: 'hohoho', 'hobby': 'game'}

#리터럴로 표현한다면? 
print(a["age"])   # 30

a = {"name" : "홍길동", "age" : 30, "age" : 40 }      #key가 두개인 것은 사용 금지(에러는 안뜸)
print(a)          #{'name': '홍길동', 'age': 40}      #목욕탕에 같은 번호의 키가 두개가 있는 것 


a = {"name" : "홍길동", ("address",) : "서울"}
print(a)
print(a[("address",)])     #서울

## - dict의 함수 
## (1) keys
# value를 가져오고 싶다면? : key를 알아야 한다. 
# a.keys() → dict_keys 자료구조로 리턴 
#             list와 유사한 자료구조 
a = {"name" : "홍길동", "age" : 20, "address" : "서울" }

myKey = a.keys()
print(myKey)  #dict_keys(['name', 'age', 'address'])
myList = list(myKey)
print(myList) #응용하여 key값만 리스트로 추릴 수 있다. 


## (2) values
# a.values() → dict_values 자료구조로 리턴 
myValue = a.values()   #dict_values 형태로 가져온다. 
print(myValue)         #dict_values(['홍길동', 20, '서울'])

##(3) items
#a.items() →  key와 value를 쌍으로 리스트 형태로 뽑을 수 있다. 
myItem = a.items()
print(myItem)          #dict_items([('name', '홍길동'), ('age', 20), ('address', '서울')])

# ex/ dict안에 있는 모든 key와 value를 출력하세요 
# for 문을 이용해서 
a = {"name" : "홍길동", "age" : 20, "address" : "서울"}

for k in a.keys():
    print("{} - {}".format(k, a[k])) # 중괄호가 없는 대신에 indent로 표시, 잘못띄우면 안됌 
                                     # indent가 없이 그냥 쓰면 for문에 포함안됨 
        
print("age" in a)                    #특정 key값이 dict에 있는지 확인 

##################################################################


## Python 의 제어문 
## 예제 위주로 익혀보자
## 제어문은 헷갈리지 않게 형식 구조가 코딩 언어별로 크게 다르지 않음 
## 1) if 문 (if, elif, else)
area = ["Seoul","Busan","Jeju"]

if "Suwon" in area:  #조건이 끝나면 : 을 붙여주도록 하자 
    pass #하는 일이 아무것도 없을때 사용 
elif "Seoul" in area:  #elseif, ~가 아니고 -이면 
    print("서울이 있어요!")
else:
    print("기타등등 ")
    
## 2) for문 
for k in range(10):
    print("k값은 : {}".format(k))
    
## 3) while문 
test =1
while test<10:
    print("test값은 {}".format(test))
    test += 1   #test = test 1





################################### 즐거운 연습문제 #################################
### 문제 1 
## 10보다 작은 자연수 주에서 3또는 5의 배수는 3,5,6,9가 존재한다. 이것들의 합은 23입니다. 
## 1000보다 작은 자연수 중에서 3또는 5의 배수들을 구해서 모두 합하면 얼마일까여요? 

k = 1 
sum = 0 
while k < 1000:
    if k % 3 == 0:
        sum = sum + k
        k = k+1
    elif k % 5 == 0:
        sum = sum + k
        k = k+1
    else:
        k = k+1
print("총 합은 {}".format(sum))



###문제 2
## 피보나치 수열의 각 항은 바로 앞의 항 두개를 더한 수열이다. 
## 1과 2로 시작하는 피보나치 수열은 
## 1, 2, 3, 5, 8, 13, 21, 34, ....
## 값이 짝수이면서 4백만 이하인 모든 항을 더하면 얼마일까요? 

Fibo = [1,2]
Sum = 0
while Fibo[-1] <= 4000000:                 #Fibo[-1] : 수열의 맨 마지막 수 
    Fibo.append(Fibo[-1] + Fibo[-2])
    if Fibo[-1] % 2 == 0:
        Sum = Sum + Fibo[-1]
print("짝수열의 총 합은 {}" .format(Sum))   #짝수열의 총 합은 4613730


###문제 3
## 알파벳 대소문자로 되어 있는 문자열이 주어진다. 
## 이 문자열에서 가장 많이 사용된 알파벳이 무었인지 출력하는 프로그램을 작성
## 단, 대소문자 구별하지 않는다, 만약 동률이 존재하면 알파벳 순서가 제일 앞서는 알파벳을 출력 
## "This is a sample Program mississippi river"


##싹다 대문자나 소문자로 변환시킨뒤 
## 그,냥 샌다! 

import string

def find_max_letter_count(word):
    
    alphabet = string.ascii_lowercase
    dictionary = {}
 
    
    for letters in alphabet:
        dictionary[letters] = 0

    for letters in word:
        dictionary[letters] += 1 #마지막에 z가 오므로 뒤집어야 함 

    dictionary = sorted(dictionary.items(), 
                        reverse=True,
                        key=lambda x: x[1]) # 역순 지정 
                  
                      
    #마지막 for문 (출력)
    for position in range(0, 26):
        print(dictionary[position])
        if position != len(dictionary) - 1:
            if dictionary[position + 1][1] < dictionary[position][1]:
                break #다음게 전꺼보다 크면 멈춤 

find_max_letter_count("asdfasaASDFASD")



