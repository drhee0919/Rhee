<11.14(목) 제 19강> - python 제 3강, 4강(함수 와 클래스) 

# python내 내장함수 기능들을 복수하고 사용자 지정 함수 설정하는 법을 알아본다. 
# 절차적 프로그래밍(procedural programming)과 객체지향 프로그래밍을 이해한다(Object-Oriented programming)
# python에서 class를 정의 및 선언하고 기본적인 구조를 파악한다. 

###########################################################################################
(스크립트명 : 03_Function(19강)) 

## 1. funciton(함수)
# 일반적으로 logic을 이용해 푼다고 하면 다음과 같은 제어문을 이용한다.
# ex/ list내 원소의 합을 구하고 싶을 때
a = [1,2,3,4]
mySum = 0 
for i in a:
    mySum += i
print(mySum)

#다른 방법으로는 Python의 내장함수를 이용한다.
mySum = sum(a)
print(mySum)

# 함수를 이용하면 코드를 간소화 시킬 수 있다는 장점이 있다. 
# => 가독성이 증가하고, '코드의 재활용성'을 높일 수 있다. 
# (생 코드를 copy&paste하며 유지보수 한다고 생각해보자(어려움))
# 프로그래밍은 일련의 기능들을 함수화 시켜 함수단위로 프로그래밍을 하게 된다. 
# => '절차적 프로그래밍'이라 지칭 
# '절차적 프로그래밍(procedural programming)'이란
#다음 함수를 수행해보자 
#ex/ 숫자를 입력받아서 해당숫자를 모두 더한 후 '결과값은 : xx입니다.' 형식으로 출력 
#  => 문제를 단위기능(더 나눌수 없는 기능) 들로 간주 => 함수化 (숫자를 입력받은 기능, 숫자를 더하는 기능)
# 문제 해결에 있어 분석하려고 하는 사람의 사고와 유사한 형태의 프로그래밍 

# -함수의 정의 
# python에서 함수는 크게 두가지로 구분 가능 : 1) 내장함수 2)사용자 정의 함수(user define 함수)
# 사용자 정의 함수를 만드는 keyword는 'def' (definition, 함수의 정의 )
# * 함수 이름은 소문자로 시작 : 관용적으로(국룰임)
def mySum(a,b,c):     #해당 함수는 a,b,c를 통해 입력을 3개 받겠다 
    total = a + b +c  #믿에 나오는 코드는 해당 함수에 걸리도록 indent 처리 
    return total 
# 함수의 정의(definition)란 함수의 이름, 인자형태, 인자개수 + 기능 구현 까지 처리한 것을 정의(완벽히 끝냄)
# 함수의 선언(declaration)이란 함수의 이름, 인자형태, 인자개수를 까지 지정 (이런 함수가 있어)
# ex1/ 입력받은 숫자를 더하는 함수를 만들자
inputValue = input() # 입력받는 내장함수, 무조건 str로 받아요 
                     # 숫자 3개를 받아보아요 ("100 200 300")
print("입력받은 값은 : {} ".format(inputValue))
var1 = inputValue.split(" ") #공백을 기준으로 분류하겠다.
                             # var1은 list 가 된다. (split : 값을 분리해서 리스트로 리턴)
result = mySum(int(var1[0]),int(var1[1]),int(var1[2]))
print("최종결과는{}".format(result)) #100 200 300
                                     #입력받은 값은 : 100 200 300 
                                     #최종결과는600


# ex2/ 전달받은 모든 값들을 더해서 리턴 (3개만이 아님, 몇개를 받든)
def mySum2(*args):     # args가 tuple로 간주  #args => (10,20,30,40)
    k=0
    for i in range(len(args)):
        k += args[i]
    return k 
                        # 전달받은 모든 값들을 더해서 리턴 
total = mySum2(10,20,30,40)
print("최종결과:{}".format(total)) #최종결과:100
total = mySum2(30,40,60,90)
print("최종결과:{}".format(total)) #최종결과:220


## ex3/ 함수를 하나 정의한다. 
## 숫자 2개를 받아서 두개의 합과 두개의 곱을 리턴 
##※tuple 
#a=(10,20,30)
#b=10,20,30
#a와 b는 동치(값이 똑같다)
#오직 tuple만이 괄호 생략이 가능하다 
#tuple을 이용하여 마치 여러개의 값이 리턴되는 것처럼 보이게 할 수 있다. 
def multi_process(x,y):
    result1 = x+y
    result2 = x*y
    return result1, result2   #괄호를 안씌워도 상관없다! (왜, 튜플이니깐)
                               #튜플로 만들어 리턴하기 때문에 (파이썬 특유의 언어적 표현때문에)
                               #값 두개를 리턴하는 것으로 보이지만, 모든 함수는 하나이 값을 리턴한다. 
a,b = multi_process(100,200)
a,b = (300, 20000)
print(a)



## - 사용자 정의 함수를 만들어요 
# default parameter 

def mySum(a,b,c=100): # 맨끝의 c가 만약 값이 안들어오면, 100을 받겠다. 
                      # c처럼 마지막 매개변수에 default값을 지정할 수 있다.(a,b는 안됨)  
    return a+b+c

total = mySum(1,2,3); print(total) #6
total = mySum(1,2);   print(total) #103


tmp = 100    #지역변수(global variable)

def myFunc(x): # 함수안에서 선언된 변수는 local variable, 함수 안에서만 유효 
    
    tmp = 10
    tmp += x  #tmp에 x로 들어온 걸 누적 
    
    return tmp 

print(myFunc(20)) # 과연 뭐가 나올까?   답:30
print(tmp)        # 100 (전역변수와 지역변수의 차이)
                  # 만일 함수 외부에 동일명의 변수가 있다하더라도, 지역변수의 영역은 해당 함수 내에 국한 
                  # local variable 은 함수가 호출될때 생성되고 
                  # 함수 수행이 끝나면 사라진다.(생명주기도 다름)
                  # 만약 지역변수를 전역변수로 바꿔주고 싶다면? 
                  # →  global tmp  (이런식으로 선언, 단 선언과 대입 동시 못함 (global tmp=10이런거))
                  # →  프로그램적으로 너무 뺑뻉 돌아가서 해결이 어려울때 사용, 가급적 지양
            
            
#나머지는 내장함수.. Python이 제공해주는 함수 

## - 내장함수 복습하기(자주쓰는 내장함수)
#  int() : 인자로 들어온 놈을 정수로 변환 
#  abs() : 절대값을 리턴해준다. 
#  all() : 인자로 반복가능한 타입이 와야한다. 인자로 들어온 값이 모두 True일 경우 True 리턴 
a = [True, 100, {}, 3.14]
print(all(a)) #false 
#  len() : 길이구하는 내장함수 
#  list() : 리스트 만들어주는 함수 
#  tuple() : tuple로 변환하는 함수 
#  str() : 문자열로 변환하는 함수 
#  type() : 인자로 들어온 데이터의 type을 return 
#  max(), min() : 최대 최소를 구해줘요 
a = [1,2,3,4,5]
# * print(mean(a)) # 안됨, mean은 내장함수로 존재하지 않음   
print(sum(a)/len(a))
# sorted() : 오름차순으로 정렬해주는 함수 
# join() : 하나의 문자열을 다른 문자열과 결합할때 사용 
a = ["이것은","소리없는","아우성"]
print(" ".join(a))

###############################(연습문제 이어서)###

### 문제 6.
## 앞에서 부터 읽을때나 뒤에서부터 읽을 때 모양이 같은 수를 대칭수라고 지칭한다. 
## 두 자리 수를 곱해서 만들 수 있는 대칭수 중에 가장 큰 수는 9009(91*99) 입니다. 
## 세 자리 수를 곱해서 가장 만들 수 있는 가장 큰 대칭수는 얼마? (답 : 906609)
## 세 자리 수를 곱해서 만들었다면, 네 자리 수로 최대 대칭수를 구하여라? (답 : 99000099)

# 풀이 알고리즘 
# 100*100 = ? 대칭수인지 확인 =>(어딘가에)저장
# 100*101 = ? 대칭수인지 확인 =>(어딘가에)저장
# 100*102 = ? 대칭수인지 확인 =>(어딘가에)저장
# ... 

# 1) 대칭수 판별을 위한 함수를 하나 만든다
def symmetric_Number(x):
    x = str(x)
    if x == x[::-1]:   #문자열 슬라이스 기능 활용, 뒤집어도 같은지 판별
        return True 
    else:
        return False 

maxValue = 0            #함수를 생성했으면 최대값을 넣어줄 변수 생성 

# 2)백의 자리(혹은 천의자리) 숫자부터 일일이 비교하는 루프문 생성 
for i in range(9000,10000):
    for j in range(9000,10000):
        cal =  i*j
        if symmetric_Number(cal):
            if maxValue < cal:
                maxValue = cal

print("최대 대칭수는 %d 입니다" %(maxValue))
    
##(문제6 이어서)
## 강사님 답안지 
def check_number(x): 
    str1 = str(x)
    tmp = list(str(x))
    tmp.reverse()
    if str1 == "".join(tmp): #join함수는 무조건 str형태로 붙게된다. 
        return True
    else:
        return False   #대칭수 판독 함수 끝 

def calcul_number(x):
    
    result = []
    for i in range(10**x,10**(x+1)):
        for j in range(10**x,10**(x+1)):
            if check_number(i*j):
                result.append(i*j) #앞서 선언한 리스트 result에 결과 할당 
            
    print(max(result))             # 결과중 가장 큰거 출력 

calcul_number(2)            #10^(n) : parameter로  n의 승수 결정 


##############################################
### 문제 7. 
##
## 1부터 10사이의 어떤 수로도 나누어떨어지는 가장 작은 수는 2520입니다. 
## 1부터 20사이의 어떤 수로도 나누어떨어지는 가장 작은 수는 얼마일까요?
## 가급적 함수로서 기능단위로 뽑아 풀어보자. 

#1~20의 최소공배수를 구하는 문제  

%%time
## 다른 풀이(진수형꺼)
## 1) 두 수간의 최대 공약수를 구하는 함수를 만들어 
## 2) 1)의 함수로 최소공배수를 구하는 함수를 만든뒤 
## 3) 2)의 함수로 1~20 사이의 숫자를 둘씩 나누어 비교하는 
##[1 2 3 4 5 6 7 8 ```` 18 19 20]
## |/ //  
##  |//
##  |/     이런식으로 .. 
# 나눳을때 나머지가 0 최소공배수?
def divide(a,b):   #1) 두 수 간의 최대 공약수를 구하는 함수
    if a>b :
        great = a
        small = b
    else:
        great = b
        small = a
    num=0
    for i in range (small,0,-1):
        if (a%i)==0 and (b%i)==0:
                num = i
                break
    #print(num)
    return num


def multi(a,b):
    return int((a*b)/divide(a,b))  #2) 두 수 간의 최소공배수를 구하는 함수 {(a*b) / (a와 b의 최대공약수) == 최소공배수}  

def expr(x):   #3) 1~20 부터 20까지 최소공배수를 비교해가는 함수 
    a=1
    b=2
    while b<x+1:
        a=multi(a,b)
        b=b+1
       
   
    return a

expr(20)

-----------------------------------------------------------------------------------------------------------------------------------
(스크립트명: 04_OOP(Object Oriented Programming, 객체지향프로그래밍(19강)))

## 1. 객체 지향 프로그래밍(Object Oriented Programming)이란 ?

#함수 기반의 프로그래밍(절차적 프로그래밍)의 장점이 무엇일까?
#: 사람의 사고와 잘 맞는다. (분석적 사고) →  상대적으로 프로그래밍 하기 쉽다. 
#  (빨리 만들 수 있고 적은 사람으로 만들 수 있다.(비용절감))
#1970년부터 시작해서 지금까지 이 방식으로 프로그래밍을 하고 있다. 
# 정보량이 많아지기 시작하면서 세상이 급변하기 시작 
# => 프로그램의 유지보수 요구가 많아지기 시작 (개발비용 능가, 배보다 배꼽이 커짐)
# (고찰결과) 절차적 프로그램으로 프로그램을 작성해서 이런 문제가 발생했음을 발견 
# (만들때는 쉽게 만들지 몰라도 변화하기가 어려운 프로그래밍 기법)
# 어떤 방식으로 프로그램을 만들면 유지보수측면에서 이점이 있을까? => 객체지향방식 등장 
# 객체지향 패러다임의 시작 : 프로그램, 데이터베이스 전부다 객체지향화

# 객체지향이 어떤 프로그래밍 방식인지를 인지
# :현실세계에 잘 부합하는 (변화에 잘 적응하는) 프로그램을 만들기 위해 해결해야 하는 문제를(현실세계의 문제)
# 프로그램으로 똑같이 모델링하면 되는것이 아닌가? 
# 예) '은행' 프로그램을 만들고자 한다. 은행프로그램을 구성하는 구성요소를 파악 
# : 텔러, 고객, 은행계좌, 지점, 테이블, .... (무궁무진하게 나옴, 심지어 분석하는 사람마다 다름)
# 한편 기능은? => 누가 분석하는가가 거의 차이가 없음(은행이 뭐 돈빌려주고 돈버는데지.. )
# 기능으로 자르는게 아니라, 구성요소간에 상호 일어나는 행위들을 정의하는 프로그래밍 방식이 바로 OOP
# 객체들은 크게 2가지로 파악할 수 있다. : 상태(값으로 표현) & 행위(동작으로 표현) 
# 예) 은행계좌의 '값' : 잔액, 예금주, 계좌번호, ... (무궁무진, 쓸데있는 것만 남김)
#     은행계좌의 '행위' : 출금, 입금, 조회(자신이 갖고있는 상태값으로 동작하는 것이 행위)
# 이와같이 세상의 삼라만상을 이 2가지로 표현하기로 함 
#  => 추상화(abstraction) : 아주 관념적인 대상을 상태와 행위로 간단하게 define 하는 것 



## 2. 클래스(class) : properties, method, constructor 로 구성 
# 프로그래밍에서 이러한 객체를 모델링하는 단위로서 class를 사용한다.(객체 모델링의 수단)  
# 클래스의 이름은 대문자로 시작하는 것이 관용적(국룰, 함수명과 구분목적!!(함수명은 소문자로 시작))

# ex/ 학생 클래스를 생성해보자! 
class Student : #학생에 대한 내용을 묘사하겠다. 
    #상태(값) : 변수로 표현 (이름, 학과, 학년, 학번, 성별, 나이, 키, 몸무게.....)
            # => 학생으로서 필수적인 것이 있고 굳이 학생으로서 필요 없는 것이 있다. 
            #    그 여부를 판단하는 것은 프로그래머마다 다름(방향성이 다양해짐)
            #    설계를 잘못하게 되면 프로그램이 산으로 간다.(코딩이 어려움)
            # 이 변수를 부르는 명칭(용어)은 프로그래밍 언어 마다 다름 
            #  => Python : properties 라 지칭 
    s_nation = "" #class variable, 모든 사람이 공유하는 내용으로서 선언 
            
                    
    def __init__(self,n): #생성자(consturctor) : 뒷 설명 참조! 
        self.s_name = n # 학생 이름을 나타내는 property,instance variable(객체가 독립적으로 갖는 변수)
        self.s_num =""   # 학번을 나타내는 property, instance variable 
        self.s_major = [] #복수전공일 수 도 있다. 
    
    
    
    #행위(동작) : 함수로 표현 (def) => 객체지향에서는 기능, 메소드(method)로 지칭
    def display(self): # '학생 정보' 를 출력하는 내용을 출력하는 기능 
        print("학생이름은: {}".format(self.s_name))
     
    
     # ※ 생성자(constructor) properties, method 와 함께 클래스의 또다른 구성요소 
    # 클래스가 묘사를 하면, 생성자는 클래스에 묘사된 정보를 기반으로 메모리 공간을 잡는다. 
    # 즉 클래스는, 객체 모델링 수단이자, '데이터 타입' => 우리가 만든 데이터 타입, "추상 데이터 타입" 
    # https://andamiro25.tistory.com/38 참고 
t = Student("홍길동")  #객체 
                       # => 이 코드에 의해서 만들어진 메모리 저장공간(instance) => 즉, 객체                       
                       # => class내부에 정의된 생성자라고 불리는 함수가 호출된다. (상단 def__init__ 참조)    
t.display()
print(t.s_name)        #t가 가지는 s_name #홍길동
Student.s_nation = "한국"
print(t.s_nation)
      
k = Student("김연아")
k.display()
print(k.s_name)
print(k.s_nation)


## 전공을 추가해보자(리스트 자료구조 추가)

class Student : 
    s_nation = "" 
                    
    def __init__(self,n): #생성자 
        self.s_name = n #instance variable
        self.s_num =""  #instance variable 
        self.s_major = [] #복수전공일 수 도 있다. 리스트를 선언 
    
    
    
    def display(self): # '학생 정보' 를 출력하는 내용을 출력하는 기능 
        print("학생이름은: {}".format(self.s_name))

students = list()   #3칸짜리 list 선언 
students.append(Student("홍길동"))  #객체

students[0].display()
      
k = Student("김연아")
k.display()

print(k.s_name)
print(k.s_nation)

####결과####
학생이름은: 홍길동
학생이름은: 김연아
김연아