## 2. Pandas 
##pandas는 데이터 조작 및 분석을 위해 Python 프로그래밍 언어로 작성된 소프트웨어 라이브러리입니다. 
##특히, 숫자 테이블 및 시계열 조작을위한 데이터 구조 및 조작을 제공

## pandas 설치 
## 가상 환경에서(activate cpu_env) -> conda install pandas 입력 
import numpy as np 
import pandas as pd


## -Seires
## Series를 생성해 보아요 
## NumPy array(ndarray)와 비교해서 확인 

# 먼저 ndarray부터 다시한번 알아보아요!
arr = np.array([-1,5,8,10], dtype=np.float64)
print(arr.dtype) #float64
#만약 이렇다면?
arr = np.array([-1,5,3.14,"Hello"]) #integer, float, string이 혼재 
print(arr) #['-1' '5' '3.14' 'Hello']
print(arr.dtype) #<U32 유니코드 : 문자열로 인식 

## 오브젝트 타입 
arr = np.array([-1,5,3.14,"Hello"], dtype=np.object) #타입을 '객체형'으로 잡음
print(arr) #[-1 5 3.14 'Hello']
print(arr.dtype) #object
print(arr[2]) #3.14
print(type(arr[2])) #<class 'float'>



## Series는 panda에서 제공해주는 함수 (nbarray ~ NumPy)
arr = np.array([-1,5,3.14,"Hello"], dtype=np.object) #array선언
s = pd.Series([-1,5,3.14,"Hello"], dtype="object")   #Series선언 
print(s)
print("="*70) #출력문 줄긋기(간지)
#1) Series의 value 부분 출력 
print("Series의 value 부분 : {}".format(s.values)) #Series의 value 부분 : [-1 5 3.14 'Hello']
print("Series의 value부분의 type : {}".format(type(s.values))) #Series의 value부분의 type : <class 'numpy.ndarray'>

#2) Series의 data type(dtype) 
print("Series의 value부분 dtype : {}".format(s.values.dtype)) #Series의 value부분 dtype : object
#또는 
print("Series의 value부분 dtype : {}".format(s.dtype)) #Series의 value부분 dtype : object

#3) Series의 index부분출력  
print("Series의 index부분 : {}" .format(s.index)) #Series의 index부분 : RangeIndex(start=0, stop=4, step=1)
print("Series의 index부분 : {}" .format(type(s.index))) #Series의 index부분 : <class 'pandas.core.indexes.range.RangeIndex'>
#※rangeindex: pandas에서 새로이 정의한 datatype(class) 




## Series는 index를 따로 지정할 수 있어요 
s = pd.Series([-1,5,8,10],
              dtype = np.int32,
              index = ["a","c","k","f"])
print(s)
#a    -1
#c     5
#k     8
#f    10
#dtype: int32

## index를새롭게 지정하면 숫자인덱스는사용할 수 없는가? - No, 숫자인덱스는 기본으로 사용 가능 
print(s[1]) #5 
print(s["k"]) #8  #새로 지정한 index로 값을 access할 수 있음 

## 만약 지정 인덱스가 겹친다면? - 사용가능하다(중복된만큼 출력). 어차피 근본은 숫자인덱스이므로 상관없다 
s = pd.Series([-1,5,8,10],
              dtype = np.int32,
              index = ["k","c","k","f"]) 
print(s["k"]) #만약 찾으려는 결과가 2개 이상이면 Series로 return 
#k   -1
#k    8
#dtype: int32



## Series의 slicing 활용
## ndarray : indexing 및 slicing사용 가능 
## Series 에서도 slicing을 이용할 수 있다.
s = pd.Series([-1,5,8,10],
              dtype = np.int32,
              index = ["a","c","k","f"])
print(s[0:2])      #Series가 return
#a   -1
#c    5
#dtype: int32
print(s["a":"k"]) #새로운 index를 이용해서slicing을 할때 범위에 조심해야 한다. (마지막거 포함, inclusive)
#a   -1
#c    5
#k    8
#dtype: int32

#boolean indexing을 이용해보자! 
print(s[s%2==0]) #해당 mask를 조건으로서 인덱스에 명시 
#k     8         #조건에 맞는 것만남게 된다. 
#f    10
#dtype: int32                 
    
#Fancy indexing도 이용해보자
print(s[[0,2]]) #인덱스에 배열이 들어간다. 
#a   -1
#k    8
#dtype: int32

#Series내부의 합계를 다 구하려면? - 집계함수가 존재한다.(s.sum())
#ndarray에서 제공했던 집계함수를 그대로 다 이용가능 
print(s.sum()) #22




## ※ 제어문에 대해서 (python의 편리한 기능)
##for 문을 list를 만들대 사용할 수 있다. 
myList = [1,2,3,4]
## 이 리스트를 이용해서 각 요소에 *2를 한 리스트를 만들고자 한다.  
## → [2,4,6,8]
##그러나 리스트는 vector의 성질이 아니다(*2면 두개를 붙여버림)
result = myList *2 
print(result) #[1, 2, 3, 4, 1, 2, 3, 4]
#for문을 사용하여 원하는 결과를 얻을 수 있다. 
result = list()
for i in myList:
    result.append(i*2)
print(result) #[2, 4, 6, 8]

#한편, 파이썬에서는 다음과 같은 편리한 기능이 있다. 
result = [x*2 for x in myList]
print(result) #[2, 4, 6, 8]

#추가 조건도 내걸 수 있다. 
result = [x*2 for x in myList if x>2]
print(result) #[6, 8]


##dict형식에도 사용할 수 있나?
result = {"stu"+ str(x) : x**2 for x in range(0,10)} # :를 경계로 key와 value를 나눔 
                                                     # x값으로 key와 value를 형성하라 
print(result)
# {'stu0': 0, 'stu1': 1, 'stu2': 4, 'stu3': 9, 'stu4': 16, 'stu5': 25, 'stu6': 36, 'stu7': 49, 'stu8': 64, 'stu9': 81}





## ※ 추가 데이터 타입 : 날짜
## 많이 사용되는 데이터 타입 중 날짜가 있다. 
## 날짜는 계산하기 힘든 데이터타입: 문자열로 계산표현하려면 30일,31일,윤년 등 고려할 사항이 너무많다 
## Date class를 이용하면 아주 쉽게 계산할 수 있다. 
from datetime import date, datetime  #base package
today = date.today() #연월일 까지만 출력
today = datetime.today() #시분초까지 출력 
print(today) #2019-11-20 #강의시점의 날짜 출력 
#타입을 확인해보자 
print(type(today)) #<class 'datetime.date'> #pythone에는 별의별 datat type, class들이 존재한다.
print("연도 : {}".format(today.year)) #연도 : 2019   #연도만 뜯어올 수 있다. 
print("월 : {}".format(today.month)) #월 : 11  #다른 것도 마찬가지다 
print("일 : {}".format(today.day)) #일 : 20 
print("시 : {}".format(today.hour)) # 이하생략 
print("분 : {}".format(today.minute))
print("초 : {}".format(today.second))
print("마이크로초 : {}".format(today.microsecond))





from datetime import date, datetime, timedelta
from dateutil.relativedelta import relativedelta 

##days => 날짜검색 아주쉽게 
today= datetime.today()
print(today) #2019-11-20 11:05:52.702095
day= timedelta(days=1)
result = today + day
print(result) #2019-11-20 11:05:52.702095 #내일을 쉽게 검색할 수 있다. 

## months, weeks, hours, minutes, seconds 도 존재한다. 
day = relativedelta(months=-1)
result = today + day 
print(result) #2019-10-20 11:11:53.333503





from datetime import date, datetime, timedelta
from dateutil.relativedelta import relativedelta 
from dateutil.parser import parse
## 예제 : 윤달에서 날짜찾기! 
## 오늘날짜가 3월 31일 => 1달전?? 2월28일, 2월 29일?
today = parse("2019-03-31")
print("오늘의 날짜 : {}".format(today)) #오늘의 날짜 : 2019-03-31 00:00:00
day = relativedelta(months=-1)
print(today+day) #2019-02-28 00:00:00
# *3월 30일로 해도 2월 28일이출력되는 이유는 ? : 당연히 2월 30일이 없기때문 






## 예제1
## A공장의 2019-01-01부터 10일간 제품생산량을 Series로 저장 
## 생산량은 랜덤으로 결정, 평균이 50이고 표준편차가 5인 정규분포에서 random 하게 추출(정수로 사용)
## 형식 2019-01-01 53(index를 날짜로 잡아요)
##      2019-01-02 58
## B공장의 2019-01-01부터 10일간 제품생산량을 Series로 저장
## 생산량은 랜덤으로 결정, 평균이 70이고 표준편차가 8인 정규분표에서 random 하게 추출(정수로 사용)

#1) 생산량부터 설정 
from datetime import date, datetime, timedelta
from dateutil.relativedelta import relativedelta 
from dateutil.parser import parse
import numpy as np
np.random.seed(100)    
A_product =  np.round(np.random.normal(50, 5, size=11)) #정수 어캐하지 np.round 를 쓰렴~   
B_product =  np.round(np.random.normal(70, 8, size=11))
print(A_product)
print(B_product)

#2) 날짜 추가하기 
today = parse("2019-01-01")
print("시작하는 날짜 : {}".format(today))
print("  ","날짜","             ""A사","","B사")
print("-"*30)
for n in range(11):
    day = relativedelta(day=n)
    print(today+day, A_product[n],B_product[n])
print("="*80)
print("생산량 합계는 A사가 %d, B사가 %d" %(A_product.sum(),B_product.sum()))






## 예제1 (강사님 답안지) + 추가사항(날짜를 서로 다르게)
from datetime import date, datetime, timedelta
from dateutil.parser import parse
#A공장
#start_day = parse("2019-01-01")
#추가로 서로 생산 시작날짜를 바꿔서 출력해보자 
sday1 = datetime(2019,1,1)
print(start_day)
factoryA = pd.Series([int(x) for x in np.random.normal(50,5,(10,))], 
                      index = [sday1 + timedelta(days=i) for i in range(10)])
sday2 = datetime(2019,1,5)
factoryB = pd.Series([int(y) for y in np.random.normal(70,8,(10,))],
                      index = [sday2 + timedelta(days=i) for i in range(10)])
print(factoryA,factoryB)
print(factoryA + factoryB) #날짜 차이로 인한 결측 확인하기 
print(factoryA[0:4],factoryA[4:9] + factoryB[0:5],factoryB[5:9]) # 그냥 붙이기?

##factoryA와 factoryB의 index만 다와서 결합해보기 : set() 함수이용
##03_data Structure(18강) 참조 
index_a = set(factoryA.index)
index_b = set(factoryB.index)

index_a_b = index_a - index_b #factoryB에 추가 
index_b_a = index_b - index_a #factoryA에 추가 

for i in index_a_b:
    factoryB[i] =0 
for i in index_b_a:
    factoryA[i] =0

print(factoryA + factoryB)
#2019-01-01     54
#2019-01-02     56
#2019-01-03     48
#2019-01-04     48
#2019-01-05    122
#2019-01-06    119
#2019-01-07    116
#2019-01-08    115
#2019-01-09    125
#2019-01-10    115
#2019-01-11     72
#2019-01-12     64
#2019-01-13     69
#2019-01-14     77
#dtype: int64





## Series를 생성할 때 list를 이용해서 만들었어요 
## dict(Dictionar)를 이용해서 Series를 생성할 수 있어요! 
import numpy as np
import pandas as pd 

my_dict = {"서울" : 1000, "부산" : 3000, "제주" : 5000}

## dictionary데이터를 기반으로 Series생성해보기 
s = pd.Series(my_dict)
print(s)
#서울    1000
#부산    3000
#제주    5000
#dtype: int64

s.name = "지역별 가격 데이터" #Series 자체에 논리적인 이름 설정 가능 
s.index.name ="지역명" #인덱스에도 붙여줄 수 있다.
print(s)
#지역명
#서울    1000
#부산    3000
#제주    5000
#Name: 지역별 가격 데이터, dtype: int64




####################################연습문제 이어서#####################3
### 문제 13
##다음과 같은 특성을 가지는 숫자의 개수를구하는 프로그램을 작성해 보아요 
## 두개의 숫자(x,y)를 이용합니다(양의 정수) 1과 1000 
## x초과 그리고 y미만인 숫자 중 각 자리의 숫자를 모두 더한 값이 5의 배수가 되는 숫자를 구하고 
## 해당 숫자가 몇 개인지 출력하세요 
## 1)숫자를 받고 각 자리수를 더해주는 함수 산출
## 2)1~1000까지의 뺑뻉이 돌려서 5의 배수 여부 산출 

#1)숫자를 받고 각 자리수를 더해주는 함수 
def figure_Sum(n):
    total = 0
    while not n== 0:
        total += int(n%10)
        n = n/10
    return total
print(figure_Sum())

#2) 뺑뺑이 start
c=0 #숫자를 세자

for i in range(100, 10000):
    if figure_Sum(i) % 5 ==0: 
        c +=1 
     
print("100부터 10000까지 자리수 합이 5의 배수인 숫자는: %d개 "  %(c))


###문제 13(다른방법 : 문자열로 받아보자)
def exercise13(x,y):
    nCount = 0 #조건에 맞는 수를 발견할 때마다 1씩 증가, 출력 대상 
    
    for i in range(x+1,y):
        #i값에는 숫자가 한개씩 들어와요! 
        k = str(i)  #숫자열을 문자로 변환한 것을 받아올 k 선언 ( i=>414, k="414")
        intSum = 0 
        for j in range(len(k)): #반복으로 하나씩 뜯어오자(k가 나타내는 자릿수만큼) 
            intSum += int(k[j]) #뜯어온거 다 더해라 
        if intSum % 5 ==0:
            nCount += 1 
    return nCount
print("해당범위까지 자리수 합이 5의 배수인 숫자는: ",exercise13(100,10000),"개")



####################################연습문제 이어서#####################3
### 문제 14
## 6자리 이상 9자리 미만의 수를 하나 이용해요 
## 예) 234567      6522345
## 수의 중앙을 기준으로 두 개의 수로 분리
## 234567 => (234, 567)
## 6522345 => (652, 345)
## 두개의 수로 분리한 다음 큰 수를 선택 
## 이 작업을 계속 진행, 더 이상 나눌 수 없을때 가지 진행
## 예) 6522345 →  (352, 345)  →  652  →  (6, 2)  →  6
## 최종적으로 남은 수는 얼마? 

## 문제 14 답안지 
def exercise14(x):
    k = str(x)
    while len(k)>1:
        if len(k) % 2 == 0:   #len(k)가 짝수다 => 센터가 없다 
            F=int(k[:len(k)//2]) # 첫번재 부터 절반까지
            R=int(k[len(k)//2:len(k)]) #절반부터 후반까지
        else:     
            F=int(k[:len(k)//2]) #
            R=int(k[(len(k)//2)+1:])
            #밑의 if문 대조를 위해 일시적 int값으로 전환
        
        if F>R:
            k = str(F) #len을 출력받기 위해서 다시 str로 
        else:
            k = str(R)
            #return하면 함수가 끝난다. 
    return k 
print(exercise14(72189817))


####################################연습문제 이어서#####################3
### 문제 15
#2 ** 15 =  32768, 각 자리수의 합은 => 3+2+7+6+8 => 26
#2*1000 = ? 각 자리수의 합은? 
# 큰 자리수를 다룰 수 있는 python 은 매우 간단한 문제 
print(sum([int(x) for x in str(2**1000)]))	
	
		
		






