rk####################################################################
## (11월 19일 강의 내용) 
## 18일(21강) 강의 내용 복습 :
## python에서 수치 계산용으로 만든 패키지, numeric python(numpy)
## ndarray라고 불리는 자료구조를 사용 
## array : 연속적으로 할당되고 같은 데이터타입의 데이터를 저장할 수 있는 자료구조 
## 연속적으로 할당되어 있다는 것은 index를 쓸 수 있다는 뜻
## python에서도 배열 자료구조를사용가능하게 하는패키지 

## 기본적으로 생성하는 방법 
import numpy as np 
arr = np.array([1,2,3,4])

## python에서 built-in type 
## int, float, bool,str, list, tuple, dict, set 
## => 이 data type 이라고 알고 있던 내용들이 실제로는 따로 class로 존재하고 있음 
## python은 class에 기반한 객체들의 집합 
## (객체지향에 관련해서는 추후 ensemble)
print(type(arr)) #type함수  #<class 'numpy.ndarray'>
print(arr)       #np.array출력 #[1 2 3 4]

##numpy의 속성들 
print(arr.ndim) #.dim #차원의 수 #1
print(arr.shape) #.shape #차원과 원소의 수 #(4,)
print(arr.astype(np.int64)) #.astype #원소타입 변경(dtype)
print(arr.size) #.size ndarray안에 있는 모든 요소의 수(np에서 len()처럼 쓰임)
print(len(arr)) #1차원 요소의 수 #행의 개수 #python과 np에서 쓰의는 의미가 다름 

##2차원 이상의 ndarray 만들기 
##º중첩자료구조 만들기
myList = [[1,2,3],[4,5,6]]
arr = np.array(myList, dtype=np.float64) #dtype도 따로 설정 
print(arr)      #[[1 2 3]
                # [4 5 6]]

##다양한 생성방법
##ºnp.zeros(), np.ones(), np.full(), np.empty() 함수  
##ºnp.arange() #주어진 간격내에서 일정간격으로 nparray형성(range와 유사)
##ºnp.linspace() #특정 공간을 일정한 간격으로 조갬 
##random 기반의 함수들  -> rand, randint, random, seed

##########################################################################
## NumPy의 활용에 대해서 알아보아요 
## shape을 조절해서 내가 원하는 형태의 ndarray를 만들어보자 
import numpy as np

arr = np.arange(0,12,1) #1차원의 numpy arrange형성 
print(arr) #[ 0  1  2  3  4  5  6  7  8  9 10 11]

##2차원으로 변경 (가령 4행 3열으로) : reshape()함수 
## reshape를 이용하면 view가 만들어진다. 즉 data는 하나고 그것을 다른 차원으로 
## 보겠다는 뜻일 뿐 (1차원 데이터를 2차원으로 보는창을 형성하는 것 , 실제데이터는 하나)
## 원본데이터를 조작하면 view의 데이터도 조작된다. 
arr1 = arr.reshape(4,3)
print(arr1) #[[ 0  1  2]
            # [ 3  4  5]
            # [ 6  7  8]
            # [ 9 10 11]]

arr[1] = 100 #만약 arr의 2번째 값을 100으로 바꾼다면? 
print(arr) # [  0 100   2   3   4   5   6   7   8   9  10  11]
print(arr1) # [[  0 100   2]
            #  [  3   4   5]
            #  [  6   7   8]
            #  [  9  10  11]]
            
## *기본적으로 python은 view의 개념이 없다. np의 취지는 많은 데이터를 다루는 것이므로 
## 메모리를 효율적으로 쓰기위해 reshape과 같은 view의 개념이 적용된다.
## (데이터 처리를 할때마다 가공된 자료를 할당하는 것은 비호율적 )

## view는 base속성이 있다. 
## base : 어디서부터 데이터를 가져와서 보여주는 어디서 (여기선 당연히 arr)
print(arr1.base is arr) #두개는 같은가? #True 
print(arr1.base == arr) #각각의 칸 끼리 비교 
                        # [ True  True  True  True  True  True  True  True  True  True  True  True]
    
## shape을 변경해서 새로운 ndarary를 만들고 싶어요 (copy()함수이용)
arr = np.arange(0,12,1)
print(arr)
arr1 = arr.reshape(4,3).copy() #새로운 ndarray를 생성

## 형태에 맞게알아서 다차원 구조를 만들어보자(reshape(n,-1))
#arr1 = arr.reshape(5,3) #이 형태로 만들 수 없기 개문에 error발생
arr1 = arr.reshape(2,-1)
print(arr1)
#[[ 0  1  2  3  4  5]
# [ 6  7  8  9 10 11]] #2행 6열로 알아서 출력

arr1 = arr.reshape(-1,3)
print(arr1)
#[[ 0  1  2]
# [ 3  4  5]
# [ 6  7  8]
# [ 9 10 11]] #4행 3열로 알아서 출력 

## 반대로 다차원배열을 1차원으로 만들 수 있다.(ravel) 
arr = np.arange(0,100,1).reshape(5,-1).copy()
print(arr) #총 5행 20열짜리 2차원배열 형성 
arr1 = np.ravel(arr)
print(arr1) #1차원으로 깔끔하게 

## 통상 1차원 → 다차원 은 reshape, 다차원 → 1차원은 size 

## 함수 resize() : 
## resize()는 reshape()와 유사 
## reshape()은 형태가 맞지 않으면 변경시 error가 발생 
## 하지만 resize()는 형태가 맞지 않아도 변경이 가능 

arr = np.arange(0,10,1)
print(arr)  #[0 1 2 3 4 5 6 7 8 9]
arr1 = np.resize(arr,(2,6))
print(arr1) #[[0 1 2 3 4 5]
            # [6 7 8 9 0 1]] #circul, 모자라는 부분은 배열의 앞부터 다시채움
arr2 = np.resize(arr,(2,2))
print(arr2) #[[0 1]
            # [2 3]]  #남는 요소는 버린다. 

# ndarray를 직접이용하는 방법     
arr = np.arange(0,10,1)
result = arr.resize(2,3)    #원본이 바뀌고 return되지 않아요 
print(result) #none
print(arr)    #[[0 1 2]
              # [3 4 5]]
    
## numpy array를 가로방향으로 혹은 세로방향으로 결합 
## 2행 3열짜리 ndarray를 생성 

## 정수로 생성, 랜덤하게 균등분포로 0~10사이에서 추출 
## 6개를 추출해서 2차원 ndarray로 생성 
arr1 = np.random.randint(0,10,(2,3))
print(arr1)
## 가로방향으로 결합 (hstack())
## 행의 개수가 같아야 한다. 열의 개수는 상관없다. 
arr2 = np.random.randint(0,10,(2,5))
print(arr2)
result = np.hstack((arr,arr2))
print(result)

## 세로방향으로 결합 (vstack)
## 열의 개수가 같아야 한다. 행의 개수는 상관없다
arr1 = np.random.randint(0,10,(2,3))
arr2 = np.random.randint(0,10,(3,3))
result = np.vstack((arr1, arr2))
print(result)


################################
## ndaray 생성, 특징 
## reshape, resize => view개념(메모리를 효율적으로 사용하기 위해 )
## 여러개의 ndarray를 결합할 수 있다. 
#3 이제 indexing과 slicing에 대한 내용을 배울 것  





## Numpy array의 indexing과 slicing 
arr = np.arange(10,20,1)
print(arr) #[10 11 12 13 14 15 16 17 18 19]

for i in arr:      #data만 추출해서 사용하는 for 
    print("data : {}".format(i))
#data : 10
#data : 11
#data : 12
#data : 13
#data : 14
#data : 15
#data : 16
#data : 17
#data : 18
#data : 19

for idx, data in enumerate(arr):
    print("index : {}, data: {}".format(idx,data))
#index : 0, data: 10
#index : 1, data: 11
#index : 2, data: 12
#index : 3, data: 13
#index : 4, data: 14
#index : 5, data: 15
#vindex : 6, data: 16
#index : 7, data: 17
#vindex : 8, data: 18
#index : 9, data: 19
    
arr = np.arange(0,5,1)
print(arr) #[0 1 2 3 4]
print(arr[2]) #indexing #2 
print(arr[1:3]) #slicing #[1 2] 
print(arr[:3]) #slicing [0 1 2]
print(arr[2:]) #slicing [2 3 4]
print(arr[1::2]) # slicing[1 3]  :2 <-2칸씩 뛰어요 
print(arr[4::]) #맨 마지막 요소만 슬라이싱 할거야 
# 좀더 범용성 있게 코드를 주면 
print(arr[-1:]) #길이에 상관없이 맨 마지막거 slicing (마지막에서 끝까지) 

arr = np.arange(0,12,1).reshape(3,4).copy()
print(arr)
#[[ 0  1  2  3]
# [ 4  5  6  7]
# [ 8  9 10 11]]
print(arr[1,2]) #indexing #6
print(arr[:,0:1]) #[[0]
                  # [4]
                  # [8]]
# 만약 [5,6,9,10]을 뽑아내고 싶다면 
print(arr[1:2, 1:2].ravel()) #[5]
print(arr[1:3, 1:3].ravel()) #[ 5  6  9 10]




## Boolean Indexing & Fancy Indexing 
## boolean indexing은 mask를 이용해서 배열의 각 요소의 선택여부를 T,F로 지정하여 
## True요소만 선택하는 방식 

## ex/ 정수형 난수를 추출해보아요 
## 0부터 9까지 정수형 난수를 1차원으로 10개 균등분포를 이용하여 추출 
np.random.seed(1)
arr = np.random.randint(0,10,(10,))
print(arr) #[5 8 9 5 0 0 1 7 6 9]

## 여기에서 짝수만 추출할 거임 
result = list()
for i in arr:
    if i%2 == 0:
        result.append(i)
result = np.array(result)
print(result)  #[8 0 0 6]
## 이와 같이 로직을 이용해서 할 수 있지만 한방에 할 수 있는 방식이 있다. 

## boolean indenxing 적용
## 조건에 맞는 mask를 만들어요 
print(arr%2 == 0) #[False  True False False  True  True False False  True False]
print(arr[arr%2 == 0]) #[8 0 0 6]   #루프를 안돌고 한줄에 해결할 수 있다.(수행속도!)




## Fancy Indexing 적용 
arr = np.arange(0,12,1).reshape(3,4).copy()
print(arr)
#[[ 0  1  2  3]
# [ 4  5  6  7]
# [ 8  9 10 11]]
print(arr[2,2])   #10
print(arr[1:2,2]) #[6] #2행,3행에서 3열(slicing이니깐 1:2중 1만 찍힘)

#print(arr[행,열])
print(arr[0,2],) #2
print(arr[[0,2],2]) #[ 2 10]
print(arr[[0,2],1:]) #[[ 1  2  3]
                     # [ 9 10 11]]
print(arr[:,[0,2]])  # [[ 0  2]
                     #  [ 4  6]
                     #  [ 8 10]]
print(arr[[1,2],[1,2]]) # [ 5 10]  
                        # 출력?? 둘다 fancy indexing으로 뽑아내면 안됨.

#방법1
print(arr[[1,2]][:,[1,2]])
#  [[ 5  6]
#   [ 9 10]]

#방법2
print(arr[np.ix_([1,2],[1,2])])
#  [[ 5  6]
#   [ 9 10]]





## ndarray의 연산 
## R의 vector연산과 유사 
np.random.seed(1)
arr1 = np.arange(1,7,1).reshape(2,3).copy()
arr2 = np.random.randint(1,10,(2,3))
print(arr1)
#[[1 2 3]
# [4 5 6]]
print(arr2)
#[[6 9 6]
# [1 1 2]]

print(arr1 + arr2) #python의 list에서 + 연산하면 리스트가 늘어난다.(연결)
#[[ 7 11  9]       #numpy ndarray에서 + 연산은 vector연산(원소합)
# [ 5  6  8]]
 
print(arr1 + 10) # 원래는 연산이 안되야 정상(타입도 틀리고, 사이즈도 다르다)
#[[11 12 13]     # 이렇게 타입이 안맞는 경우 scalar값을 broadcasting 시키는 기능존재
# [14 15 16]]    # broadcasting: 행으로, 열로 늘리겠다. (2행3열짜리 10으로 채워진 ndarray)

arr2 = np.array([1,2,3])  #직접 원소를 기재한 1차원 nparray
print(arr1 + arr2)        # broadcasting: 
#[[2 4 6]                 #1차 배열 [1,2,3] =>  [[1,2,3]
# [5 7 9]]                #                     [1,2,3]]    

#* broadcasting이 다 되는 것은 아니다 
arr2 = np.array(1,2)
print(arr1 + arr2)        # 1차 배열 [1,2] => ?
                          # 에러가 드게 된다.(TypeError: data type not understood)





## 기본적인 집계(통계)함수
## numpy는 숫자처리에 최적화되어 있는 패키지여서 
## 빠르고 다양한 함수들을 제공한다. (사실 loop는 최후의 수단)
arr = np.arange(0,12,1).reshape(3,4).copy()
print(arr)
#[[ 0  1  2  3]
# [ 4  5  6  7]
# [ 8  9 10 11]]

#ndarray의 sum 함수
print(np.sum(arr)) #66, 실제 기능을 수행하는 함수
print(arr.sum()) #66, numpy의 method 
                 #기능적인 차이는없다 
#ndarray의 누적함수
print(np.cumsum(arr)) #1차원으로 변환
#[ 0  1  3  6 10 15 21 28 36 45 55 66]

#(드디어) ndarray에서는 평균도 구할수 있다.
print(np.mean(arr)) #5.5
# ndarray의 최대값
print(np.max(arr)) #11
# ndarray의 최소값
print(np.min(arr)) #0
# ndarray의 표준편차
print(np.std(arr)) #3.452052529534663
# ndarray의 제곱근
print(np.sqrt(arr)) 
#[[0.         1.         1.41421356 1.73205081]
# [2.         2.23606798 2.44948974 2.64575131]
# [2.82842712 3.         3.16227766 3.31662479]]

# 로그 및 상용로그를 구할 수 있다. 
#(log의 기원은 큰 수를 쉽게 계산하기 위하여 등장)
print(np.log10(arr)) # 자연로그, 상용로그를 사용할 수 있다. 
#[[      -inf 0.         0.30103    0.47712125]
# [0.60205999 0.69897    0.77815125 0.84509804]
# [0.90308999 0.95424251 1.         1.04139269]]


## axis : 축
## 축 개념을 이해해 보자 
## 위에 있는 집계함수를 이용할 때 axis 개념을 사용하게 된다. 
## 만약 axis를 명시하지 않으면, axis를 None으로 설정하고 대상범위를 ndarray로 지정 

## ex1/ 1차원 ndarray 
arr = np.arange(0,5,1)
print(arr) #[0 1 2 3 4] 
print(arr.sum()) #10  # axis를 명시하지 않은 경우 
print(arr.sum(axis=0)) #10 #1차원에서 axis=0 이면 '열 방향(→)'을 지칭함(축이 하나뿐)
#print(arr.sum(axis=1)) #에러(해당축이 1차원에서 존재하지 않음)

## ex2/ 2차원 ndarray 
arr = np.arange(0,12,1).reshape(3,4).copy()
print(arr)
#[[ 0  1  2  3]
# [ 4  5  6  7]
# [ 8  9 10 11]]
print(arr.sum())
# 66
print(arr.sum(axis=0)) # 2차원에서 axis=0이면 '행방향(↓)'을 지칭함 (행:열)
#[12 15 18 21]         # 반대로 axis=1이면 '열방향(→)'을 지칭 

## ex3/ 3차원 ndarray # 3차원은? (면:행:열) 
                      # 당연히 axis도 해당 순서를 따르지 않을까? 
    
## 정리
## 당연하게.. 일반 로직으로 프로그램하는것보다는 집계함수를 이용해서 처리하는게 훨씬 효율적




##응용
## 다음 ndarray에서 5보다 큰 값의 개수는? 
np.random.seed(1)
arr = np.random.randint(1,10,(2,5))
print(arr)
#[[6 9 6 1 1]
# [2 8 7 3 5]]
(arr>5).sum() #5
arr[arr>5].size #5 




## delete
## 맨날 들고오기만 했는데 지우는것도 알려줌 
## delete()함수는 axis을 기준으로 행과 열을 삭제
## axis를 지정하지 않으면 1차배열로 변환한 후 해당 요소를 삭제
## 원본은 유지하고 삭제된 복사본을 return

arr = np.arange(0,12,1).reshape(3,4).copy()
print(arr)
#[[ 0  1  2  3]
# [ 4  5  6  7]
#[ 8  9 10 11]]

# axis를 지정하지 않고 삭제 처리 
result = np.delete(arr,1) #1차 배열로 변환환 후 해당, 인덱스를 삭제 
print(result) #[ 0  2  3  4  5  6  7  8  9 10 11] #1이 날라감 

# axis를 지정하면? 
result = np.delete(arr,1,axis=0) #1차 배열로 변환한 후 해당 인덱스를 삭제
print(result)                    #행 방향으로 1 => 4,5,6,7 날라감
#[[ 0  1  2  3]
# [ 8  9 10 11]]





####################연습문제(11/19)##############################
%%time
### 문제 11. 
## 피타고라스 정리 a^2 + b^2 = c^2 와 같이되는 자연수 a,b,c가 있을 때  ex/ 3,4,5 
## 이런 특징을 가지는 수에 대해서 a+b+c = 1000인 피타고라스 수는 1개만 존재 
## 이때 a*b*c 는? 
## 1) 피타고라스 여부를 따지는 함수 1 생성
## 2) 1000까지의 범위내 해당하는 a,b,c를 찾는 제어문
## 3) 출력문에 곱하고 출력 

# 1) 
def pythagoras(a, b, c):
    if a ** 2 + b ** 2 == c ** 2:
        return True
    return False


for num in range(1,1000):
    for dig in range(num, 1001 - num):
        for i in range(dig, 1001 - dig):
            if num + dig + i == 1000:
                if pythagoras(num, dig, i):
                    print(num, dig, i)
                    print("세 값의 곱은: {}".format(num * dig * i)) #3)
              
                  
######	
		
%%time
##다른 방법 (알고리즘을 간소화해보자)
for a in range(1, 333):
    for b in range(a, 666 - a):
        c = 1000 - a - b
        if (a*b) + (1000*c) == 500000: #(a+b+c)^2 = 1000^2
            print(a, b, c)
            print("세 값의 곱은: {}".format(a * b * c))
            

## 문제 12. (콜라츠 추측)
## 양의 정수 n에 대해서 다음과 같은 계산 과정을 반복합니다. 
## n이 짝수일 경우 => n -> n/2 
## n이 홀수일 경우 => n -> 3 * n +1 
## 가령 13이라는 정수 n에 대해서 위의 규칙을 적용해본다면 
## 13 *3+ 1 -> 40 -> 20 ->10 ->5 -> 16 -> 8 -> 4 -> 2 ->1 
## 1,000,000이하의 수로 시작했을 때 1까지 도달하는데 가장 긴 과정을 거치는 수는 얼마인가요?
## 추가) numpy를 활용해서 풀어보자(list보다는 nbarray)

##1) 콜라츠 추측에 대한 개요함수 설정 
##2) 콜라츠 추측이 반복적으로 이어질 수 있는 제어문 설정(<1,000,000)
##3) 제어문이 돌 때마다 개수를 세어주는 함수 설정 -> 변수 할당 
##4) 가장 많이 돈 nbarray(횟수, 값 perhaps) 출력하기 

##해당하는 숫자에 대한 콜라츠 추출 과정을 나타내는 함수 생성 
def collatz(n):
    print(n)
    while not n==1: #1부터 제외 
        if n%2==0:
            n=n/2
       
        else:
            n=n*3+1
        print(n)
    return
collatz(1999)


##함수변경 
##반복 후 세어주는 걸로다 이전 함수를 변경 
def collatz(n):
    if n == 1: 
        return 1
    elif (n) in count :
        return count[n]
    elif n%2==0:
        return collatz(n/2) +1
    else:
        return collatz(n*3+1) +1
collatz(837799)


#함수변경 
#반복 후 세어주는 걸로다 
count = {}
def collatz(n):
    if n == 1: 
        return 1
    elif (n) in count :
        return count[n]
    elif n%2==0:
        return collatz(n/2) +1
    else:
        return collatz(n*3+1) +1
collatz()


%%time
##최종1(numpy 미사용)
count = {}
def collatz(n):
    if n == 1: 
        return 1
    elif n in count :
        return count[n]
    elif n%2==0:
        return collatz(n/2) +1
    else:
        return collatz(n*3+1) +1
 
i=1; 
maxTimes=0;

for i  in range(1, 1000000):
    times = collatz(i)
    if times > maxTimes : 
        maxTimes = times
        maxValue = i
    count[i] = times
    i+=1
     
print("가장 귀찮은 수는: %d, %d회"  %(maxValue,maxTimes))


%%time
##최종2(numpy 미사용, 선언한 변수 제거(개별 사용x))

def collatz(n):
    if n == 1: 
        return 1
    elif n in count :
        return count[n]
    elif n%2==0:
        return collatz(n/2) +1
    else:
        return collatz(n*3+1) +1
 

i=1; 
maxTimes=0;

for i  in range(1, 1000000):
    times = collatz(i)
    if times > maxTimes : 
        maxTimes = times
        maxValue = i
    i+=1
     
print("가장 귀찮은 수는: %d, %d회"  %(maxValue,maxTimes))




	