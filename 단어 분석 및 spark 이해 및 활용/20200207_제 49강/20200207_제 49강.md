- join 이란?

> 하나 이상의 테이블로부터 동일한 속성의 컬럼값이 일치할 때 (두 테이블의) 레코드를 결합해서 검색하는 연산
>
> (http://www.gurubee.net/lecture/1879)
>
> → 동일한 속성이 테이블 상호간에 있는지부터 확인하여야 한다. 
>
> *  문법 
>
>   > where 절에 조인 조건 선언
>   >
>   > sql 1999표준 조인 문법(from 절 조인 선언)
>
> * 종류 
>
> > equi join(inner join) 
> >
> > >  조인할 두 테이블에서 동일한 속성의 컬럼값이 일치할 때(=연산자 사용)
> > >
> > >  - \- 일반 조인시 ,(콤마)를 생략하고 INNER JOIN을 추가하고, WHERE절 대신 ON절을 사용하면 된다.
> > >  - \- INNER는 생략 가능 하다.
> > >  - \- 아래 두 조인의 결과 값은 같다.
> >
> > non-equi join 
> >
> > > 조인할 두 테이블에서 동일한 속성의 컬럼이 존재하지 않은 경우
> > >
> > > (=가 아닌 다른 연산자를 사용해서 조인 조건을 선언 )
> >
> > self-join 
> >
> > >  조인할 두 테이블이 동일한 테이블(하나의 테이블에서 PK를 참조하는 FK가 존재하는 경우로서 자기참조 가능한 테이블)로부터 레코드를 결합해서 검색 
> >
> > outer join  
> >
> > > equi join에서 조인할 두 테이블에서 동일한 속성의 컬럼값이 일치할 때 레코드를 결합해서 검색 결과를 생성하므로, 조인할 컬럼 중 하나가 null 인 경우는 조인 결과집합에서 레코드가 누락되지 않고 결과집합에 가져오기 위해 수행하는 join 
> >
> > cartesian product(cross join)
> >
> > > ```sql
> > > conn hr /oracle -- hr게정 접속 
> > > Q. 사원번호, 사원이름, 소속부서번호, 소속부서 이름을 검색 
> > > select employees_id, last_name, department_id, department_name
> > > from employees, departments; --오류, 조인조건누락 
> > > 
> > > select a.employee_id, a.last_name, a.department_id, b.department_name
> > > from employees a, departments b; --cartesian product(2889 = 107 * 27)
> > > 
> > > select  a.employee_id, a.last_name, a.department_id, b.department_name
> > > from employees a  , departments b
> > > where a.department_id = b.department_id; --equi join(106 rows, 하나누락)
> > > --a.employee_id 는 primary key 가 아니여서 null 허용인 record가 있음 
> > > --null을 가져오고 싶다면 outer join 필요 
> > > ```
> > >
> > > 조인조건이 누락되면 조인할 테이블의 레코드가 전체 레코드에 대해서 한번씩 조인됨 
> >
> > natural join
> >
> > > 조인할 두 테이블에서 동일한 이름의 컬럼값이 일치할 때 조인 결과를 생성 
> > >
> > > (동일한 이름의 컬럼앞에 소유자(테이블명, alias)를 선언하지 않습니다. )
> > >
> > > - \- Equi Join과 동일 하다고 보면 된다.
> > > - \- 두 테이블의 동일한 이름을 가지는 칼럼은 모두 조인이 된다.
> > > - \- 동일한 컬럼을 내부적으로 찾게 되므로 테이블 Alias를 주면 오류가 발생 한다.
> > > - \- 동일한 컬럼이 두개 이상일 경우 JOIN~USING 문장으로 조인되는 컬럼을 제어 할 수 있다.
> > > - \- 아래 두 조인의 결과 값은 같다.
> > >
> > > ``` sql
> > > select a.employee_id, a.last_name, a.department_id, b.department_name
> > > from employees a natural join departments b; --error
> > > 
> > > select a.employee_id, a.last_name, department_id, b.department_name 
> > > from employees a natural join departments b; --32행 
> > > -- a.department_id = b.department_id and a.manager_id = b.manager_id
> > > ```
> >
> > join ~using(column name)
> >
> > > 동일한 이름의 속성이 여러개인 테이블을 조인할 때, 하나의 컬럼으로만 equi방식 조인을 수행
> > >
> > > - \- NATURAL JOIN의 단점은 동일한 이름을 가지는 칼럼은 모두 조인이 되는데, USING 문을 사용하면 컬럼을 선택해서 조인을 할 수가 있다.
> > > - \- USING절 안에 포함되는 컬럼에 Alias를 지정하면 오류가 발생 한다.
> > >
> > > ```sql
> > > select a.employee_id, a.last_name, department_id, b.department_name
> > > from employees a join departments b using(department_id); --106행 
> > > ```
> >
> > join ~on 
> >
> > > 두 테이블의 조인 컬럼이름이 다른 경우 join~on 조건을 쓴다. 
> > >
> > > - 조인 조건을 지정 할 수 있다.
> > > - \- 모든 논리 연산 및 서브쿼리를 지정할 수 있다.
> > >
> > > ```sql
> > > Q. 사원번호, 사원이름, 소속부서번호, 소속부서이름을 검색
> > > select a.empno, a.ename, a.deptno, b.dname
> > > from emp a  join dept2 b on a.deptno = b.deptid;
> > > ```
> > >
> > > 

---

